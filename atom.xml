<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只会敲代码的Sheep</title>
  
  <subtitle>Koyang&#39;Blog</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-13T03:33:10.589Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Koyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序学习(今日天气)</title>
    <link href="http://yoursite.com/archives/wxxcx.html"/>
    <id>http://yoursite.com/archives/wxxcx.html</id>
    <published>2021-07-12T01:45:49.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<p>这个是记录微信小程序的学习，开发一款今日天气<br>目前完成</p><ul><li>获取实时位置信息并显示天气信息</li><li>手动选择位置信息并获取天气</li></ul><p>所用<code>api</code>来自和风天气,请自行注册<code>key</code>,代码中的<code>key</code>皆用<code>****</code>表示。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>打开微信开发工具<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210712083155.png"></p><h2 id="删除所有内容"><a href="#删除所有内容" class="headerlink" title="删除所有内容"></a>删除所有内容</h2><p>删除初始化所有内容并新建<code>app.json</code>、<code>app.js</code>、<code>app.wxss</code>,在新建的<code>app.json</code>中输入<code>&#123;&#125;</code>并保存。</p><h2 id="新建page"><a href="#新建page" class="headerlink" title="新建page"></a>新建page</h2><p>在<code>pages/index</code>目录下右键新建<code>page</code><br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210712084526.png"></p><h2 id="文件作用"><a href="#文件作用" class="headerlink" title="文件作用"></a>文件作用</h2><ul><li>js:页面逻辑 (JavaScript)</li><li>json:负责标题栏和一些状态栏</li><li>wxml:管理页面有什么 (html)</li><li>wxss:页面排版 (css)</li></ul><h2 id="修改标题栏"><a href="#修改标题栏" class="headerlink" title="修改标题栏"></a>修改标题栏</h2><p>修改<code>app.json</code>文件，输入<code>window</code><br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210712100817.png"></p><h2 id="编写index-wxml内容"><a href="#编写index-wxml内容" class="headerlink" title="编写index.wxml内容"></a>编写<code>index.wxml</code>内容</h2><p>相当于编写小程序页面有什么内容</p><pre><code class="html">&lt;view class=&quot;container&quot;&gt;      &lt;!-- 区域一 选择器 --&gt;    &lt;picker mode=&quot;region&quot; bindchange=&quot;ChangeRegion&quot;&gt;      &lt;view&gt;&#123;&#123;region&#125;&#125;&lt;/view&gt;    &lt;/picker&gt;      &lt;!-- 区域二 文本区 --&gt;    &lt;text&gt;&#123;&#123;now.temp&#125;&#125; ℃ &#123;&#123;now.text&#125;&#125;&lt;/text&gt;      &lt;!--区域三 图片  --&gt;      &lt;image src=&quot;../../images/&#123;&#123;now.icon&#125;&#125;.png&quot;&gt;&lt;/image&gt;      &lt;!-- 区域四 天气信息 --&gt;      &lt;view class=&quot;detail&quot;&gt;          &lt;view class=&quot;bar&quot;&gt;              &lt;view class=&quot;box&quot;&gt;湿度&lt;/view&gt;              &lt;view class=&quot;box&quot;&gt;气压&lt;/view&gt;              &lt;view class=&quot;box&quot;&gt;能见度&lt;/view&gt;          &lt;/view&gt;          &lt;view class=&quot;bar&quot;&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.humidity&#125;&#125; %&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.pressure&#125;&#125; hPa&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.vis&#125;&#125; Km&lt;/view&gt;          &lt;/view&gt;          &lt;view class=&quot;bar&quot;&gt;            &lt;view class=&quot;box&quot;&gt;风向&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;风速&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;风力&lt;/view&gt;          &lt;/view&gt;          &lt;view class=&quot;bar&quot;&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.windDir&#125;&#125;&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.windSpeed&#125;&#125; Km/h&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.windScale&#125;&#125; 级&lt;/view&gt;          &lt;/view&gt;      &lt;/view&gt;&lt;/view&gt;</code></pre><h2 id="编写逻辑代码index-js"><a href="#编写逻辑代码index-js" class="headerlink" title="编写逻辑代码index.js"></a>编写逻辑代码<code>index.js</code></h2><pre><code class="js">Page(&#123;  data: &#123;      region:[&quot;北京市&quot;,&quot;北京市&quot;,&quot;东城区&quot;],      location:&quot;&quot;,      now:&#123;&quot;icon&quot;:999&#125;  &#125;,  onLoad:function()&#123;      this.getnowlocation();  &#125;,  ChangeRegion:function(e)&#123;    this.setData(&#123;      region:e.detail.value    &#125;)    this.getLocation()  &#125;,  getLocation:function()&#123;    var that=this;       wx.request(&#123;         url: &#39;https://geoapi.qweather.com/v2/city/lookup?&#39;,         data:&#123;           key:&#39;****&#39;,           location:that.data.region[2]         &#125;,         success:function(res)&#123;           that.setData(&#123;location:res.data.location[0].id&#125;);           that.getWeather();          &#125;        &#125;)      &#125;,  getnowlocation:function()&#123;    var that=this;    wx.getLocation(&#123;      type:&#39;wgs84&#39;,      success (res) &#123;        that.setData(&#123;location:res.longitude+&quot;,&quot;+res.latitude&#125;)        that.setCity();        that.getWeather();        &#125;    &#125;)  &#125;,  setCity:function()&#123;    var that=this;    wx.request(&#123;      url: &#39;https://geoapi.qweather.com/v2/city/lookup?&#39;,      data:&#123;        key:&#39;****&#39;,        location:that.data.location      &#125;,      success:function(res)&#123;        console.log(res.data.location[0])        that.setData(&#123;          region:[res.data.location[0].adm1,res.data.location[0].adm2,res.data.location[0].name]        &#125;)      &#125;    &#125;)  &#125;,  getWeather:function()&#123;      var that=this;      wx.request(&#123;        url: &#39;https://devapi.qweather.com/v7/weather/now?&#39;,        data:&#123;          key:&#39;****&#39;,          location:that.data.location        &#125;,        success:function(res)&#123;           that.setData(&#123;now:res.data.now&#125;)        &#125;      &#125;)  &#125;&#125;)</code></pre><h2 id="编写排版文件index-wxss"><a href="#编写排版文件index-wxss" class="headerlink" title="编写排版文件index.wxss"></a>编写排版文件<code>index.wxss</code></h2><pre><code class="css">.container&#123;  height: 100vh;  display: flex;  flex-direction: column;  align-items: center;  justify-content: space-around;&#125;.detail&#123;  width: 100%;  display: flex;  flex-direction: column;&#125;.bar&#123;  margin: 20rpx 0;  display: flex;  flex-direction: row;&#125;.box&#123;  width: 33.3%;  text-align: center;&#125;</code></pre><h2 id="最终样式"><a href="#最终样式" class="headerlink" title="最终样式"></a>最终样式</h2><p>加入了打开时获取当前位置信息，需要授权位置信息获取权限，稍后可以手动选择查询位置<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210713112518.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个是记录微信小程序的学习，开发一款今日天气&lt;br&gt;目前完成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取实时位置信息并显示天气信息&lt;/li&gt;
&lt;li&gt;手动选择位置信息并获取天气&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所用&lt;code&gt;api&lt;/code&gt;来自和风天气,请自行注册&lt;code&gt;key&lt;</summary>
      
    
    
    
    <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows Terminal的美化</title>
    <link href="http://yoursite.com/archives/wterminal.html"/>
    <id>http://yoursite.com/archives/wterminal.html</id>
    <published>2021-07-11T01:45:49.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h2><p>与一般软件的设置界面不同，Windows Terminal 采用 json 文件对 Terminal 进行设置。单击设置，会打开一个settings.json的文件。现在的Windows 10应该会在你点击“设置”后提示你用什么软件来打开json文件。</p><h2 id="Windows-Terminal-美化"><a href="#Windows-Terminal-美化" class="headerlink" title="Windows Terminal 美化"></a>Windows Terminal 美化</h2><h3 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h3><p>设置中可以选择预设配置配色和字体，新版加入了可视化设置,可以设置透明度(毛玻璃)<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1625993057000.png"></p><h3 id="安装-Powerline-字体"><a href="#安装-Powerline-字体" class="headerlink" title="安装 Powerline 字体"></a>安装 Powerline 字体</h3><p>下载 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Meslo.zip">Meslo LGM NF 1</a>字体来支持 Oh-my-Posh V3 的特殊符号</p><h3 id="安装-posh-git-以及-oh-my-posh"><a href="#安装-posh-git-以及-oh-my-posh" class="headerlink" title="安装 posh-git 以及 oh-my-posh"></a>安装 posh-git 以及 oh-my-posh</h3><pre><code class="CMD">Install-Module posh-git -Scope CurrentUserInstall-Module oh-my-posh -Scope CurrentUser</code></pre><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1625993195000.png"></p><h3 id="在-PowerShell-中设置-Powerline"><a href="#在-PowerShell-中设置-Powerline" class="headerlink" title="在 PowerShell 中设置 Powerline"></a>在 PowerShell 中设置 Powerline</h3><p>在 PowerShell 中输入<code>notepad $profile</code>用文本文档打开 PowerShell 配置文件。</p><pre><code class="CMD">Import-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme Paradox</code></pre><p>现在，每个新实例启动时都会导入 Posh-Git 和 Oh-My-Posh，然后从 Oh-My-Posh 设置 Paradox 主题。<a href="https://ohmyposh.dev/docs/themes">内置主题</a>。</p><h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><ol><li>win10左下角点击logo，找到Windows Powershell，右击，然后以管理员身份打开.</li><li>输入<pre><code class="CMD">get-ExecutionPolicy   # 查看系统执行策略状态set-executionpolicy remotesigned # 修改执行策略状态</code></pre></li><li>重新打开</li></ol><h3 id="PowerShell-的更新"><a href="#PowerShell-的更新" class="headerlink" title="PowerShell 的更新"></a>PowerShell 的更新</h3><p>自带的 PS 版本　是 5.0 的 ，可以升级到更高版本， 目前稳定版本为 7.x</p><pre><code class="CMD">$PSVersionTable.PSVersion.Major   #查看Powershell版本$PSVersionTable.CLRVersion.Major  #查看.NET Framework版本</code></pre><p>在<a href="https://github.com/PowerShell/PowerShell/releases">这里</a>找到<code>**x64.msi</code>,下载安装即可。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1625994201000.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Windows-Terminal&quot;&gt;&lt;a href=&quot;#Windows-Terminal&quot; class=&quot;headerlink&quot; title=&quot;Windows Terminal&quot;&gt;&lt;/a&gt;Windows Terminal&lt;/h2&gt;&lt;p&gt;与一般软件的设置界面不同，W</summary>
      
    
    
    
    <category term="Windows" scheme="http://yoursite.com/categories/Windows/"/>
    
    
    <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Windows" scheme="http://yoursite.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>PYQT5的安装配置使用</title>
    <link href="http://yoursite.com/archives/pyqt5.html"/>
    <id>http://yoursite.com/archives/pyqt5.html</id>
    <published>2021-03-27T13:02:30.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装PYQT5"><a href="#安装PYQT5" class="headerlink" title="安装PYQT5"></a>安装PYQT5</h2><ol><li>pyqt5安装</li></ol><ul><li>直接使用pip安装,但是需要SIP的支持,所以先安装SIP,再安装pyqt5<pre><code class="cmd">pip install sippip install PyQt5</code></pre><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1616852334000.png"></li></ul><ol start="2"><li>安装QT Designer</li></ol><ul><li>同样使用pip安装<br><code>pip install PyQt5-tools</code></li></ul><h2 id="在Pycharm中配置QT-Designer"><a href="#在Pycharm中配置QT-Designer" class="headerlink" title="在Pycharm中配置QT Designer"></a>在Pycharm中配置QT Designer</h2><h3 id="配置QT-Designer"><a href="#配置QT-Designer" class="headerlink" title="配置QT Designer"></a>配置QT Designer</h3><ul><li>QT Designer默认路径<code>C:\Users\用户名\AppData\Local\Programs\Python\Python38\Lib\site-packages\qt5_applications\Qt\bin</code><blockquote><ul><li>Name：可自己定义 <ul><li>Program：指向上述路径里面的designer.exe</li><li>Work directory：使用变量 $FileDir$</li></ul></li></ul></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1616852877000.png"></p><h3 id="配置PyUIC"><a href="#配置PyUIC" class="headerlink" title="配置PyUIC"></a>配置PyUIC</h3><blockquote><ul><li>Name：可自己定义</li><li>Program：指向上述python.exe(默认<code>C:\Users\codeyang\AppData\Local\Programs\Python\Python38\python.exe</code>)</li><li>Arguments: <code>-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py</code></li><li>Work directory：使用变量 $FileDir$</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1616853200000.png"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在顶部<code>工具</code>栏中可以找到这两个工具</p><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1616853416000.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装PYQT5&quot;&gt;&lt;a href=&quot;#安装PYQT5&quot; class=&quot;headerlink&quot; title=&quot;安装PYQT5&quot;&gt;&lt;/a&gt;安装PYQT5&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;pyqt5安装&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;直接使用pip安装,但是需要SI</summary>
      
    
    
    
    <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github Actions自动化部署</title>
    <link href="http://yoursite.com/archives/hexoaction.html"/>
    <id>http://yoursite.com/archives/hexoaction.html</id>
    <published>2021-03-05T02:28:32.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="一，import这个仓库"><a href="#一，import这个仓库" class="headerlink" title="一，import这个仓库"></a>一，import这个仓库</h3><p>点击新建一个仓库，你会在新建仓库页面看到这个<code>Import a repository</code>，点它</p><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921213026.png"></p><p>然后你会看到如下图的内容</p><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921213146.png"></p><p>在<code>You old repository&#39;s clone URL</code>下填我这个项目的链接</p><pre><code class="html">https://github.com/FuShaoLei/auto-hexo-template</code></pre><p>然后为了安全起见（或者说是为了隐私起见），将仓库设为<code>private</code></p><p>都设置完后点击下面那个绿色按钮<code>Begin import</code>即可</p><p>完成时如下</p><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921213520.png"></p><h3 id="二，根据你的情况修改参数"><a href="#二，根据你的情况修改参数" class="headerlink" title="二，根据你的情况修改参数"></a>二，根据你的情况修改参数</h3><p>要配置的有</p><ul><li>配置公钥和私钥</li><li><code>.github/workflows/main.yml</code>里的用户名和邮箱</li><li><code>_config.yml</code>里的<code>root</code>和<code>deploy</code></li></ul><p>下面一一说明</p><h4 id="a-配置公钥和私钥"><a href="#a-配置公钥和私钥" class="headerlink" title="a.配置公钥和私钥"></a>a.配置公钥和私钥</h4><p>在你的本地<code>ctrl+r</code>输入<code>cmd</code>调出小黑块，输入</p><pre><code>ssh-keygen -t rsa -C &quot;&lt;你的github邮箱&gt;&quot;</code></pre><p>然后在<code>C:\Users\用户名\.ssh</code>中可找到</p><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200920221956.png"></p><ul><li>公钥的配置（正常来说应该是配置过了），直接在这个<a href="https://github.com/settings/keys">链接</a>点击那个new SSH key就可配置</li><li>私钥的配置，点击 <a href="https://github.com/">https://github.com/</a>&lt;你的用户名&gt;/&lt;存放源文件的仓库名&gt;/settings/secrets，新建私钥，注意，这里的名称要填<code>HEXO_DEPLOY_PRIVATE_KEY</code></li></ul><h4 id="b-配置-github-workflows-main-yml里的用户名和邮箱"><a href="#b-配置-github-workflows-main-yml里的用户名和邮箱" class="headerlink" title="b.配置.github/workflows/main.yml里的用户名和邮箱"></a>b.配置<code>.github/workflows/main.yml</code>里的用户名和邮箱</h4><p>这个不多说了，底部可以找到<br><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921214724.png"></p><h4 id="c-配置-config-yml里的root和deploy"><a href="#c-配置-config-yml里的root和deploy" class="headerlink" title="c.配置_config.yml里的root和deploy"></a>c.配置<code>_config.yml</code>里的<code>root</code>和<code>deploy</code></h4><p>如果你部署的仓库名是<code>&lt;你的github用户名&gt;.github.io</code>），那么用默认的就行了，如果不是的话，要改成</p><pre><code class="yml">root: /&lt;仓库名&gt;/</code></pre><p>然后是<code>deploy</code>，大家根据自己的需求来改就好了</p><pre><code class="yml">deploy:  type: git  repository: git@github.com:&lt;你的用户名&gt;/&lt;部署hexo的仓库名&gt;.git  branch: master</code></pre><h3 id="三，允许使用github-aciton即可"><a href="#三，允许使用github-aciton即可" class="headerlink" title="三，允许使用github aciton即可"></a>三，允许使用github aciton即可</h3><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921215108.png"></p><p>点击那个绿色的按钮即可</p><h3 id="四，自定义修改"><a href="#四，自定义修改" class="headerlink" title="四，自定义修改"></a>四，自定义修改</h3><ul><li>如果你使用了第三方主题，需要把主题目录的<code>.gitinit</code>删除后才能<code>push</code></li><li>如果你安装了第三方插件或一些主题需要的插件，需要在<code>mian.yml</code>中依次添加<code>npm</code>命令<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1614911848000.png"></li></ul><h3 id="五，编写文章"><a href="#五，编写文章" class="headerlink" title="五，编写文章"></a>五，编写文章</h3><p>每次本地写完文章后，只需要往源文件仓库<code>push</code>更新源文件，<code>GitHub Actions </code>监控到<code>push </code>操作时，就自动化执行<code> hexo clean</code>、<code>hexo g -d </code>操作，完成博文发布。这样可以将部署放到<code>Github Actions</code>,避免更换电脑或重装系统后每次都要重新下载部署配置的问题。进阶操作是配合<a href="https://github.com/HexoPlusPlus/HexoPlusPlus">HexoPlusPlus</a>,给Hexo加个后端管理界面，完美脱离本地主机，完全部署到云端</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用步骤&quot;&gt;&lt;a href=&quot;#使用步骤&quot; class=&quot;headerlink&quot; title=&quot;使用步骤&quot;&gt;&lt;/a&gt;使用步骤&lt;/h2&gt;&lt;h3 id=&quot;一，import这个仓库&quot;&gt;&lt;a href=&quot;#一，import这个仓库&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
    <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java打包程序.exe</title>
    <link href="http://yoursite.com/archives/javaexe.html"/>
    <id>http://yoursite.com/archives/javaexe.html</id>
    <published>2021-01-09T02:28:32.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<p>Java编写的程序需要在有jre环境的设备上才能运行，在我们编写完程序后发给别人使用时，不能保证每个人的设备都安装有Java运行环境，所以需要将源码和运行所需要的环境打包成特定的可执行文件，比如Windows平台的可执行文件是.exe。</p><h2 id="新建一个项目目录"><a href="#新建一个项目目录" class="headerlink" title="新建一个项目目录"></a>新建一个项目目录</h2><p><strong>里面包含<code>file</code>、<code>res</code>、<code>jre</code>;</strong></p><ul><li>file:文件夹是放临时文件的可以没有</li><li>res:文件夹是放资源文件的，如图片，配置文件等也可以没有</li><li>jre:这个是必须的，该文件中的内容可以直接把JDK安装目录下jre的内容拷贝过来即可。有了它可以不用再装java运行环境 </li></ul><h2 id="将源码导出"><a href="#将源码导出" class="headerlink" title="将源码导出"></a>将源码导出</h2><p>第一步所需要的是将我们编写的Java整个项目导出成jar包。<br>在<code>IDEA</code>中<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210109104200.png" alt="20210109104200"><br>在项目结构中选取<img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210109104402.png" alt="20210109104402">选取主类即可导出<code>jar</code>包</p><h2 id="JRE环境"><a href="#JRE环境" class="headerlink" title="JRE环境"></a>JRE环境</h2><p>将安装的JRE环境拷贝到项目目录的<code>jre</code>文件夹里，如果不知道可以将整个<code>JRE</code>环境拷贝过来</p><h2 id="下载exe4j工具"><a href="#下载exe4j工具" class="headerlink" title="下载exe4j工具"></a>下载<code>exe4j</code>工具</h2><p><a href="https://www.ej-technologies.com/download/exe4j/files">下载地址</a></p><h2 id="打开exe4j开始生产-exe文件"><a href="#打开exe4j开始生产-exe文件" class="headerlink" title="打开exe4j开始生产.exe文件"></a>打开<code>exe4j</code>开始生产<code>.exe</code>文件</h2><ol><li>选择<code>JAR in EXE</code>模式<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/1.png"></li><li>名字和输出目录随便写<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/2.png"></li><li>选<code>GUI application</code><br><code>Executable name</code>写的.exe名字<br><code>Icon File</code>找到要的icon图标<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/3.png"></li><li>在<code>class path</code>中找到刚才导出的<code>jar</code>包<br>在<code>main class from</code>找到主类(有<code>main</code>方法的类)<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/4.png"></li><li>在<code>Advanced Options</code>选<code>Search sequence</code><br>删除默认的路径，把项目目录拷贝的<code>jre</code>环境选中<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/5.png"></li><li>默认即可<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/7.png"></li><li>生成成功<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/8.png"><br>点击即可打开测试</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在项目于目录就有一个<code>.exe</code>后缀的文件，打开即可运行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java编写的程序需要在有jre环境的设备上才能运行，在我们编写完程序后发给别人使用时，不能保证每个人的设备都安装有Java运行环境，所以需要将源码和运行所需要的环境打包成特定的可执行文件，比如Windows平台的可执行文件是.exe。&lt;/p&gt;
&lt;h2 id=&quot;新建一个项目</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
    <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Fine in Codes</title>
    <link href="http://yoursite.com/archives/fineincode.html"/>
    <id>http://yoursite.com/archives/fineincode.html</id>
    <published>2020-11-22T11:40:32.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul><li>Code<pre><code class="Python">End = &quot;You&quot;while End is &quot;You&quot;:  print &quot;I wait %s&quot; % End</code></pre><blockquote><p>尽头是你我会一直等</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture//20201122195115.png"></p><h2 id="附文"><a href="#附文" class="headerlink" title="附文"></a>附文</h2><p>经常写爬虫，然后就爱上了<code>response</code>这个单词。有道词典给的翻译是：<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture//20201122200615.png"><br>最理想的状态就像：</p><pre><code class="Python">import requestsurl = &quot;everything&quot;params=&#123;&#125;data=&#123;&#125;response = requests.get(url,params=params,data=data)print(response)</code></pre><blockquote><p>事事有回应，件件有着落</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture//20201122201033.png"></p><blockquote><p>没有<code>&#39;params&#39;</code>和<code>&#39;data&#39;</code>，依然可以得到回应</p></blockquote><blockquote><p>它的应用场景应是我发消息不会等很久你才会回，和你聊天时你如果有事情要离开会提前告知我并结束话题。我不用花很多时间去等待，也不用花很多心思去猜疑，你给予我良好的反馈，于我亦是一种心安。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Code&lt;pre&gt;&lt;code class=&quot;Python&quot;&gt;End = &amp;quot;You&amp;quot;
while End is</summary>
      
    
    
    
    <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
    <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
    <category term="网站搭建" scheme="http://yoursite.com/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Clash Premium For Magisk的使用</title>
    <link href="http://yoursite.com/archives/cpfm.html"/>
    <id>http://yoursite.com/archives/cpfm.html</id>
    <published>2020-10-11T01:35:10.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Clash-Premium-For-Magisk的用途"><a href="#Clash-Premium-For-Magisk的用途" class="headerlink" title="Clash Premium For Magisk的用途"></a>Clash Premium For Magisk的用途</h2><p>Google NB！</p><h2 id="需要文件下载地址"><a href="#需要文件下载地址" class="headerlink" title="需要文件下载地址"></a>需要文件下载地址</h2><p><a href="https://www.lanzoux.com/ifTojhc1i0d">Clash_Premium_For_Magisk</a></p><p><a href="https://www.lanzoux.com/inFhFhc1ixg">Dashboard</a></p><h2 id="面具刷入"><a href="#面具刷入" class="headerlink" title="面具刷入"></a>面具刷入</h2><p>Root后用面具刷入Clash Premium For Magisk/Clash For Magisk</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-093248.jpg" alt="Screenshot_20201011-093248"></p><p>刷入完成后重启这个时候clash就在后台运行了，担心需要<code>termux</code>来开启服务，下面介绍一个<code>Dashboard APP</code>这个图形化控制界面</p><h2 id="Dashboard-APP"><a href="#Dashboard-APP" class="headerlink" title="Dashboard APP"></a>Dashboard APP</h2><p>打开<code>Dashboard APP</code>，再点击<code>Premium</code>切换到<code>Premium</code>模式</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-093307.jpg" alt="Screenshot_20201011-093307"></p><p>右上角菜单，选择更新GeoIP，无需输入地址，点击确定来下载GeoIP文件，这是Clash工作所需要的文件。</p><p>再下载<code>config.yml</code>文件<img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-093320.jpg" alt="Screenshot_20201011-093320"></p><p>点击下载订阅，输入clash订阅地址<img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-093330.jpg" alt="Screenshot_20201011-093330"></p><p>下载完订阅地址就重新打开应用，然后开启<code>clash</code></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-094622.jpg" alt="Screenshot_20201011-094622"></p><p>这个时候就可以上网了</p><h2 id="进阶设置"><a href="#进阶设置" class="headerlink" title="进阶设置"></a>进阶设置</h2><h3 id="选择本地面板可以加载更快"><a href="#选择本地面板可以加载更快" class="headerlink" title="选择本地面板可以加载更快"></a>选择本地面板可以加载更快</h3><p>切换YACD面板</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-095157.jpg" alt="Screenshot_20201011-095157"></p><h3 id="关于clash地址"><a href="#关于clash地址" class="headerlink" title="关于clash地址"></a>关于clash地址</h3><ol><li><p>clash地址一般机场都会提供</p></li><li><p>自己搭建的服务器，可以使用订阅转换将vmess链接转为clash</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-100537.jpg" alt="Screenshot_20201011-100537"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Clash-Premium-For-Magisk的用途&quot;&gt;&lt;a href=&quot;#Clash-Premium-For-Magisk的用途&quot; class=&quot;headerlink&quot; title=&quot;Clash Premium For Magisk的用途&quot;&gt;&lt;/a&gt;Clash</summary>
      
    
    
    
    <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Wiki" scheme="http://yoursite.com/tags/Wiki/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用和一些应用安装</title>
    <link href="http://yoursite.com/archives/Docker.html"/>
    <id>http://yoursite.com/archives/Docker.html</id>
    <published>2020-09-01T01:06:08.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h2><p><code>Docker</code>也是目前很火的技术，当我在学习期间，因为学的东西比较多，部署环境很是麻烦，这时候就想把需要的环境搭建在<code>Docker</code>上，而且<code>Docker</code>搭建很是轻松，比如你安装<code>Centos</code>时候只需要几行命令便可以拉取安装，比起传统虚拟机安装方便快速很多，而且可以克隆部署多个。</p><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><ul><li>Ubuntu</li><li><code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></li><li>Debian</li><li><code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></li><li>Centos</li><li><code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></li></ul><h2 id="Docker加速镜像"><a href="#Docker加速镜像" class="headerlink" title="Docker加速镜像"></a>Docker加速镜像</h2><ol><li>编辑<br><code>vim /etc/docker/daemon.json</code></li><li>修改<br><code>&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</code><br>推荐修改为<code>https://hub-mirror.c.163.com/</code></li><li>重启<br><code>sudo systemctl daemon-reload</code><br><code>sudo systemctl restart docker</code></li></ol><h3 id="一、安装Centos系统"><a href="#一、安装Centos系统" class="headerlink" title="一、安装Centos系统"></a>一、安装<code>Centos</code>系统</h3><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><p>进入<code>Docker hub</code>官方镜像仓库<br><a href="https://hub.docker.com/search?q=&type=image">docker hub</a></p><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p><code>docker pull centos</code></p><h4 id="查看已经下载的镜像"><a href="#查看已经下载的镜像" class="headerlink" title="查看已经下载的镜像"></a>查看已经下载的镜像</h4><p><code>docker images</code></p><h4 id="查看正在运行的镜像"><a href="#查看正在运行的镜像" class="headerlink" title="查看正在运行的镜像"></a>查看正在运行的镜像</h4><p><code>docker ps</code></p><h4 id="运行一个容器"><a href="#运行一个容器" class="headerlink" title="运行一个容器"></a>运行一个容器</h4><p><code>docker run -itd --name centos-study centos</code><br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200903075810.png"></p><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p><code>docker exec -it centos-study /bin/bash</code><br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200903080139.png"><br>此时前面的名称就变了，此时已经进入centos这个容器了，查看一下系统信息<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200903080415.png"></p><h3 id="二、Docker安装portainer可视化界面"><a href="#二、Docker安装portainer可视化界面" class="headerlink" title="二、Docker安装portainer可视化界面"></a>二、Docker安装<code>portainer</code>可视化界面</h3><h4 id="搜索一下portainer"><a href="#搜索一下portainer" class="headerlink" title="搜索一下portainer"></a>搜索一下<code>portainer</code></h4><p><code>docker search portainer</code><br>看哪个镜像star多就优先选择</p><h4 id="拉去镜像"><a href="#拉去镜像" class="headerlink" title="拉去镜像"></a>拉去镜像</h4><p><code>docker pull portainer/portainer</code></p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><pre><code class="cmd">docker run -ti -d --name portainer -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock  portainer/portainer</code></pre><ul><li>–name 定义容器名</li><li>-p 9000：9000 定义9000端口</li></ul><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>打开浏览器输入<code>http://127.0.0.1:9000</code><br>登陆后就可以通过图形界面进行<code>Docker</code>的管理<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200903084415.png"></p><h3 id="三、安装MySQL-8"><a href="#三、安装MySQL-8" class="headerlink" title="三、安装MySQL 8"></a>三、安装MySQL 8</h3><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><p><code>docker pull mysql:8.0</code></p><h4 id="运行MySQL"><a href="#运行MySQL" class="headerlink" title="运行MySQL"></a>运行MySQL</h4><p><code>docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0</code></p><blockquote><p><code>-p 3306:3306</code> ：映射容器服务的 <code>3306</code> 端口到宿主机的 <code>3306</code> 端口，外部主机可以直接通过 宿主机<code>ip:3306</code> 访问到 <code>MySQL</code> 的服务。<code>MYSQL_ROOT_PASSWORD=123456</code>：设置 <code>MySQL</code> 服务 <code>root</code> 用户的密码。</p></blockquote><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>使用数据库管理工具连接数据块即可<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904105726.png"></p><h3 id="四、安装wordpress"><a href="#四、安装wordpress" class="headerlink" title="四、安装wordpress"></a>四、安装wordpress</h3><p>我用的是阿里云的服务器，国内服务器一般搭建网站是需要备案的，一般安装完初始化时候就会提示打不开。用<code>Docker</code>搭建wordpress就不会提示因为备案问题无法打开</p><h4 id="拉取wordpress镜像"><a href="#拉取wordpress镜像" class="headerlink" title="拉取wordpress镜像"></a>拉取wordpress镜像</h4><p><code>docker pull wordpress:latest</code></p><h4 id="拉取MySQL镜像"><a href="#拉取MySQL镜像" class="headerlink" title="拉取MySQL镜像"></a>拉取<code>MySQL</code>镜像</h4><p><code>docker pull mysql:latest</code></p><h4 id="运行MySQL-1"><a href="#运行MySQL-1" class="headerlink" title="运行MySQL"></a>运行MySQL</h4><p><code>docker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</code></p><blockquote><p><code>name</code>参数指定要启动的实例名称，<code>MYSQL_ROOT_PASSWORD</code>指定<code>ROOT</code>密码。<code>tag</code>参数是<code>MySQL</code>的版本号，可以是<code>5.7</code>、<code>5.6</code>、<code>8.0</code></p></blockquote><h4 id="运行wordpress"><a href="#运行wordpress" class="headerlink" title="运行wordpress"></a>运行wordpress</h4><p><code>docker run --name some-wordpress --link some-mysql:mysql -p 8080:80 -d wordpress</code></p><blockquote><p><code>name</code>参数指定要启动的<code>WordPress</code>实例名称，<code>link</code>参数指定要使用的<code>Docker MySQL</code>实例名称，<code>p</code>参数将<code>Docker</code>内部的<code>80</code>端口映射到本地的<code>8080</code>端口上</p></blockquote><h4 id="打开设置"><a href="#打开设置" class="headerlink" title="打开设置"></a>打开设置</h4><p>浏览器输入<code>ip + 端口号</code><br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904101122.png"></p><blockquote><p>安装<code>typecho</code>大体上一样，安装<code>MySQL</code>后安装主体</p></blockquote><h3 id="五、安装netdata"><a href="#五、安装netdata" class="headerlink" title="五、安装netdata"></a>五、安装netdata</h3><h4 id="直接安装运行netdata"><a href="#直接安装运行netdata" class="headerlink" title="直接安装运行netdata"></a>直接安装运行<code>netdata</code></h4><pre><code class="docker">docker run -d --name=netdata -p 19999:19999 -v netdatalib:/var/lib/netdata -v netdatacache:/var/cache/netdata -v /etc/passwd:/host/etc/passwd:ro -v /etc/group:/host/etc/group:ro -v /proc:/host/proc:ro -v /sys:/host/sys:ro -v /etc/os-release:/host/etc/os-release:ro --restart unless-stopped --cap-add SYS_PTRACE --security-opt apparmor=unconfined netdata/netdata</code></pre><h4 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h4><p>安装完浏览器输入<code>ip + 19999</code>，就进入了<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904103554.png"></p><h3 id="六、安装nextcloud"><a href="#六、安装nextcloud" class="headerlink" title="六、安装nextcloud"></a>六、安装nextcloud</h3><h4 id="安装nextcloud"><a href="#安装nextcloud" class="headerlink" title="安装nextcloud"></a>安装<code>nextcloud</code></h4><p><code>docker run -d --name nextcloud -p 80:80 -v /root/nextcloud:/data rootlogin/nextcloud</code></p><blockquote><p>登录地址为<code>http://ip</code>，<code>80</code>端口可自行替换，如果你改成<code>800</code>，那么登录地址会变成<code>http://ip:800</code>，<code>/root/nextcloud</code>为网盘的数据库，也可以自行修改</p></blockquote><h4 id="设置安装"><a href="#设置安装" class="headerlink" title="设置安装"></a>设置安装</h4><p>打开浏览器输入<code>ip + 80</code><br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904104142.png"><br>还可以安装<code>手机客户端</code>使用</p><h3 id="七、安装code-sever"><a href="#七、安装code-sever" class="headerlink" title="七、安装code-sever"></a>七、安装<code>code-sever</code></h3><h4 id="安装code-server"><a href="#安装code-server" class="headerlink" title="安装code-server"></a>安装<code>code-server</code></h4><p><code>docker run -dit --restart=always --name vscode -h vscode -u root  -p 8086:8080 -v /data/vscode:/root -e PASSWORD=mycode -v /etc/localtime:/etc/localtime:ro codercom/code-server:v2  --auth password</code></p><blockquote><p><code>--auth password</code> 启动密码<br><code>-e PASSWORD=mycode</code> 环境变量设置密码为<code>mycode</code></p></blockquote><h4 id="设置安装-1"><a href="#设置安装-1" class="headerlink" title="设置安装"></a>设置安装</h4><p>打开浏览器输入<code>ip + 端口号</code><br>输入设置的密码就可以进入了<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904104630.png"></p><h3 id="八、安装aira2下载器"><a href="#八、安装aira2下载器" class="headerlink" title="八、安装aira2下载器"></a>八、安装<code>aira2下载器</code></h3><h4 id="安装aria2"><a href="#安装aria2" class="headerlink" title="安装aria2"></a>安装<code>aria2</code></h4><p>下载<code>P大</code>调试维护的<code>aria2-pro</code></p><pre><code class="docker">docker run -d \    --name aria2-pro \    --restart unless-stopped \    --log-opt max-size=1m \    --network host \    -e PUID=$UID \    -e PGID=$GID \    -e RPC_SECRET=&lt;TOKEN&gt; \    -e RPC_PORT=6800 \    -e LISTEN_PORT=6888 \    -v ~/aria2-config:/config \    -v ~/aria2-downloads:/downloads \    p3terx/aria2-pro</code></pre><h4 id="链接aria2"><a href="#链接aria2" class="headerlink" title="链接aria2"></a>链接<code>aria2</code></h4><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904105211.png"></p><h3 id="九-安装FAST-OS-DOCKER"><a href="#九-安装FAST-OS-DOCKER" class="headerlink" title="九.安装FAST OS DOCKER"></a>九.安装FAST OS DOCKER</h3><h4 id="安装FAST-OS-DOCKER"><a href="#安装FAST-OS-DOCKER" class="headerlink" title="安装FAST OS DOCKER"></a>安装FAST OS DOCKER</h4><pre><code class="docker">docker run --restart always -p 8081:8081 -d -v /var/run/docker.sock:/var/run/docker.sock wangbinxingkong/fast</code></pre><p><img src="https://www.dockernb.com/img/screenshot/img-1.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Docker的基本操作&quot;&gt;&lt;a href=&quot;#Docker的基本操作&quot; class=&quot;headerlink&quot; title=&quot;Docker的基本操作&quot;&gt;&lt;/a&gt;Docker的基本操作&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Docker&lt;/code&gt;也是目前很火的技术，当我在学习</summary>
      
    
    
    
    <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
    <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>AMD虚拟机安装MacOS系统</title>
    <link href="http://yoursite.com/archives/Hackintosh.html"/>
    <id>http://yoursite.com/archives/Hackintosh.html</id>
    <published>2020-08-18T14:47:56.000Z</published>
    <updated>2021-07-13T03:33:10.585Z</updated>
    
    <content type="html"><![CDATA[<p>因为有些东西需要用到MacOS系统，而且AMD笔记本的CPU和显卡对黑苹果无法兼容，所以只能使用虚拟机来安装MacOS，记录一下安装过程中遇到的一些坑吧</p><h2 id="首先安装VMware"><a href="#首先安装VMware" class="headerlink" title="首先安装VMware"></a>首先安装VMware</h2><p>目前测试最新版VMwar15.10不行，VMware15.1可以</p><p>刚安装的VMware是没有支持安装MacOS，需要<a href="#%E4%B8%8B%E8%BD%BD%E8%A7%A3%E9%94%81%E5%B7%A5%E5%85%B7">下载解锁工具</a>解锁后才能选择安装MacOS</p><h2 id="下载解锁工具"><a href="#下载解锁工具" class="headerlink" title="下载解锁工具"></a>下载解锁工具</h2><p><a href="https://www.lanzoux.com/i32SQfqw44b">下载地址</a></p><p><strong>已管理员身份运行<code>win-install.cmd</code></strong></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818095345.png"></p><p>到目前为止，VMware就支持安装MacOS了</p><h2 id="创建MacOS"><a href="#创建MacOS" class="headerlink" title="创建MacOS"></a>创建MacOS</h2><p>解锁完创建就可以创建MacOS系统</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818100054.png"></p><h2 id="编辑-vmx文件"><a href="#编辑-vmx文件" class="headerlink" title="编辑.vmx文件"></a>编辑<code>.vmx</code>文件</h2><p>打开MacOS虚拟机目录，用编辑打开<code>.vmx</code>文件</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818095013.png"></p><pre><code class="vmx">smc.version = &quot;0&quot;cpuid.0.eax = &quot;0000:0000:0000:0000:0000:0000:0000:1011&quot;cpuid.0.ebx = &quot;0111:0101:0110:1110:0110:0101:0100:0111&quot;cpuid.0.ecx = &quot;0110:1100:0110:0101:0111:0100:0110:1110&quot;cpuid.0.edx = &quot;0100:1001:0110:0101:0110:1110:0110:1001&quot;cpuid.1.eax = &quot;0000:0000:0000:0001:0000:0110:0111:0001&quot;cpuid.1.ebx = &quot;0000:0010:0000:0001:0000:1000:0000:0000&quot;cpuid.1.ecx = &quot;1000:0010:1001:1000:0010:0010:0000:0011&quot;cpuid.1.edx = &quot;0000:1111:1010:1011:1111:1011:1111:1111&quot;featureCompat.enable = &quot;FALSE&quot;</code></pre><p><strong>一定要在这两行中插入代码</strong></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818100455.png"></p><h2 id="启动安装"><a href="#启动安装" class="headerlink" title="启动安装"></a>启动安装</h2><p><img src="http://p.ananas.chaoxing.com/star3/origin/90cfd4b8e52aae51e3ccc98a56c044ad.png"></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="1-没有网络"><a href="#1-没有网络" class="headerlink" title="1.没有网络"></a>1.没有网络</h3><p>把网络设为<code>桥接模式</code></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818100916.png"></p><h3 id="2-报错”这个虚拟机需要avx2，但是没有avx”"><a href="#2-报错”这个虚拟机需要avx2，但是没有avx”" class="headerlink" title="2.报错”这个虚拟机需要avx2，但是没有avx”"></a>2.报错”这个虚拟机需要avx2，但是没有avx”</h3><p>将vmx文件中 <strong>virtualHW.version = “16”**改为 **virtualHW.version = “10”</strong></p><h3 id="3-无法使用鼠标键盘"><a href="#3-无法使用鼠标键盘" class="headerlink" title="3.无法使用鼠标键盘"></a>3.无法使用鼠标键盘</h3><p>1、关闭虚拟机。</p><p>2、找到 vmx文件，在其中添加：</p><p><strong>keyboard.vusb.enable = “TRUE”</strong></p><p><strong>mouse.vusb.enable = “TRUE”</strong></p><p>3、把虚拟机设置，选择“硬件”的“USB控制器”，</p><p>   在左侧的界面里勾选“显示所有USB输入设备（S）”，并把顶部的“USB兼容性（C）”改为USB2.0。</p><p>4、重启虚拟机。</p><h3 id="4-虚拟机进入BIOS"><a href="#4-虚拟机进入BIOS" class="headerlink" title="4.虚拟机进入BIOS"></a>4.虚拟机进入BIOS</h3><pre><code>1.常规方法：开启虚拟机，按F2键，注意要将鼠标点进虚拟机环境中2.特殊情况,按F2键无反应：进入虚拟机目录，找到vmx文件，在文件最前端加入一行：bios.forceSetupOnce = &quot;TRUE&quot;保存后开启虚拟机直接进入bios该方法只生效一次下次如需进入bios需重新编辑vmx文件3.延长bios等待时间：在vmx文件前端加入：bios.bootDelay = &quot;6000&quot;注意保存。6000=6秒，可自行设置。如果进入bios后无法引导进入光盘镜像，例如 .cdr 镜像文件，或许是 cdr文件本身经过修改，可更换为其他镜像。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为有些东西需要用到MacOS系统，而且AMD笔记本的CPU和显卡对黑苹果无法兼容，所以只能使用虚拟机来安装MacOS，记录一下安装过程中遇到的一些坑吧&lt;/p&gt;
&lt;h2 id=&quot;首先安装VMware&quot;&gt;&lt;a href=&quot;#首先安装VMware&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="MacOS" scheme="http://yoursite.com/categories/MacOS/"/>
    
    
    <category term="Hackintosh" scheme="http://yoursite.com/tags/Hackintosh/"/>
    
    <category term="MacOS" scheme="http://yoursite.com/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-线性表</title>
    <link href="http://yoursite.com/archives/data.html"/>
    <id>http://yoursite.com/archives/data.html</id>
    <published>2020-08-15T14:28:25.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><ol><li>首先定义一个单链表结构题</li></ol><pre><code class="C++">typedef struct LNode&#123;  ElemType data;//定义一个自定义类型的变量存放数据  LNode *Next;//定义一个指向结构体的指针&#125;LNode,*Linklist;//创建一个结构体指针</code></pre><p>*<em>LNode <em>p ==Linklist p</em></em></p><ol start="2"><li>链表的初始化</li></ol><pre><code class="C++">void init(Linklist &amp;L)&#123;    L=new LNode;//为L动态分配一块内存空间    L-&gt;Next=NULL;//将L的指针域设为空&#125;</code></pre><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200812155623.png"></p><ol start="3"><li><p>创建链表</p><p>图中是用尾插法构建单链表，头插法还请移步<a href="#%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95">头插法</a></p><pre><code class="C++">void created(Linklist &amp;L)&#123;    Linklist p=L;//新创建一个p指针指向头节点L    for(int i=0;i&lt;20;i++)//循环创建20个节点的单链表    &#123;        Linklist q=new LNode;//创建一个新的节点，并用q指针指向这个新的节点        q-&gt;data=i;//将i的值存入q的data域        q-&gt;Next=NULL;//将q的Next指针指向为空        p-&gt;Next=q;//将q/L的尾指针指向新创建的q这个结构体        p=q;//再将p指向位置移动到q（p指针后移）    &#125;&#125;</code></pre><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200812161052.png"></p></li><li><p>分别定义两个指针，一个快指针(high)一个慢指针(low)，查找一个有序链表的中间值</p><pre><code class="C++">int findmid(Linklist &amp;L)&#123;    Linklist high,low=L;    while(high-&gt;Next != NULL)    &#123;        if(high-&gt;Next-&gt;Next != NULL)        &#123;            high = high-&gt;Next-&gt;Next;//high每次后移两步            low = low-&gt;low;//low指针每次后移一步        &#125;     else        &#123;            high=high-&gt;Next;        &#125;    &#125;    return low-&gt;data;&#125;</code></pre><p><code>high</code>指针每次向后移动两步，<code>low</code>指针每次向后移动一步，这样当<code>high</code>指针移动到链表最后面时，恰巧<code>low</code>应该在链表中间位置。 </p><h4 id="头插法和尾插法"><a href="#头插法和尾插法" class="headerlink" title="头插法和尾插法"></a>头插法和尾插法</h4></li></ol><p>如果将数据结构的存储方式换为头插法，只需要将<code>created()</code>函数换为：</p><pre><code class="C++">void creat(Linklist &amp;L)&#123;    Linklist p=L;    Linklist q=new LNode;    q-&gt;data=0;    q-&gt;Next=NULL;    p-&gt;Next=q;    for (int i = 1; i &lt; 20; i++)    &#123;        /* code */        Linklist q=new LNode;        q-&gt;data=i;        q-&gt;Next=p-&gt;Next;        p-&gt;Next=q;    &#125;&#125;</code></pre><p><strong>头插法</strong>创建一个节点长度为20的有序单链表输出出来的循序则为逆序</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200812223221.png"></p><p>而<strong>尾插法</strong>创建一个节点长度为20的有序单链表输出出来的循序是正序：</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200812223459.png"></p><h3 id="链表节点的增、删"><a href="#链表节点的增、删" class="headerlink" title="链表节点的增、删"></a>链表节点的增、删</h3><p>创建一个增加节点的函数<code>push()</code></p><pre><code class="C++">void push(Linklist &amp;L)&#123;    int n,m;    Linklist p=L;    cout &lt;&lt; &quot;在第几个节点后面增加：&quot; &lt;&lt; &quot;\n&quot;;    cin &gt;&gt; n;    /*先将指针移动到插入节点*/    for (int i = 0; i &lt; n; i++)    &#123;        /* code */        p=p-&gt;Next;    &#125;    Linklist q=new LNode;    cout &lt;&lt; &quot;输入数值：&quot; &lt;&lt; &quot;\n&quot;;    cin &gt;&gt; m;    q-&gt;data=m;    q-&gt;Next=p-&gt;Next;    p-&gt;Next=q;&#125;</code></pre><p>创建一个删除节点的函数<code>deleted()</code></p><pre><code class="C++">void deleted(Linklist &amp;L)&#123;    int n;    Linklist p,q;    p=L;    cout &lt;&lt; &quot;在第几个节点后面删除：&quot; &lt;&lt; &quot;\n&quot;;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    &#123;        /* code */        p=p-&gt;Next;    &#125;    q=p-&gt;Next;    p-&gt;Next=q-&gt;Next;&#125;</code></pre><p>执行了增加节点的函数<code>push()</code>后输出有序链表结果如下图：</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200813092600.png"></p><p>执行删除节点函数<code>deleted()</code>后的输出结果如下图：</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200813092901.png"></p><p>对比发现增加了一个数值为100的节点，删除了一个数值为4的节点。</p><h3 id="创建一个有序链表并快速查找中间值的完整代码："><a href="#创建一个有序链表并快速查找中间值的完整代码：" class="headerlink" title="创建一个有序链表并快速查找中间值的完整代码："></a><strong>创建一个有序链表并快速查找中间值的完整代码：</strong></h3><pre><code class="C++">#include &quot;iostream&quot;#include &lt;stdlib.h&gt;using namespace std;#define OK 1#define ERROR 0typedef int Status;typedef int ElemType; typedef struct LNode&#123;    ElemType data;    LNode *next;&#125;LNode,*LinkList;Status init(LinkList &amp;L)    //初始化&#123;    L=new LNode;    L-&gt;next=NULL;    return OK;&#125;void creat(LinkList &amp;L)    //尾插法建立链表&#123;    LinkList p,q=L;    for(int i=0;i&lt;20;i++)    &#123;        p=new LNode;        p-&gt;data=i+1;        p-&gt;next=NULL;        q-&gt;next=p;        q=p;    &#125;&#125;void show(LinkList L)        //显示链表&#123;    LinkList p=L-&gt;next;    while(p)    &#123;        cout&lt;&lt;p-&gt;data&lt;&lt;&quot;\t&quot;;         p=p-&gt;next;    &#125;    cout&lt;&lt;endl;&#125;Status findmid(LinkList L)    //查找中间值&#123;    LinkList high,mid;    ElemType e;    high=mid=L;    while(high-&gt;next!=NULL)    &#123;        if(high-&gt;next-&gt;next!=NULL)        &#123;            high=high-&gt;next-&gt;next;            mid=mid-&gt;next;        &#125;        else        &#123;            high=high-&gt;next;        &#125;    &#125;    e=mid-&gt;data;    return e;&#125;int main()&#123;        LinkList L;    init(L);    creat(L);    cout&lt;&lt;&quot;显示链表：&quot;&lt;&lt;endl;    show(L);    cout&lt;&lt;&quot;显示中间值：&quot;&lt;&lt;endl;    cout&lt;&lt;findmid(L)&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p><strong>首先声明这里说的指针只是为了方便称呼，不是在C/C++中的指针</strong></p><ol><li><p>定义一个队列(线性表的顺序结构)</p><pre><code class="C++">typedef struct&#123;    int ID[10];//每个节点的编号    int front;//头指针    int rear;//尾指针&#125;Sql;</code></pre></li></ol><ol start="2"><li><p>队列初始化</p><pre><code class="C++">void init(Sql *data)&#123;    data-&gt;front=data-&gt;rear=0;    for (; data-&gt;rear &lt; 10; ++data-&gt;rear)//尾指针后移    &#123;        /* code */        data-&gt;ID[data-&gt;rear]=0;    &#125;    //此时头指针在头位，尾指针在尾位&#125;对队列赋值</code></pre></li></ol><ol start="3"><li><p>给列表赋值</p><pre><code class="C++">void creat(Sql *data)&#123;    int i=1;    while(data-&gt;front!=data-&gt;rear)//当头指针后移到尾指针时候循环结束    &#123;        data-&gt;ID[data-&gt;front]=i;        data-&gt;front++;        i++;    &#125;    data-&gt;front=0;//把头指针回归到首位&#125;</code></pre></li></ol><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200814131754.png"></p><ol start="4"><li><p>遍历列表输出整个顺序表</p><pre><code class="C++">void print(Sql *data)&#123;    while(data-&gt;front!=data-&gt;rear)    &#123;        cout &lt;&lt; data-&gt;ID[data-&gt;front] &lt;&lt; &quot;\n&quot;;        data-&gt;front++;//头指针后移直至结束    &#125;    data-&gt;front=0;//头指针回归到原位&#125;</code></pre></li></ol><h3 id="输出一个顺序表"><a href="#输出一个顺序表" class="headerlink" title="输出一个顺序表"></a><strong>输出一个顺序表</strong></h3><pre><code class="C++">#include &quot;iostream&quot;using namespace std;typedef struct&#123;    int ID[10];//每个节点的编号    int front;//头指针    int rear;//尾指针&#125;Sql;void init(Sql *data)&#123;    data-&gt;front=data-&gt;rear=0;    for (; data-&gt;rear &lt; 10; ++data-&gt;rear)    &#123;        /* code */        data-&gt;ID[data-&gt;rear]=0;    &#125;&#125;void creat(Sql *data)&#123;    int i=1;    while(data-&gt;front!=data-&gt;rear)    &#123;        data-&gt;ID[data-&gt;front]=i;        data-&gt;front++;        i++;    &#125;    data-&gt;front=0;&#125;void print(Sql *data)&#123;    while(data-&gt;front!=data-&gt;rear)    &#123;        cout &lt;&lt; data-&gt;ID[data-&gt;front] &lt;&lt; &quot;\n&quot;;        data-&gt;front++;    &#125;    data-&gt;front=0;&#125;int main()&#123;    /* code */    Sql data;    init(&amp;data);    creat(&amp;data);    print(&amp;data);    return 0;&#125;</code></pre><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200814133143.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单链表&quot;&gt;&lt;a href=&quot;#单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表&quot;&gt;&lt;/a&gt;单链表&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先定义一个单链表结构题&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;
typedef stru</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>使用正则表达式</title>
    <link href="http://yoursite.com/archives/re.html"/>
    <id>http://yoursite.com/archives/re.html</id>
    <published>2020-08-08T14:40:54.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。</p><p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p><p>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫<a href="https://deerchao.net/tutorials/regex/regex.htm">《正则表达式30分钟入门教程》</a>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p><h2 id="正则表达式相关知识"><a href="#正则表达式相关知识" class="headerlink" title="正则表达式相关知识"></a>正则表达式相关知识</h2><table><thead><tr><th>符号</th><th>解释</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符</td><td>b.t</td><td>可以匹配bat / but / b#t / b1t等</td></tr><tr><td>\w</td><td>匹配字母/数字/下划线</td><td>b\wt</td><td>可以匹配bat / b1t / b_t等 但不能匹配b#t</td></tr><tr><td>\s</td><td>匹配空白字符（包括\r、\n、\t等）</td><td>love\syou</td><td>可以匹配love you</td></tr><tr><td>\d</td><td>匹配数字</td><td>\d\d</td><td>可以匹配01 / 23 / 99等</td></tr><tr><td>\b</td><td>匹配单词的边界</td><td>\bThe\b</td><td></td></tr><tr><td>^</td><td>匹配字符串的开始</td><td>^The</td><td>可以匹配The开头的字符串</td></tr><tr><td>$</td><td>匹配字符串的结束</td><td>.exe$</td><td>可以匹配.exe结尾的字符串</td></tr><tr><td>\W</td><td>匹配非字母/数字/下划线</td><td>b\Wt</td><td>可以匹配b#t / b@t等 但不能匹配but / b1t / b_t等</td></tr><tr><td>\S</td><td>匹配非空白字符</td><td>love\Syou</td><td>可以匹配love#you等 但不能匹配love you</td></tr><tr><td>\D</td><td>匹配非数字</td><td>\d\D</td><td>可以匹配9a / 3# / 0F等</td></tr><tr><td>\B</td><td>匹配非单词边界</td><td>\Bio\B</td><td></td></tr><tr><td>[]</td><td>匹配来自字符集的任意单一字符</td><td>[aeiou]</td><td>可以匹配任一元音字母字符</td></tr><tr><td>[^]</td><td>匹配不在字符集中的任意单一字符</td><td>[^aeiou]</td><td>可以匹配任一非元音字母字符</td></tr><tr><td>*</td><td>匹配0次或多次</td><td>\w*</td><td></td></tr><tr><td>+</td><td>匹配1次或多次</td><td>\w+</td><td></td></tr><tr><td>?</td><td>匹配0次或1次</td><td>\w?</td><td></td></tr><tr><td>{N}</td><td>匹配N次</td><td>\w{3}</td><td></td></tr><tr><td>{M,}</td><td>匹配至少M次</td><td>\w{3,}</td><td></td></tr><tr><td>{M,N}</td><td>匹配至少M次至多N次</td><td>\w{3,6}</td><td></td></tr><tr><td>|</td><td>分支</td><td>foo|bar</td><td>可以匹配foo或者bar</td></tr><tr><td>(?#)</td><td>注释</td><td></td><td></td></tr><tr><td>(exp)</td><td>匹配exp并捕获到自动命名的组中</td><td></td><td></td></tr><tr><td>(?<name>exp)</td><td>匹配exp并捕获到名为name的组中</td><td></td><td></td></tr><tr><td>(?:exp)</td><td>匹配exp但是不捕获匹配的文本</td><td></td><td></td></tr><tr><td>(?=exp)</td><td>匹配exp前面的位置</td><td>\b\w+(?=ing)</td><td>可以匹配I’m dancing中的danc</td></tr><tr><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td><td>(?&lt;=\bdanc)\w+\b</td><td>可以匹配I love dancing and reading中的第一个ing</td></tr><tr><td>(?!exp)</td><td>匹配后面不是exp的位置</td><td></td><td></td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td><td></td><td></td></tr><tr><td>*?</td><td>重复任意次，但尽可能少重复</td><td>a.<em>b a.</em>?b</td><td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td></tr><tr><td>+?</td><td>重复1次或多次，但尽可能少重复</td><td></td><td></td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,N}?</td><td>重复M到N次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,}?</td><td>重复M次以上，但尽可能少重复</td><td></td><td></td></tr></tbody></table><blockquote><p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成(和)，否则圆括号被视为正则表达式中的分组。</p></blockquote><h2 id="Python对正则表达式的支持"><a href="#Python对正则表达式的支持" class="headerlink" title="Python对正则表达式的支持"></a>Python对正则表达式的支持</h2><p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>compile(pattern, flags=0)</td><td>编译正则表达式返回正则表达式对象</td></tr><tr><td>match(pattern, string, flags=0)</td><td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td></tr><tr><td>search(pattern, string, flags=0)</td><td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td></tr><tr><td>split(pattern, string, maxsplit=0, flags=0)</td><td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td></tr><tr><td>sub(pattern, repl, string, count=0, flags=0)</td><td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td></tr><tr><td>fullmatch(pattern, string, flags=0)</td><td>match函数的完全匹配（从字符串开头到结尾）版本</td></tr><tr><td>findall(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td></tr><tr><td>finditer(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td></tr><tr><td>purge()</td><td>清除隐式编译的正则表达式的缓存</td></tr><tr><td>re.I / re.IGNORECASE</td><td>忽略大小写匹配标记</td></tr><tr><td>re.M / re.MULTILINE</td><td>多行匹配标记</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="例子1：从一段文字中提取出国内手机号码。"><a href="#例子1：从一段文字中提取出国内手机号码。" class="headerlink" title="例子1：从一段文字中提取出国内手机号码。"></a>例子1：从一段文字中提取出国内手机号码。</h3><p>下面这张图是截止到2017年底，国内三家运营商推出的手机号段。</p><pre><code class="Python">import redef main():    # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字    pattern = re.compile(r&#39;(?&lt;=\D)1[34578]\d&#123;9&#125;(?=\D)&#39;)    sentence = &#39;&#39;&#39;    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，    不是15600998765，也是110或119，王大锤的手机号才是15600998765。    &#39;&#39;&#39;    # 查找所有匹配并保存到一个列表中 （一）    mylist = re.findall(pattern, sentence)    print(mylist)    print(&#39;--------华丽的分隔线--------&#39;)    # 通过迭代器取出匹配对象并获得匹配的内容 （二）    for temp in pattern.finditer(sentence):        print(temp.group())    print(&#39;--------华丽的分隔线--------&#39;)    # 通过search函数指定搜索位置找出所有匹配 （三）    m = pattern.search(sentence)    while m:        print(m.group())        m = pattern.search(sentence, m.end())if __name__ == &#39;__main__&#39;:    main()</code></pre><blockquote><p>说明： 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?&lt;=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p></blockquote><ul><li>注释部分</li><li><strong>注释（一）：</strong> <code>findall(pattern, string, flags=0)</code>    查找字符串所有与正则表达式匹配的模式 返回<code>字符串的列表</code>，即<strong>在string中查询所有匹配模式为pattern的字符串，并将所有字符串添加到一个列表并返回</strong></li><li><strong>注释（二）：</strong> <code>finditer(pattern, string, flags=0)</code>查找字符串所有与正则表达式匹配的模式 返回一个<code>迭代器</code>，即<strong>在string中查找匹配模式为pattern的字符串，并将所有字符串添加到一个迭代器列表</strong><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></li><li><strong>注释（三）</strong> <code>m = pattern.search(sentence, m.end())</code>搜索字符串中第一次出现正则表达式的模式 成功返回<code>匹配对象</code> 否则返回<code>None</code>,用<code>m.end()</code>表示<code>m</code>的结束位置，作为下一次查找的起始位置，防止查找重复的问题<h3 id="例子2：验证输入用户名和QQ号是否有效并给出对应的提示信息。"><a href="#例子2：验证输入用户名和QQ号是否有效并给出对应的提示信息。" class="headerlink" title="例子2：验证输入用户名和QQ号是否有效并给出对应的提示信息。"></a>例子2：验证输入用户名和QQ号是否有效并给出对应的提示信息。</h3><pre><code class="Python">&quot;&quot;&quot;验证输入用户名和QQ号是否有效并给出对应的提示信息</code></pre></li></ul><p>要求：用户名必须由字母、数字或下划线构成且长度在6<del>20个字符之间，QQ号是5</del>12的数字且首位不能为0<br>“””<br>import re</p><p>def main():<br>    username = input(‘请输入用户名: ‘)<br>    qq = input(‘请输入QQ号: ‘)<br>    # match函数的第一个参数是正则表达式字符串或正则表达式对象<br>    # 第二个参数是要跟正则表达式做匹配的字符串对象<br>    m1 = re.match(r’^[0-9a-zA-Z_]{6,20}$’, username) #注释（一）<br>    if not m1:<br>        print(‘请输入有效的用户名.’)<br>    m2 = re.match(r’^[1-9]\d{4,11}$’, qq)<br>    if not m2:<br>        print(‘请输入有效的QQ号.’)<br>    if m1 and m2:<br>        print(‘你输入的信息是有效的!’)</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p><pre><code>&gt; 提示： 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。- **注释（一）：** `print(m1)` -&gt; `&lt;_sre.SRE_Match object; span=(0, 10), match=&#39;koyangyang&#39;&gt;` `print(type(m1))` -&gt; `&lt;class &#39;_sre.SRE_Match&#39;&gt;`### 例子3：替换字符串中的不良内容```Pythonimport redef main():    sentence = &#39;你丫是傻叉吗? 我操你大爷的. Fuck you.&#39;    purified = re.sub(&#39;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔&#39;,&#39;*&#39;, sentence, flags=re.IGNORECASE) #注释（一）    print(purified)  # 你丫是*吗? 我*你大爷的. * you.if __name__ == &#39;__main__&#39;:    main()</code></pre><blockquote><p>说明： re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。</p></blockquote><ul><li><strong>注释（一）：</strong> <code>sub(pattern, repl, string, count=0, flags=0)</code>    用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数，具体还请看<a href="#sub%E5%87%BD%E6%95%B0">sub函数</a><h3 id="例子4：拆分长字符串"><a href="#例子4：拆分长字符串" class="headerlink" title="例子4：拆分长字符串"></a>例子4：拆分长字符串</h3><pre><code class="Python">import re</code></pre></li></ul><p>def main():<br>    poem = ‘窗前明月光，疑是地上霜。举头望明月，低头思故乡。’<br>    sentence_list = re.split(r’[，。, .]’, poem) #注释（一）<br>    while ‘’ in sentence_list:<br>        sentence_list.remove(‘’)<br>    print(sentence_list)  # [‘窗前明月光’, ‘疑是地上霜’, ‘举头望明月’, ‘低头思故乡’]</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p><pre><code>- **注释（一）：** `split(pattern, string, maxsplit=0, flags=0)`    用正则表达式指定的模式分隔符拆分字符串 返回`列表`&lt;br&gt;最开始的`sentence_list`&gt; [&#39;窗前明月光&#39;, &#39;疑是地上霜&#39;, &#39;举头望明月&#39;, &#39;低头思故乡&#39;, &#39;&#39;]经过```Pythonwhile &#39;&#39; in sentence_list:        sentence_list.remove(&#39;&#39;)</code></pre><blockquote><p>[‘窗前明月光’, ‘疑是地上霜’, ‘举头望明月’, ‘低头思故乡’]<br><strong>所以经过<code>split()</code>函数后返回的列表中除了切割部分还包含一个<code>&#39;&#39;</code>空字符串</strong></p></blockquote><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ol><li>迭代器是一个可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li><li>迭代器有两个基本的方法：<code>iter()</code> 和 <code>next()</code>。</li><li>字符串，列表或元组对象都可用于创建<a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>：</li></ol><p><strong>例如：</strong></p><pre><code class="python">datas = [1,2,3,4,5,6,7,8,9,0]data = iter(datas)for x in data:    print(x)</code></pre><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200807232743.png"><br>了解更多请移步：<a href="https://www.runoob.com/python3/python3-iterator-generator.html">传送门</a></p><h3 id="sub函数"><a href="#sub函数" class="headerlink" title="sub函数"></a>sub函数</h3><p>在Python中，re模块用来实现正则表达式功能。<br><code>sub(pattern, repl, string, count=0, flags=0)</code>具体参数如下：</p><ol><li>pattern： 是re.compile()方法生成Pattern类型，也就是索要匹配的模式。</li><li>repl ： 可以是一段字符串，或者是一个方法</li><li>string： 需要被匹配和替换的原字符串</li><li>count： 指的是最大的可以被替换的匹配到的字符串的个数，默认为0，就是所有匹配到的字符串。</li><li>flags ： 标志位</li></ol><p><strong>其中repl比较特殊：</strong></p><ul><li>当repl为字符串的时候，也就是需要 将string中与pattern匹配的字符串都替换成repl</li><li>当repl为方法的时候，就必须是一个带有一个参数，且参数为MatchObject类型的方法，该方法需要返回一个字符串。</li></ul><p><strong>比如：</strong></p><pre><code class="Python"> __author__ = &#39;zhoujinyu&#39;import fileinput,refield_pat = re.compile(r&#39;\[(.+?)\]&#39;)scope = &#123;&#125;def replacement(match):    code = match.group(1)    try:        return str(eval(code,scope))    except SyntaxError:        exec code in scope        return &#39;&#39;lines = []for line in fileinput.input():    lines.append(line)text=&#39;&#39;.join(lines)print field_pat.sub(replacement,text)</code></pre><blockquote><p>该例子的最后一句 print field_pat.sub(replacement,text)<br>中的replacement就是replacement(match)函数，其中match就是一个MatchObject对象。<br>由于sub()方法是一个循环方法，也就是会逐个找出text（string）中与field_pat（pattern）中匹配的字符串并将其替换成replacement（repl）返回的字符串。<br>所以每次进行匹配查找的时候都会运行一次replacement(match)函数，而每次运行这个函数的时候，match.group(1)这个方法会找到和field_pat（pattern）中第一个括号匹配的字符，由于sub方法是循环不重复进行的（下一次会从上一次匹配到的字符串之后开始匹配），所以在第二次匹配过程中<br>并不会重复上次一匹配到的字符串，会自动找到下一个可以匹配到的字符串。<br>经过多次循环，最终会找到所有匹配的字符串进行替换。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于一般的爬虫工作者来说，掌握正则表达式可以帮助我们更快的通过指定的匹配模式来查找提取文字中想要的、有用的信息。<code>Beautiful Soup</code>或<code>Lxml</code>来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦。而且再有的地方还是需要用到正则表达式，除了爬虫还有<code>Django</code>中的<code>path</code>函数匹配规则。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如</summary>
      
    
    
    
    <category term="Wiki" scheme="http://yoursite.com/categories/Wiki/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
    <category term="Wiki" scheme="http://yoursite.com/tags/Wiki/"/>
    
  </entry>
  
  <entry>
    <title>爬虫小练习</title>
    <link href="http://yoursite.com/archives/pachongtest.html"/>
    <id>http://yoursite.com/archives/pachongtest.html</id>
    <published>2020-07-31T05:36:55.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<p>通过爬取下载<strong>斗图啦</strong><a href="https://www.doutula.com/photo/list?page=0">https://www.doutula.com/photo/list?page=0</a>中的表情包，来练习爬虫</p><h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>声明一个变量来引用<code>requests</code>的对象</p><pre><code class="python">response = requests.get(url, headers...)</code></pre><p>此时输出<code>response</code>是一个html文档</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//static.doutula.com/css/bootstrap.css?id=ecc6bb0e2e008ee4306a&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//static.doutula.com/css/main.css?id=583df7ef1aba1be8ec1b&quot;&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta http-equiv=&quot;content-language&quot; content=&quot;zh-CN&quot;&gt;        &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;        &lt;meta name=&quot;force-rendering&quot; content=&quot;webkit&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;        &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://www.doutula.com/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;        &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;        &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;斗图啦&quot;&gt;        &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;        &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;&gt;        &lt;meta name=&quot;keywords&quot; content=&quot;斗图,斗图啦,斗图网,斗图大会,表情三巨头,蘑菇头,小学生,撕逼图片,搞笑斗图,熊猫表情,微信滑稽表情,猥琐表情,斗图大会开始了,斗图图片,斗图大赛,金馆长斗图表情,金馆长表情,金馆长斗图吧,金馆长qq表情包&quot;/&gt;        &lt;meta name=&quot;description&quot; content=&quot;斗图啦，收集了成千上万的撕逼斗图表情包，在这里你可以快速找到想要的表情，通过在线表情制作可以快速生成自定义表情。&quot;/&gt;        &lt;title&gt;最新斗图表情 - 斗图表情包 - 金馆长表情库 - 真正的斗图网站 - doutula.com&lt;/title&gt;        &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform&quot; /&gt;        &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;        &lt;style&gt;        @media  screen and (max-width: 768px)        &#123;            .center-wrap.col-sm-9 &#123;                padding: 0;            &#125;            .center-wrap.col-xs-12 &#123;                padding: 0;            &#125;        &#125;        &lt;/style&gt;&lt;script&gt;var _hmt = _hmt || [];(function() &#123;  var hm = document.createElement(&quot;script&quot;);  hm.src = &quot;https://hm.baidu.com/hm.js?2fc12699c699441729d4b335ce117f40&quot;;  var s = document.getElementsByTagName(&quot;script&quot;)[0];  s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;//cpro.baidustatic.com/cpro/ui/cm.js&quot; async=&quot;async&quot; defer=&quot;defer&quot; &gt;&lt;/script&gt;        &lt;script src=&quot;//dup.baidustatic.com/js/ds.js&quot; async=&quot;async&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;    &lt;!--&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;--&gt;    &lt;script&gt;        (adsbygoogle = window.adsbygoogle || []).push(&#123;            google_ad_client: &quot;ca-pub-8376044552838383&quot;,            enable_page_level_ads: true        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h3><p>通过<code>BeautifulSoup</code>是用来从<code>HTML</code>或<code>XML</code>中提取数据的<code>Python</code>库</p><pre><code class="python">result = BeautifulSoup(response, &quot;html.parser)</code></pre><p>此时<code>result</code>这个变量就是一个经过转换的<code>soup</code>对象<br>分别输出<code>response</code>和<code>result</code>的数据类型</p><pre><code>&lt;class &#39;str&#39;&gt;&lt;class &#39;bs4.BeautifulSoup&#39;&gt;</code></pre><h3 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h3><p>创建一个变量<code>data</code>用了存放从<code>result</code>中提取出来的信息</p><pre><code>[&lt;img alt=&quot;等他说完在电他&quot; class=&quot;img-responsive lazy image_dta&quot; data-backup=&quot;http://img.doutula.com/production/uploads/image/2020/07/31/20200731175866_BnSbGs.png&quot; data-original=&quot;http://img.doutula.com/production/uploads/image/2020/07/31/20200731175866_BnSbGs.png&quot; referrerpolicy=&quot;no-referrer&quot; src=&quot;//static.doutula.com/img/loader.gif?33&quot;/&gt;,..., &lt;img alt=&quot;那耶@好吃到飞起&quot; class=&quot;img-responsive lazy image_dta&quot; data-backup=&quot;http://img.doutula.com/production/uploads/image/2020/07/30/20200730078726_eJqKRZ.jpg&quot; data-original=&quot;http://img.doutula.com/production/uploads/image/2020/07/30/20200730078726_eJqKRZ.jpg&quot; referrerpolicy=&quot;no-referrer&quot; src=&quot;//static.doutula.com/img/loader.gif?33&quot;/&gt;]</code></pre><p>是一个包含多个<code>img</code>标签的列表，列表是一个<code>python</code>数据结构</p><h3 id="筛选数据"><a href="#筛选数据" class="headerlink" title="筛选数据"></a>筛选数据</h3><p>遍历<code>data</code>这个<code>list</code>，分别用<code>img_name</code>、<code>img_url</code>去引用<code>data</code>中的属性<code>alt</code>和<code>data-backup</code></p><pre><code class="python">for imgs in data:    img_name = imgs[&#39;alt&#39;]    img_url = imgs[&#39;data-backup&#39;]    img = requests.get(img_url)    print(&quot;正在下载&quot; + &quot;  &quot; + img_name + &quot;  &quot; + img_url)    try:        f = open(&quot;C://Users/Koyang/Desktop/表情包/%s.png&quot; % img_name, &#39;wb&#39;)        f.write(img.content)    except Exception as result:        print(result)</code></pre><p>到目前为止就已经完成了对斗图啦的表情包的爬取和批量下载</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200731153043.png"></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200731153001.png"></p><h3 id="附上完整的代码"><a href="#附上完整的代码" class="headerlink" title="附上完整的代码"></a><strong>附上完整的代码</strong></h3><pre><code class="python"># --*-- coding : utf-8 --*--# @Author : Koyang import requestsfrom bs4 import BeautifulSoupclass Doutu:    def __init__(self):        self.url = &quot;https://www.doutula.com/photo/list?page=0&quot;        self.headers = &#123;            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36&quot;&#125;    def get_html(self):        response = requests.get(self.url, headers=self.headers).text        result = BeautifulSoup(response, &quot;html.parser&quot;)        data = result.find_all(attrs=&#123;&quot;alt&quot;: True&#125;)        # 对数据进行筛选和下载        for imgs in data:            img_name = imgs[&#39;alt&#39;]            img_url = imgs[&#39;data-backup&#39;]            img = requests.get(img_url)            print(&quot;正在下载&quot; + &quot;  &quot; + img_name + &quot;  &quot; + img_url)            try:                f = open(&quot;C://Users/Koyang/Desktop/表情包/%s.png&quot; % img_name, &#39;wb&#39;)                f.write(img.content)            except Exception as result:                print(result)if __name__ == &quot;__main__&quot;:    test = Doutu()    test.get_html()</code></pre><h2 id="附页"><a href="#附页" class="headerlink" title="附页"></a>附页</h2><h3 id="Beautiful解析器的区别"><a href="#Beautiful解析器的区别" class="headerlink" title="Beautiful解析器的区别"></a>Beautiful解析器的区别</h3><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库执行速度适中文档容错能力强</td><td>Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>lxml XML 解析器</td><td>BeautifulSoup(markup, [“lxml”, “xml”])BeautifulSoup(markup, “xml”)</td><td>速度快唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性以浏览器的方式解析文档生成HTML5格式的文档</td><td>速度慢不依赖外部扩展</td></tr></tbody></table><h3 id="BeautifulSoup函数讲解"><a href="#BeautifulSoup函数讲解" class="headerlink" title="BeautifulSoup函数讲解"></a>BeautifulSoup函数讲解</h3><h4 id="（1）find-all-name-attrs-recursive-text-kwargs"><a href="#（1）find-all-name-attrs-recursive-text-kwargs" class="headerlink" title="（1）find_all( name , attrs , recursive , text , **kwargs )"></a>（1）find_all( name , attrs , recursive , text , **kwargs )</h4><p><code>find_all()</code> 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件</p><p><strong>1）name 参数</strong></p><p><code>name</code> 参数可以查找所有名字为 <code>name</code> 的tag,字符串对象会被自动忽略掉</p><p><strong>A.传字符串</strong></p><p>最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的<b>标签</p><table><thead><tr><th>12</th><th>soup.find_all(‘b’)# [<b>The Dormouse’s story</b>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>12</th><th>print soup.find_all(‘a’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>, <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>, <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>B.传正则表达式</strong></p><p>如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 <code>match()</code> 来匹配内容.下面例子中找出所有以b开头的标签,这表示<body>和<b>标签都应该被找到</p><table><thead><tr><th>12345</th><th>import refor tag in soup.find_all(re.compile(“^b”)):  print(tag.name)# body# b</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>C.传列表</strong></p><p>如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有<a>标签和<b>标签</p><table><thead><tr><th>12345</th><th>soup.find_all([“a”, “b”])# [<b>The Dormouse’s story</b>,# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,# <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>D.传 True</strong></p><p><code>True</code> 可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点</p><table><thead><tr><th>1234567891011</th><th>for tag in soup.find_all(True):  print(tag.name)# html# head# title# body# p# b# p# a# a</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>E.传方法</strong></p><p>如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 [<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id85">4]</a> ,如果这个方法返回 <code>True</code> 表示当前元素匹配并且被找到,如果不是则反回 <code>False</code></p><p>下面方法校验了当前元素,如果包含 <code>class</code> 属性却不包含 <code>id</code> 属性,那么将返回 <code>True</code>:</p><table><thead><tr><th>12</th><th>def has_class_but_no_id(tag):  return tag.has_attr(‘class’) and not tag.has_attr(‘id’)</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>将这个方法作为参数传入 <code>find_all()</code> 方法,将得到所有<p>标签:</p><table><thead><tr><th>1234</th><th>soup.find_all(has_class_but_no_id)# [<p class="title"><b>The Dormouse’s story</b></p>,# <p class="story">Once upon a time there were…</p>,# <p class="story">…</p>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>2）keyword 参数</strong></p><blockquote><p><strong>注意：如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 <code>id</code> 的参数,Beautiful Soup会搜索每个tag的”id”属性</strong></p></blockquote><table><thead><tr><th>12</th><th>soup.find_all(id=’link2’)# [<a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>如果传入 <code>href</code> 参数,Beautiful Soup会搜索每个tag的”href”属性</p><table><thead><tr><th>12</th><th>soup.find_all(href=re.compile(“elsie”))# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>使用多个指定名字的参数可以同时过滤tag的多个属性</p><table><thead><tr><th>12</th><th>soup.find_all(href=re.compile(“elsie”), id=’link1’)# [<a class="sister" href="http://example.com/elsie" id="link1">three</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在这里我们想用 class 过滤，不过 class 是 python 的关键词，这怎么办？加个下划线就可以</p><table><thead><tr><th>1234</th><th>soup.find_all(“a”, class_=”sister”)# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,# <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性</p><table><thead><tr><th>123</th><th>data_soup = BeautifulSoup(‘<div data-foo="value">foo!</div>‘)data_soup.find_all(data-foo=”value”)# SyntaxError: keyword can’t be an expression</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>但是可以通过 <code>find_all()</code> 方法的 <code>attrs</code> 参数定义一个字典参数来搜索包含特殊属性的tag</p><table><thead><tr><th>12</th><th>data_soup.find_all(attrs={“data-foo”: “value”})# [<div data-foo="value">foo!</div>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>3）text 参数</strong></p><p>通过 <code>text</code> 参数可以搜搜文档中的字符串内容.与 <code>name</code> 参数的可选值一样, <code>text</code> 参数接受 字符串 , 正则表达式 , 列表, True</p><table><thead><tr><th>12345678</th><th>soup.find_all(text=”Elsie”)# [u’Elsie’] soup.find_all(text=[“Tillie”, “Elsie”, “Lacie”])# [u’Elsie’, u’Lacie’, u’Tillie’] soup.find_all(text=re.compile(“Dormouse”))[u”The Dormouse’s story”, u”The Dormouse’s story”]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>4）limit 参数</strong></p><p><code>find_all()</code> 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 <code>limit</code> 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 <code>limit</code> 的限制时,就停止搜索返回结果.</p><p>文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量</p><table><thead><tr><th>123</th><th>soup.find_all(“a”, limit=2)# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>5）recursive 参数</strong></p><p>调用tag的 <code>find_all()</code> 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 <code>recursive=False</code> .</p><p>一段简单的文档:</p><table><thead><tr><th>1234567</th><th><html><head> <title>  The Dormouse’s story </title></head>…</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>是否使用 <code>recursive</code> 参数的搜索结果:</p><table><thead><tr><th>12345</th><th>soup.html.find_all(“title”)# [<title>The Dormouse’s story</title>] soup.html.find_all(“title”, recursive=False)# []</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（2）find-name-attrs-recursive-text-kwargs"><a href="#（2）find-name-attrs-recursive-text-kwargs" class="headerlink" title="（2）find( name , attrs , recursive , text , **kwargs )"></a>（2）find( name , attrs , recursive , text , **kwargs )</h4><p>它与 find_all() 方法唯一的区别是 <code>find_all()</code> 方法的返回结果是值包含一个元素的列表,而 <code>find()</code> 方法直接返回结果</p><h4 id="（3）find-parents-find-parent"><a href="#（3）find-parents-find-parent" class="headerlink" title="（3）find_parents()  find_parent()"></a>（3）find_parents()  find_parent()</h4><p><code>find_all()</code> 和 <code>find()</code> 只搜索当前节点的所有子节点,孙子节点等. <code>find_parents()</code> 和 <code>find_parent()</code> 用来搜索当前节点的父辈节点,搜索方法与普通tag的搜索方法相同,搜索文档搜索文档包含的内容</p><h4 id="（4）find-next-siblings-find-next-sibling"><a href="#（4）find-next-siblings-find-next-sibling" class="headerlink" title="（4）find_next_siblings()  find_next_sibling()"></a>（4）find_next_siblings()  find_next_sibling()</h4><p>这2个方法通过 .next_siblings 属性对当 tag 的所有后面解析的兄弟 tag 节点进行迭代, <code>find_next_siblings()</code> 方法返回所有符合条件的后面的兄弟节点,<code>find_next_sibling()</code> 只返回符合条件的后面的第一个tag节点</p><h4 id="（5）find-previous-siblings-find-previous-sibling"><a href="#（5）find-previous-siblings-find-previous-sibling" class="headerlink" title="（5）find_previous_siblings()  find_previous_sibling()"></a>（5）find_previous_siblings()  find_previous_sibling()</h4><p>这2个方法通过 .previous_siblings 属性对当前 tag 的前面解析的兄弟 tag 节点进行迭代, <code>find_previous_siblings()</code>方法返回所有符合条件的前面的兄弟节点, <code>find_previous_sibling()</code> 方法返回第一个符合条件的前面的兄弟节点</p><h4 id="（6）find-all-next-find-next"><a href="#（6）find-all-next-find-next" class="headerlink" title="（6）find_all_next()  find_next()"></a>（6）find_all_next()  find_next()</h4><p>这2个方法通过 .next_elements 属性对当前 tag 的之后的 tag 和字符串进行迭代, <code>find_all_next()</code> 方法返回所有符合条件的节点, <code>find_next()</code> 方法返回第一个符合条件的节点</p><h4 id="（7）find-all-previous-和-find-previous"><a href="#（7）find-all-previous-和-find-previous" class="headerlink" title="（7）find_all_previous() 和 find_previous()"></a>（7）find_all_previous() 和 find_previous()</h4><p>这2个方法通过 .previous_elements 属性对当前节点前面的 tag 和字符串进行迭代, <code>find_all_previous()</code> 方法返回所有符合条件的节点, <code>find_previous()</code>方法返回第一个符合条件的节点</p><blockquote><p><strong>注：以上（2）（3）（4）（5）（6）（7）方法参数用法与 find_all() 完全相同，原理均类似，在此不再赘述。</strong></p></blockquote><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>我们在写 CSS 时，标签名不加任何修饰，类名前加点，id名前加 #，在这里我们也可以利用类似的方法来筛选元素，用到的方法是 <strong>soup.select()，</strong>返回类型是 <strong>list</strong></p><h4 id="（1）通过标签名查找"><a href="#（1）通过标签名查找" class="headerlink" title="（1）通过标签名查找"></a>（1）通过标签名查找</h4><table><thead><tr><th>12</th><th>print soup.select(‘title’) #[<title>The Dormouse’s story</title>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>12</th><th>print soup.select(‘a’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>, <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>, <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>12</th><th>print soup.select(‘b’)#[<b>The Dormouse’s story</b>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（2）通过类名查找"><a href="#（2）通过类名查找" class="headerlink" title="（2）通过类名查找"></a>（2）通过类名查找</h4><table><thead><tr><th>12</th><th>print soup.select(‘.sister’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>, <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>, <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（3）通过-id-名查找"><a href="#（3）通过-id-名查找" class="headerlink" title="（3）通过 id 名查找"></a>（3）通过 id 名查找</h4><table><thead><tr><th>12</th><th>print soup.select(‘#link1’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（4）组合查找"><a href="#（4）组合查找" class="headerlink" title="（4）组合查找"></a>（4）组合查找</h4><p>组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开</p><table><thead><tr><th>12</th><th>print soup.select(‘p #link1’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>直接子标签查找</p><table><thead><tr><th>12</th><th>print soup.select(“head &gt; title”)#[<title>The Dormouse’s story</title>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（5）属性查找"><a href="#（5）属性查找" class="headerlink" title="（5）属性查找"></a>（5）属性查找</h4><p>查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。</p><table><thead><tr><th>12</th><th>print soup.select(‘a[class=”sister”]’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>, <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>, <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>12</th><th>print soup.select(‘a[href=”<a href="http://example.com/elsie&quot;]&#39;)#[">http://example.com/elsie&quot;]&#39;)#[</a><a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>同样，属性仍然可以与上述查找方式组合，不在同一节点的空格隔开，同一节点的不加空格</p><table><thead><tr><th>12</th><th>print soup.select(‘p a[href=”<a href="http://example.com/elsie&quot;]&#39;)#[">http://example.com/elsie&quot;]&#39;)#[</a><a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。</p><table><thead><tr><th>123456</th><th>soup = BeautifulSoup(html, ‘lxml’)print type(soup.select(‘title’))print soup.select(‘title’)[0].get_text() for title in soup.select(‘title’):  print title.get_text()</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>好，这就是另一种与 find_all 方法有异曲同工之妙的查找方法，是不是感觉很方便？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过爬取下载&lt;strong&gt;斗图啦&lt;/strong&gt;&lt;a href=&quot;https://www.doutula.com/photo/list?page=0&quot;&gt;https://www.doutula.com/photo/list?page=0&lt;/a&gt;中的表情包，来练习爬虫&lt;/p</summary>
      
    
    
    
    <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
    <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫中的数据提取</title>
    <link href="http://yoursite.com/archives/pachong.html"/>
    <id>http://yoursite.com/archives/pachong.html</id>
    <published>2020-07-30T01:45:49.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96">数据提取</a><ul><li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E6%A6%82%E5%BF%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E7%B1%BB">数据提取概念和数据的分类</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96">什么是数据提取</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E7%A7%8D%E7%B1%BB">数据的种类</a><ul><li><a href="#%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE">构化数据</a></li><li><a href="#%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE">非结构化数据</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul></li></ul><h2 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>用网络获取的数据中提取出想要的数据。</p></blockquote><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ul><li>数据提取概念和数据的分类</li><li>使用 <code>json</code> 模块提取数据</li><li>使用正则表达式提取数据</li><li>使用 <code>xpath</code> 提取数据</li><li>使用 <code>beautifulsoup</code> 提取数据</li><li><code>json</code>、<code>csv</code> 数据转换</li></ul><h3 id="数据提取概念和数据的分类"><a href="#数据提取概念和数据的分类" class="headerlink" title="数据提取概念和数据的分类"></a>数据提取概念和数据的分类</h3><h4 id="什么是数据提取"><a href="#什么是数据提取" class="headerlink" title="什么是数据提取"></a>什么是数据提取</h4><blockquote><p>简单的来说，数据提取就是从响应中获取我们想要的数据的过程</p></blockquote><h4 id="数据的种类"><a href="#数据的种类" class="headerlink" title="数据的种类"></a>数据的种类</h4><h5 id="构化数据"><a href="#构化数据" class="headerlink" title="构化数据"></a>构化数据</h5><ul><li><p><strong>数据类型</strong></p></li><li><p>json 格式数据</p><pre><code class="json">&#123;&quot;name&quot;:&quot;hello&quot;,&quot;age&quot;:18,&quot;parents&quot;:&#123;  &quot;mother&quot;:&quot;妈妈&quot;,  &quot;father&quot;:&quot;爸爸&quot;&#125;&#125;</code></pre></li><li><p>xml 格式数据</p><pre><code class="xml">&lt;bookstore&gt;&lt;book category=&quot;COOKING&quot;&gt;  &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;   &lt;author&gt;Giada De Laurentiis&lt;/author&gt;   &lt;year&gt;2005&lt;/year&gt;   &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;CHILDREN&quot;&gt;  &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;   &lt;author&gt;J K. Rowling&lt;/author&gt;   &lt;year&gt;2005&lt;/year&gt;   &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt;  &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;   &lt;author&gt;Erik T. Ray&lt;/author&gt;   &lt;year&gt;2003&lt;/year&gt;   &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt;</code></pre></li><li><p>处理方式</p><blockquote><p>通过 json 模块等直接转成 Python 数据类型</p></blockquote></li></ul><h5 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h5><ul><li>数据类型<ul><li>html 格式数据</li><li>word 格式数据</li><li>等</li></ul></li><li><strong>处理方式</strong><blockquote><p>通过 <code>正则表达式</code> 、 <code>xpath</code> 、<code>beautifulsoup</code> 等模块提取数据</p></blockquote></li></ul><h2 id="爬取大学排行"><a href="#爬取大学排行" class="headerlink" title="爬取大学排行"></a>爬取大学排行</h2><p>接下来通过一篇实例来了解<code>爬取html格式数据转换</code><br>因为正值高考报名期间，便以大学软科排名网站(<strong>这里只是学习爬虫。如何排名无关紧要</strong>)</p><h3 id="获取网站url"><a href="#获取网站url" class="headerlink" title="获取网站url"></a>获取网站url</h3><ol><li>打开<br><a href="http://www.zuihaodaxue.cn/zuihaodaxuepaiming2020.html">2020软科中国大学排名</a><br><img src="https://gitee.com/koyangyang/pictures/raw/master/pachong(1).png"></li><li>按f12进入开发者控制台（谷歌浏览器等）<br><img src="https://gitee.com/koyangyang/pictures/raw/master/pachong(2).png"><br>按照图示指示获得url，并知道是get请求方式</li><li>打开测试软件获得爬取的结果<br><img src="https://gitee.com/koyangyang/pictures/raw/master/pachong(3).png"><br>通过结果找到自己想要爬取的数据，并对结果进行筛选，这里爬取获得的是html数据<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="python"># coding=UTF-8import requestsfrom bs4 import BeautifulSoup</code></pre></li></ol><h1 id="目标网站url"><a href="#目标网站url" class="headerlink" title="目标网站url"></a>目标网站url</h1><p>url = “<a href="http://www.zuihaodaxue.cn/zuihaodaxuepaiming2020.html&quot;">http://www.zuihaodaxue.cn/zuihaodaxuepaiming2020.html&quot;</a></p><h1 id="自定义请求头部"><a href="#自定义请求头部" class="headerlink" title="自定义请求头部"></a>自定义请求头部</h1><p>headers = {<br>    “User-Agent”: “Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36”<br>}</p><h1 id="获取请求返回内容"><a href="#获取请求返回内容" class="headerlink" title="获取请求返回内容"></a>获取请求返回内容</h1><p>respoense = requests.get(url, headers=headers).content.decode(‘utf-8’)</p><h1 id="将内容通过BeautifulSoup转换数据"><a href="#将内容通过BeautifulSoup转换数据" class="headerlink" title="将内容通过BeautifulSoup转换数据"></a>将内容通过BeautifulSoup转换数据</h1><p>trans = BeautifulSoup(respoense, “html.parser”)</p><h1 id="在所有数据中查找div标签"><a href="#在所有数据中查找div标签" class="headerlink" title="在所有数据中查找div标签"></a>在所有数据中查找<code>div</code>标签</h1><p>re_div = trans.find_all(‘div’)</p><h1 id="遍历所有含div标签的内容"><a href="#遍历所有含div标签的内容" class="headerlink" title="遍历所有含div标签的内容"></a>遍历所有含<code>div</code>标签的内容</h1><p>for names in re_div:<br>    if(names.get(‘align’) == ‘left’):<br>        print(names.string)</p><p>```</p><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200730155230.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是爬虫的初步学习，对于一些简单的网站基本适用，关键在于如何对爬取获得的请求返回信息进行一个转换和提取才是关键</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96&quot;&gt;数据提取&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%8B%E7%BB%8D&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A6%82%</summary>
      
    
    
    
    <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
    <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>信息纷繁复杂时代的RSS利器</title>
    <link href="http://yoursite.com/archives/rss.html"/>
    <id>http://yoursite.com/archives/rss.html</id>
    <published>2020-07-21T15:04:33.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们目前生活在一个每天充斥着大量信息时代，微博、杂志、短视频、公众号等等每天都在给我们推送很多复杂并未经分类的信息，其中有不少是娱乐信息，社会猎奇新闻，国际前沿信息，而我们的兴趣却被慢慢忽视掉了，各种团体疯狂抢取流量的竞争，也正是为啥我们需要了解使用一种合适的获取信息的方法。</p><h2 id="RSS简介"><a href="#RSS简介" class="headerlink" title="RSS简介"></a>RSS简介</h2><ul><li>可以简单的理解为一种订阅方式，其实官方名字应该叫作<strong>简单信息聚合</strong>（也叫聚合内容）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议，它的英文全称叫作<strong>Really Simple Syndication</strong>。</li><li><strong>RSS</strong>广泛用于网上新闻频道，blog和wiki，主要的版本有0.91, 1.0, 2.0。使用RSS订阅能更快地获取信息，网站提供RSS输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持RSS的聚合工具软件，在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。<h2 id="如何获得RSS"><a href="#如何获得RSS" class="headerlink" title="如何获得RSS"></a>如何获得RSS</h2><h3 id="网站提供"><a href="#网站提供" class="headerlink" title="网站提供"></a>网站提供</h3>最简单的方法是直接查找现成的RSS订阅地址，比如我们有时候看到网址有不起眼的RSS超链接或图标等类似提示标志，如图：<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/rss1.png"><br>这时我们点开网址，既可以看到类似这样充满摘选文字信息的网页<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/rss2.png"><br>然后我们复制并记录这个网页的链接，并将其添加到<strong>RSS阅读器</strong>中,即可获得当下网址的内容<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/rss3.png"><h3 id="自己获取RSS订阅地址"><a href="#自己获取RSS订阅地址" class="headerlink" title="自己获取RSS订阅地址"></a>自己获取RSS订阅地址</h3><h4 id="扩展程序获取"><a href="#扩展程序获取" class="headerlink" title="扩展程序获取"></a>扩展程序获取</h4>这里推荐的是<strong>RSShub Reader</strong>这款扩展程序，可以在谷歌扩展程序商店搜到<img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/rss4.png"><br>当你浏览那些把RSS订阅按钮隐藏起来的网站，可以点击这个扩展程序，它可以发现这个网页隐藏的RSS订阅地址，然后可以收集复制这个链接去RSS阅读器使用并订阅这个网站。<h4 id="试探性查找"><a href="#试探性查找" class="headerlink" title="试探性查找"></a>试探性查找</h4>一般可以尝试在你想要找到RSS订阅地址的网址后面加上<code>/feed</code>或者<code>aatom.xml</code>，这两个是一般RSS订阅默认提供的方式，如果有更多欢迎补充。比如我们在我的网站<a href="https://www.koyang.shop/">https://www.koyang.shop</a>后加上<code>atom.xml</code>成<a href="https://www.koyang.shop/atmo.xml">https://www.koyang.shop/atmo.xml</a>,这个网址就是我的网站的RSS订阅地址，很多人添加RSS功能没有修改订阅地址一般默认就是网址后面加<code>/feed</code>或<code>atom.xml</code><h4 id="第三方提供服务"><a href="#第三方提供服务" class="headerlink" title="第三方提供服务"></a>第三方提供服务</h4>在<strong>RSShub Reader</strong>的官方网址也是提供了很多RSS订阅地址，这个已经是<strong>RSShub Reader</strong>搭建完成并提供给大家使用的订阅服务，找到你喜欢的网站或内容的RSS订阅地址，复制到RSS阅读器上去，即可开始订阅网址，特别简单方便，<strong>不用动手的感觉真爽</strong>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们目前生活在一个每天充斥着大量信息时代，微博、杂志、短视频、公众号等等每天都在给我们推送很多复杂并未经分类的信息，其中有不少是娱乐信息，社</summary>
      
    
    
    
    
    <category term="分享" scheme="http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>看透一件事，没必要说破</title>
    <link href="http://yoursite.com/archives/test1.html"/>
    <id>http://yoursite.com/archives/test1.html</id>
    <published>2020-07-16T03:25:57.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这是测试文本转语言功能，由于hexo没有后台数据库，目前我找到的办法是把文件传到Onedrive里面，在解析外链引用，如果听不到声音是因为网络问题加载，稍等一会就好，后续有更好办法在更新修改</strong></p><center><audio id="audio" controls="" preload="auto" radius="50%">      <source id="mp3" src="https://onedrive.gimhoy.com/sharepoint/aHR0cHM6Ly8yOWp0MC1teS5zaGFyZXBvaW50LmNvbS86dTovZy9wZXJzb25hbC9rb3lhbmdfY3N1X2Nvb2wvRWFkX1dSRDJVMGhMcnRlb0wzQ2RGYXdCWVpFOHdDSllMSkJQZ3M2TUxCWGFTdz9lPVc1Y3hEWQ==.mp3"></audio></center><p>做人，不是多说话，而是要会说话；不懂时，不说，懂时，少说。<br>与小人争辩，辨不出道理；与家人争辩，伤的是和气；与朋友争辩，伤的是感情。<br>守嘴是福，不多吵，不多说，不多问，嘴上不多说，心里明白就行。<br>为人处世，不会说的，就不要说；不该说的，就不必说，直话，转弯说；反话，正着说。<br>不要不懂装懂，夸夸其谈，少说几句，没有人会把你当哑巴，话多了，容易得罪人，也会给自己带来祸害，守好一张嘴，把好是非关，生活才会心安。<br>自古，树大招风，言多必失。祸从口出的道理要牢记。<br>有些话，只适合藏着，不适合说；有些事，只适合看破，不可以说。<br>￼<br>看清一个人，没必要拆穿；讨厌一个人，没必要翻脸；看透一件事，没必要说破。<br>心里明白，嘴上不要说出来，这样才不会伤到自己，招惹别人。<br>人生路上，要学会沉默，该明白的要明白，该看透的就要看透，不该说的 就不要说。<br>经历了岁月，才能明白人生的苦痛，经历了磨练才能懂得生活的艰辛，要明白，学会说话，说好话，是人的一生中必修的功课。<br>沉默不是懦弱，不是无能，而是心灵通透后的豁达，选择后的安静，凡事看开，人生才坦然，学会沉默，让岁月走过清简流年，岁月静好。<br>说话，让着别人，不去争，不去吵，与人和善；凡事看透不说透，凡事看破不说破，与人留余地，与自己留后路。<br>有些人，只是点头之交，没必要掏心掏肺；有些人，只是表面和善，没必要全抛一颗真心。<br>￼<br>学着糊涂一点，学会愚笨一点，这样才安静，才从容。<br>沉默是最好的自救，尤其是在情绪不稳定的情况下，一定要学会闭嘴。<br>人在极度愤怒的时候，最容易出口伤人，也许是有口无心，图个痛快，但是生气的话往往失去了理智，伤人伤己，等你冷静下来的时候，后悔也无用，话从口出就会覆水难收。<br>极度生气的时候，最好能够自己冷静片刻，忍住冲动的表达，给自己留点余地，才不给自己惹祸伤身，免得犯下大错。<br>￼<br>受到打击的时候，人最容易陷入悲哀痛苦的负面情绪中，看不到希望，看不到未来，人很容易悲观，绝望，很多时候会想不通，说出傻话。<br>一个人在颓废消极的时候，不要去胡乱说话，免得被人笑话你的懦弱，走出去呼吸呼吸空气散散心，接近大自然，在广阔的天地之间体会人生的坚强。<br>人在大悲的时候，容易悲观，在大喜的时候，容易兴奋过度，这个时候，人往往容易失态，一开心，口无遮拦的说出了很多掏心窝的实话，给嫉妒恨你的人留下暗算你的隐患；要记住，自己的成绩虽然可喜，但是人外有人，天外有天，不要太过高调。<br>说话，是每个正常人最简单的能力，往往我们说一句话，毫不费力，却因为多说一句话，而招惹是非；做人，不能太过自我，要考虑到所处的说话环境，顾及他人的感受，有所把握，然后才能好好说话，好好生活。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;这是测试文本转语言功能，由于hexo没有后台数据库，目前我找到的办法是把文件传到Onedrive里面，在解析外链引用，如果听不到声音是因为网络问题加载，稍等一会就好，后续有更好办法在更新修改&lt;/strong&gt;&lt;/p&gt;
&lt;center&gt;&lt;audio id=&quot;a</summary>
      
    
    
    
    
    <category term="分享" scheme="http://yoursite.com/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="Test" scheme="http://yoursite.com/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>如何进行内网穿透</title>
    <link href="http://yoursite.com/archives/xiaomy.html"/>
    <id>http://yoursite.com/archives/xiaomy.html</id>
    <published>2020-07-13T02:09:17.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为生产环境的需要，把自己的主力实体机换成了Linux(强调不是虚拟机)，但是因为经常外出，为了方便出门在外仍然可以操作家中电脑，所以现在考虑尝试内网穿透<br>说起内网穿透很多人不知道是干啥的，接下来简单的讲解一下内外网区别</p><h2 id="内网和外网区别"><a href="#内网和外网区别" class="headerlink" title="内网和外网区别"></a>内网和外网区别</h2><p>内网和外网的定义：</p><ul><li>内网通俗的说就是局域网，是几台或者几十台电脑之间互相连接用于资源共享的网络。比如邻居之间的电脑连成内网打CS。</li><li>外网通俗的说就是与因特网相通的。可以访问因特网上的所有网络资源。如果你用的是ADSL连接的就是外网<br>具体详细解答还请移步：<a href="https://m.sohu.com/a/321883781_100195755/?pvid=000115_3w_a">传送门</a><br>因为中国的三大运营商是不主动提供公网IP，你也可以跟客服申请公网IP(基本不给，给也不是固定IP)</li></ul><p>所以现在往内网穿透方向考虑</p><h2 id="注册一个网穿云账号"><a href="#注册一个网穿云账号" class="headerlink" title="注册一个网穿云账号"></a>注册一个网穿云账号</h2><p>网上很多提供内网穿透服务的厂商，现在拿<strong>网穿云</strong>做教程，因为这个才刚起步，有条免费隧道，个人使用还是很不错<br><a href="https://www.xiaomy.net/">注册地址</a></p><ol><li>进入控制台-开通一条隧道<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou2.png"><br>个人使用一条3Mbps的免费隧道应该够用，如果你需要多条隧道或者搭建游戏服务器开黑、搭建语音聊天平台、搭建多人在线网站和资源文件下载站可以考虑升级配置，输入优惠码uwn8qw即可，一般个人使用一条免费隧道即可<br>输入本地需要穿透的内网地址，端口号，隧道类型后点击开通就可以</li><li>下载服务端<br>点击顶部下载自己电脑系统的服务端，网穿云是提供全平台的服务端，我这里用的Linux所以我下载Linux版本<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou1.png"></li><li>运行服务端<br>打开后输入控制台里面的令牌即可，几秒钟解析完毕就可以外网连接<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou3.png"></li></ol><h2 id="外网连接"><a href="#外网连接" class="headerlink" title="外网连接"></a>外网连接</h2><p>输入控制台里面的域名和端口号连接即可</p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>随机给的域名太贵可以修改域名，也可以自己绑定自己购买的域名(免费隧道不支持)</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>我这里显示的是Linux系统，也只是方便我在外控制家中电脑终端，更多用途比如连接家中服务器，网站搭建，数据库远程访问等就不展示，内网穿透用途懂得自然懂<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou5.jpg"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>内网穿透是干什么的：最直白讲就是出门在外可以连接家中任何局域网设备，比如电脑、NAS、下载器</li><li>网穿云是否永久免费：目前阶段是永久免费<img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou4.jpg"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近因为生产环境的需要，把自己的主力实体机换成了Linux(强调不是虚拟机)，但是因为经常外出，为了方便出门在外仍然可以操作家中电脑，所以现在考虑尝试内网穿透&lt;br&gt;说起内网穿透很多人不知道是干啥的，接下来简单的讲解一下内外网区别&lt;/p&gt;
&lt;h2 id=&quot;内网和外网区别&quot;&gt;</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="内网穿透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>常用的Git命令</title>
    <link href="http://yoursite.com/archives/git.html"/>
    <id>http://yoursite.com/archives/git.html</id>
    <published>2020-07-12T09:18:59.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<p>经常用Github怎么能不会Git命令，收录一些常用的Git命令</p><a id="more"></a><p>听说Linux和git搭配更加好用，附上我正在使用的Linux系统<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/desktop.png"></p><h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h2><h3 id="1-1-git-配置"><a href="#1-1-git-配置" class="headerlink" title="1.1. git 配置"></a>1.1. git 配置</h3><pre><code class="shell"># 显示 config 的配置 加--list# 优先级：local &gt; global &gt; systemgit config --list --local # local 的范围是某个仓库git config --list --global # global 的范围是登录的用户git config --list --system # system 的范围是系统所有登录的用户# 配置用户 name 和 emailgit config --global user.name &#39;your_name &#39;git config --global user.email &#39;your_email@domain.com&#39;# 清除配置信息git config --unset --global user.name</code></pre><h3 id="1-2-仓库初始化"><a href="#1-2-仓库初始化" class="headerlink" title="1.2. 仓库初始化"></a>1.2. 仓库初始化</h3><pre><code class="shell"># 将执行该命令时所在的目录初始化为一个 git 仓库（如：进入某目录后执行该命令会将该目录初始化为一个 git 仓库）git init# 会在当前路径下创建和项目名称同名的文件夹，并将其初始化为 git 仓库git init your_project</code></pre><h3 id="1-3-git-add"><a href="#1-3-git-add" class="headerlink" title="1.3. git add"></a>1.3. git add</h3><pre><code class="shell">git add readme.md # 将 readme.md 文件添加到暂存区git add . # 将当前工作目录的所有文件添加到暂存区git add -u # 把修改之后的文件（这些文件已经被管理起来了）一次性提交到暂存区</code></pre><h3 id="1-4-git-status"><a href="#1-4-git-status" class="headerlink" title="1.4. git status"></a>1.4. git status</h3><pre><code class="shell">git status # 查看工作目录和暂存区的状态</code></pre><h3 id="1-5-git-commit"><a href="#1-5-git-commit" class="headerlink" title="1.5. git commit"></a>1.5. git commit</h3><pre><code class="shell">git commit -m &#39;Add readme.md&#39; # -m 指定 commit 的信息git commit # 这时候会跳出一个文本输入界面，让你输入更多的 commit 信息</code></pre><h3 id="1-6-git-mv"><a href="#1-6-git-mv" class="headerlink" title="1.6. git mv"></a>1.6. git mv</h3><pre><code class="shell">git mv readme readme.md # 将 git 管理的文件进行重命名</code></pre><h3 id="1-7-git-rm"><a href="#1-7-git-rm" class="headerlink" title="1.7. git rm"></a>1.7. git rm</h3><pre><code class="shell">git rm filename # 从 git 管理的文件删除某个已管理的文件，同时把修改的情况添加到暂存区</code></pre><h3 id="1-8-git-log"><a href="#1-8-git-log" class="headerlink" title="1.8. git log"></a>1.8. git log</h3><pre><code class="shell">git log # 只查看当前分支(Head所指的分支)的log情况git log --oneline # 简洁的显示版本更新信息git log -n2  # n2 代表查看最近两次commit历史git log -2   # 2 代表查看最近两次commit历史git log -n2 --oneline # 简洁的显示最近两次的版本更新信息git log branch_name # 后面跟上分支名表示查看该分支的log日志git log -all # 列出所有分支的loggit log --all --graph # 以图形化的方式查看git log --oneline --all # 以简洁的方式查看所有分支的loggit log --oneline --all -n4# 以简洁的方式查看所有分支的loggit help log # 以web的方式查看log的帮助文档，等同于git help --web log # 和上面那条效果一样</code></pre><h2 id="2-分支相关"><a href="#2-分支相关" class="headerlink" title="2. 分支相关"></a>2. 分支相关</h2><pre><code class="shell">git branch -v # 查看本地分支的详细情况git branch -a # 查看所有分支，包括远端分支，但没有过于详细的信息git branch -av # 查看所有分支情况git branch branch_name hash_value # 创建一个新的分支，基于 hash_value 的这个 commit 创建一个新的分支，hash_value 可以省略，那么默认是基于当前分支的最后一个 commit 创建。git branch -d branch_namegit branch -D branch_name  # 这个分支已经有了一些 commitgit checkout branch_name # 切换分支git checkout mastergit checkout -b branch_name git_id # 创建一个新的分支并切换过去，git_id可以是hash_value，也可以是某个分支的名字（分支的名字其实就指向了某个 commit）git checkout -b temp 9ef147dgit checkout -b temp2 mastergit checkout hash_value  # 分离头指针</code></pre><h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><pre><code class="shell">git diff hash_value1 hash_value2 # hash_value1 对应的 comimit 和 hash_value2 对应的 commit 进行比较git diff hash_value1 hash_value2 -- file_name1 file_name2 # 在上述基础之上，只比较 file_name1、file_name2 这两个文件git diff branch_name1 branch_name2 # 对两个分支进行比较，也可以跟 -- 只看某些文件git diff HEAD HEAD^  # HEAD 指向的 commit 与该 commit 的父亲 commit 进行比较git diff HEAD HEAD^^ # HEAD 指向的 commit 与该 commit 的父亲的父亲 commit 进行比较git diff HEAD HEAD~  # HEAD 指向的 commit 与该 commit 的父亲 commit 进行比较git diff HEAD HEAD~1 # 同上 git diff HEAD HEAD~2 # HEAD 指向的 commit 与该 commit 的父亲的父亲 commit 进行比较git diff --cached  # 暂存区和 HEAD 做比较，也可以跟 -- 只看某些文件git diff      # 工作目录和暂存区中所有文件进行比较，也可以跟 -- 只看某些文件</code></pre><h2 id="4-版本历史更改"><a href="#4-版本历史更改" class="headerlink" title="4. 版本历史更改"></a>4. 版本历史更改</h2><pre><code class="shell">git commit --amend # 最近一次 commit 的 message 修改git rebase -i hash_value # 交互文件中选择 reword，老旧 commit 的 message 修改。hash_value，是需要的 commit 的父亲 commit 的 hash_valuegit rabase -i hash_value # 交互文件中选择 squash，多个连续 commit 合并成一个，hash_value 同上git rebase -i hash_value # 交互文件中选择 squash，把间隔的 commit 移到一块，即可合并成一个，hash_valuegit rebase origin/master # 把当前分支基于 origin/master 做 rebase 操作，也就相当于把当前分支的东西加到 origin/master 中</code></pre><h2 id="5-回滚操作"><a href="#5-回滚操作" class="headerlink" title="5. 回滚操作"></a>5. 回滚操作</h2><pre><code class="shell">git reset HEAD        # 暂存区恢复成和 HEAD 一样git reset HEAD -- file_name1 file_name2 # 暂存区部分文件变得跟 HEAD 一样git checkout -- file_name # 工作目录指定文件恢复为和暂存区一样git checkout -- *|. ## 工作目录全部文件恢复为和暂存区一样git reset --hard hash_value # 把 HEAD、暂存区、工作目录都回滚到 hash_value 所代表的 commit 中。git reset --hard  # 把暂存区里面的修改去掉，也就是让暂存区、工作目录默认恢复到 HEAD 的位置</code></pre><h2 id="6-工作目录、暂存区状态保存"><a href="#6-工作目录、暂存区状态保存" class="headerlink" title="6. 工作目录、暂存区状态保存"></a>6. 工作目录、暂存区状态保存</h2><pre><code class="shell">git stash # 把相应的修改内容给存下来，之后 git status 查看的话又变为什么都没改变的了git stash list # 查看存下来的内容git stash apply # 存下来的内容又恢复了，但是存下来的内容还在 stash 中git stash pop   # 存下来的内容恢复了，但是存下来的内容也没了</code></pre><h2 id="7-合并"><a href="#7-合并" class="headerlink" title="7. 合并"></a>7. 合并</h2><pre><code class="shell">git merge branch_name1 branch_name2git merge hash_value1 hash_value2git merge --squash # 以 squash 方式进行 merge</code></pre><h2 id="8-Git-对象操作"><a href="#8-Git-对象操作" class="headerlink" title="8. Git 对象操作"></a>8. Git 对象操作</h2><pre><code class="shell">git cat-file -t|p|s hash_value # 显示版本库对象的内容，类型及大小信息git cat-file -t hash_value  # 查看版本库对象的类型git cat-file -p hash_value  # 查看版本库对象的内容git cat-file -s hash_value  # 查看版本库对象的大小</code></pre><h2 id="9-Git-远端操作"><a href="#9-Git-远端操作" class="headerlink" title="9. Git 远端操作"></a>9. Git 远端操作</h2><pre><code class="shell">git remote add &lt;远端名&gt; &lt;远端仓库地址&gt; # 这边远端名的意思是远端仓库的别名，push、pull 都将用到远端名git remote -v  # 查看远端仓库连接情况git remote set-url &lt;远端名&gt; 你新的远程仓库地址 # 修改远端仓库地址git remote rm &lt;远端名&gt;      # 删除远端仓库git clone &lt;远端仓库地址&gt; # 把远端仓库 clone 下来git clone --bare  &lt;远端仓库地址&gt; # bare 是指不带工作目录，也就相当于只 clone .git 目录git push &lt;远端名&gt; &lt;本地分支名&gt; git push -u &lt;远端名&gt; &lt;本地分支名&gt; # -u 表示将本地分支的内容推到远端分支，并且将本地分支和远端分支关联起来git push -u origin master # 表示把本地 master 分支的内容推到远端分支 origin/master，并且将本地分支 master 和远端分支 origin/master 关联起来git push # 这条命令也可以使用，默认是将当前本地所在分支推到相关联的远端分支git fetch &lt;远端名&gt; &lt;本地分支名&gt;git fetch origin master # 将远端分支 origin/master fetch 到本地git pull &lt;远端名&gt; &lt;本地分支名&gt; # 将远端分支 fetch 到本地，并且将远端分支和本地所处分支进行合并git pull --rebase # 以 rebase 方式进行合并，也就是将本地分支 rebase 到远端分支</code></pre><h2 id="Github上传项目"><a href="#Github上传项目" class="headerlink" title="Github上传项目"></a>Github上传项目</h2><ol><li>在Github上new一个Repository</li><li>打开Git Bash输入<pre><code class="git">git clone https://github.com/用户名/项目名.git</code></pre></li><li>把项目文件移动这个文件夹</li><li>依次输入<pre><code class="git">git add .git commit -m &quot;内容&quot;git push -u origin master</code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;经常用Github怎么能不会Git命令，收录一些常用的Git命令&lt;/p&gt;</summary>
    
    
    
    <category term="Wiki" scheme="http://yoursite.com/categories/Wiki/"/>
    
    
    <category term="Wiki" scheme="http://yoursite.com/tags/Wiki/"/>
    
    <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Linux帮助信息命令指北</title>
    <link href="http://yoursite.com/archives/linux1.html"/>
    <id>http://yoursite.com/archives/linux1.html</id>
    <published>2020-07-11T02:02:30.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看-Linux-命令帮助信息的要点"><a href="#1-查看-Linux-命令帮助信息的要点" class="headerlink" title="1. 查看 Linux 命令帮助信息的要点"></a>1. 查看 Linux 命令帮助信息的要点</h2><ul><li>查看 Shell 内部命令的帮助信息 - 使用 <a href="#help">help</a></li><li>查看命令的简要说明 - 使用 <a href="#whatis">whatis</a></li><li>查看命令的详细说明 - 使用 <a href="#info">info</a></li><li>查看命令的位置 - 使用 <a href="#which">which</a></li><li>定位指令的二进制程序、源代码文件和 man 手册页等相关文件的路径 - 使用 <a href="#whereis">whereis</a></li><li>查看命令的帮助手册（包含说明、用法等信息） - 使用 <a href="#man">man</a></li><li>只记得部分命令关键字 - 使用 man -k</li></ul><h2 id="2-命令常见用法"><a href="#2-命令常见用法" class="headerlink" title="2. 命令常见用法"></a>2. 命令常见用法</h2><h3 id="2-1-help"><a href="#2-1-help" class="headerlink" title="2.1. help"></a>2.1. help</h3><p><strong>help命令</strong>用于显示shell内部命令的帮助信息。help命令只能显示shell内部的命令帮助信息。而对于外部命令的帮助信息只能使用man或者info命令查看。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>help(选项)(参数)</code></pre><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><pre><code>-s：输出短格式的帮助信息。仅包括命令格式。</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>内部命令：指定需要显示帮助信息的shell内部命令。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>使用help命令显示shell内部shopt命令的帮助信息，输入如下命令：</p><pre><code>help shopt                #获取shopt命令的帮助信息shopt: shopt [-pqsu] [-o long-option] optname [optname...]    Toggle the values of variables controlling optional behavior.    The -s flag means to enable (set) each OPTNAME; the -u flag    unsets each OPTNAME.  The -q flag suppresses output; the exit    status indicates whether each OPTNAME is set or unset.  The -o    option restricts the OPTNAMEs to those defined for use with    `set -o&#39;.  With no options, or with the -p option, a list of all    settable options is displayed, with an indication of whether or    not each is set.</code></pre><h3 id="2-2-whatis"><a href="#2-2-whatis" class="headerlink" title="2.2. whatis"></a>2.2. whatis</h3><p><strong>whatis命令</strong>是用于查询一个命令执行什么功能，并将查询结果打印到终端上。</p><p>whatis命令在用<code>catman -w</code>命令创建的数据库中查找command参数指定的命令、系统调用、库函数或特殊文件名。whatis命令显示手册部分的页眉行。然后可以发出man命令以获取附加的信息。whatis命令等同于使用<code>man -f</code>命令。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code>whatis</code></pre><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>[root@localhost ~]# whatis lsls                   (1)  - list directory contentsls                   (1p)  - list directory contents[root@localhost ~]# whatis cpcp                   (1)  - copy files and directoriescp                   (1p)  - copy files[root@localhost ~]# whatis chownchown                (1)  - change file owner and groupchown                (1p)  - change the file ownershipchown                (2)  - change ownership of a filechown                (3p)  - change owner and group of a file[root@localhost ~]# whatis manman                  (1)  - format and display the on-line manual pagesman                  (1p)  - display system documentationman                  (7)  - macros to format man pagesman                 (rpm) - A set of documentation tools: man, apropos and whatis.man-pages           (rpm) - Man (manual) pages from the Linux Documentation Project.man.config [man]     (5)  - configuration data for man</code></pre><h3 id="2-3-info"><a href="#2-3-info" class="headerlink" title="2.3. info"></a>2.3. info</h3><p><strong>info命令</strong>是Linux下info格式的帮助指令。</p><p>就内容来说，info页面比man page编写得要更好、更容易理解，也更友好，但man page使用起来确实要更容易得多。一个man page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。理解这个命令的窍门就是不仅要学习如何在单独的Info页面中浏览导航，还要学习如何在节点和子节点之间切换。可能刚开始会一时很难在info页面的节点之间移动和找到你要的东西，真是具有讽刺意味：原本以为对于新手来说，某个东西比man命令会更好些，但实际上学习和使用起来更困难。</p><p><code>info(选项)(参数)</code></p><h4 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h4><pre><code>-d：添加包含info格式帮助文档的目录；-f：指定要读取的info格式的帮助文档；-n：指定首先访问的info帮助文件的节点；-o：输出被选择的节点内容到指定文件。</code></pre><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>帮助主题：指定需要获得帮助的主题，可以是指令、函数以及配置文件。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>在info后面输入命令的名称就可以查看该命令的info帮助文档了：</p><pre><code>info info</code></pre><p>面介绍一下它的几个常用快捷键。</p><pre><code>?键：它就会显示info的常用快捷键。N键：显示（相对于本节点的）下一节点的文档内容。P键：显示（相对于本节点的）前一节点的文档内容。U键：进入当前命令所在的主题。M键：敲M键后输入命令的名称就可以查看该命令的帮助文档了。G键：敲G键后输入主题名称，进入该主题。L键：回到上一个访问的页面。SPACE键：向前滚动一页。BACKUP或DEL键：向后滚动一页。Q：退出info。</code></pre><p><strong>命令</strong></p><pre><code>？     显示帮助窗口在帮助窗口中：Ctrl-x 0          关闭帮助窗口Ctrl-x Ctrl-c    关闭整个 Infoq      退出 infon      打开与本 Node 关联的下一个 Nodep      打开与本 Node 关联的前一个 Nodeu      打开与本 Node 关联的上一个 Nodel      回到上一次访问的 Nodem或g   选择一个菜单项（Node 的名字）       输入指定菜单的名字后按回车，打开指定菜单项关联的 Node空格键 下一页（PageDown 也可以，下一页从当前页的最后两行开始算起）       下一个 Node （若当前页在 Node 文档的末尾）Del 键 上一页（PageUp 也可以，上一页从当前页的开始两行开始算起）       上一个 Node （若当前页 Node 文档的开始）b 或 t 或 Home   文档的开始（b 是 begining 的意思）e 或 End         文档的末尾（b 是 ending 的意思）Ctrl-l    刷新当前页，若当前文档显示情况有问题时Ctrl-g    取消所键入的指令</code></pre><h3 id="2-4-which"><a href="#2-4-which" class="headerlink" title="2.4. which"></a>2.4. which</h3><p><strong>which命令</strong>用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre><code>which(选项)(参数)</code></pre><h4 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h4><pre><code>-n&lt;文件名长度&gt;：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；-p&lt;文件名长度&gt;：与-n参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径；-w：指定输出时栏位的宽度；-V：显示版本信息。</code></pre><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><p>指令名：指令名列表。</p><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>查找文件、显示命令路径：</p><pre><code>[root@localhost ~]# which pwd/bin/pwd[root@localhost ~]#  which adduser/usr/sbin/adduser</code></pre><p>说明：which是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p><h3 id="2-5-whereis"><a href="#2-5-whereis" class="headerlink" title="2.5. whereis"></a>2.5. whereis</h3><p><strong>whereis命令</strong>用来定位指令的二进制程序、源代码文件和<a href="#man">man</a>手册页等相关文件的路径。</p><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p><p>和<a href="#find">find</a>相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的<a href="#locate">locate</a>时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre><code>whereis(选项)(参数)</code></pre><h4 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h4><pre><code>-b：只查找二进制文件；-B&lt;目录&gt;：只在设置的目录下查找二进制文件；-f：不显示文件名前的路径名称；-m：只查找说明文件；-M&lt;目录&gt;：只在设置的目录下查找说明文件；-s：只查找原始代码文件；-S&lt;目录&gt;只在设置的目录下查找原始代码文件；-u：查找不包含指定类型的文件。</code></pre><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><p>指令名：要查找的二进制程序、源文件和man手册页的指令名。</p><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><p>将相关的文件都查找出来</p><pre><code>[root@localhost ~]# whereis tomcattomcat:[root@localhost ~]# whereis svnsvn: /usr/bin/svn /usr/local/svn /usr/share/man/man1/svn.1.gz</code></pre><p>说明：tomcat没安装，找不出来，svn安装找出了很多相关文件</p><p>只将二进制文件查找出来 </p><pre><code>[root@localhost ~]# whereis -b svnsvn: /usr/bin/svn /usr/local/svn[root@localhost ~]# whereis -m svnsvn: /usr/share/man/man1/svn.1.gz[root@localhost ~]# whereis -s svnsvn:</code></pre><p>说明：<code>whereis -m svn</code>查出说明文档路径，<code>whereis -s svn</code>找source源文件。</p><h3 id="2-6-man"><a href="#2-6-man" class="headerlink" title="2.6. man"></a>2.6. man</h3><p><strong>man命令</strong>是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><pre><code>man(选项)(参数)</code></pre><h4 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h4><pre><code>-a：在所有的man帮助手册中搜索；-f：等价于whatis指令，显示给定关键字的简短描述信息；-P：指定内容时使用分页程序；-M：指定man手册搜索的路径。</code></pre><h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul><li>数字：指定从哪本man手册中搜索帮助；</li><li>关键字：指定要搜索帮助的关键字。</li></ul><p>示例：</p><pre><code>$ man date # 查看 date 命令的帮助手册$ man 3 printf # 查看 printf 命令的帮助手册中的第 3 类$ man -k keyword # 根据命令中部分关键字来查询命令</code></pre><h5 id="2-6-1-man-要点"><a href="#2-6-1-man-要点" class="headerlink" title="2.6.1. man 要点"></a>2.6.1. man 要点</h5><p>在 man 的帮助手册中，可以使用 page up 和 page down 来上下翻页。</p><p>man 的帮助手册中，将帮助文档分为了 9 个类别，对于有的关键字可能存在多个类别中， 我们就需要指定特定的类别来查看；（一般我们查询 bash 命令，归类在 1 类中）。</p><p>man 页面的分类(常用的是分类 1 和分类 3)：</p><ol><li>可执行程序或 shell 命令</li><li>系统调用(内核提供的函数)</li><li>库调用(程序库中的函数)</li><li>特殊文件(通常位于 /dev)</li><li>文件格式和规范，如 /etc/passwd</li><li>游戏</li><li>杂项(包括宏包和规范，如 man(7)，groff(7))</li><li>系统管理命令(通常只针对 root 用户)</li><li>内核例程 [非标准]</li></ol><p>前面说到使用 whatis 会显示命令所在的具体的文档类别，我们学习如何使用它</p><pre><code>$ whatis printfprintf (1) - format and print dataprintf (1p) - write formatted outputprintf (3) - formatted output conversionprintf (3p) - print formatted outputprintf [builtins](1) - bash built-in commands, see bash(1)</code></pre><p>我们看到 printf 在分类 1 和分类 3 中都有；分类 1 中的页面是命令操作及可执行文件的帮助；而 3 是常用函数库说明；如果我们想看的是 C 语言中 printf 的用法，可以指定查看分类 3 的帮助：</p><pre><code>$ man 3 printf</code></pre><h3 id="Linux命令查询"><a href="#Linux命令查询" class="headerlink" title="Linux命令查询"></a>Linux命令查询</h3><p><a href="https://man.linuxde.net/">传送门</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-查看-Linux-命令帮助信息的要点&quot;&gt;&lt;a href=&quot;#1-查看-Linux-命令帮助信息的要点&quot; class=&quot;headerlink&quot; title=&quot;1. 查看 Linux 命令帮助信息的要点&quot;&gt;&lt;/a&gt;1. 查看 Linux 命令帮助信息的要点&lt;/h2</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Wiki" scheme="http://yoursite.com/tags/Wiki/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux下搭建Hexo</title>
    <link href="http://yoursite.com/archives/linuxhexo.html"/>
    <id>http://yoursite.com/archives/linuxhexo.html</id>
    <published>2020-07-09T05:36:34.000Z</published>
    <updated>2021-07-13T03:33:10.589Z</updated>
    
    <content type="html"><![CDATA[<p>因为一些原因，我已经把我的工作环境从Windows10换到了Linux，所以一些环境的搭建需要更换，接下来介绍如何配置Linux环境来搭建Hexo。</p><a id="more"></a><h2 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h2><p>这个是必须的，因为hexo就是基于nodejs的，从<a href="https://link.jianshu.com/?t=http://nodejs.cn/">官网</a>下载压缩包，解压即可</p><p>不过这里的命令不是全局的，所以需要把node和npm设置成全局</p><pre><code class="bash">ln -s /home/node-v4.4.4-linux-x64/bin/node /usr/local/bin/node  ln -s /home/node-v4.4.4-linux-x64/bin/npm /usr/local/bin/npm  </code></pre><p>前边的**/home/node-v4.4.4-linux-x64/bin/npm** 是自己的node所在的路径，这个记得改成自己的</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>打开终端输入：</p><pre><code class="bash">sudo apt install git</code></pre><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>打开终端输入：</p><pre><code class="bash">npm install hexo-cli -g</code></pre><h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><pre><code class="bash">hexo init hexo</code></pre><h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><p>具体操作和Windows上一样<br>在终端输入：</p><pre><code class="bash">ssh-keygen -t rsacd .ssh/cat id_rsa.pub</code></pre><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/linuxhexo.png"></p><p>将说的key填入Github中<br>参考<a href="https://www.koyang.shop/archives/blog.html">利用Hexo+Github Pages搭建个人博客</a></p><h2 id="Hexo-部署到-GitHub-Pages"><a href="#Hexo-部署到-GitHub-Pages" class="headerlink" title="Hexo 部署到 GitHub Pages"></a>Hexo 部署到 GitHub Pages</h2><h3 id="config-yml-配置修改"><a href="#config-yml-配置修改" class="headerlink" title="_config.yml 配置修改"></a>_config.yml 配置修改</h3><pre><code class="bash">[root@zhangblog hexo]# pwd/app/softinsall/hexo[root@zhangblog hexo]# vim _config.yml………………# Deployment## Docs: https://hexo.io/docs/deployment.html  # 修改或添加如下信息deploy:  type: git  repo: git@github.com:zhanglianghhh/zhanglianghhh.github.io.git  branch: master</code></pre><h2 id="上传Github"><a href="#上传Github" class="headerlink" title="上传Github"></a>上传Github</h2><p>打开终端输入</p><pre><code class="bash">hexo n 文章名hexo cleanhexo ghexo d</code></pre><p>即可推送到Github仓库</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为一些原因，我已经把我的工作环境从Windows10换到了Linux，所以一些环境的搭建需要更换，接下来介绍如何配置Linux环境来搭建Hexo。&lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Rclone+aria2实现OneDrive高速离线下载</title>
    <link href="http://yoursite.com/archives/aria2.html"/>
    <id>http://yoursite.com/archives/aria2.html</id>
    <published>2020-07-07T01:12:36.000Z</published>
    <updated>2021-07-13T03:33:10.585Z</updated>
    
    <content type="html"><![CDATA[<p>对于一些大容量网盘，如OneDrive，Google云端硬盘等本身是不自带离线下载，现在我们可以借助第三方工具aria2实现高速多线程离线下载，如有Linux用户同样适用于多线程本地下载。</p><a id="more"></a><p>先附上一张效果图：</p><p><img src="http://p.ananas.chaoxing.com/star3/origin/e15213cc87391633c6a82575db9d9fd4.png"></p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><ol><li>装有Linux系统的电脑，推荐Debian/Ubuntu(大流量VPS更好)</li><li>懂点SSH连接</li></ol><h2 id="安装并配置aria2"><a href="#安装并配置aria2" class="headerlink" title="安装并配置aria2"></a>安装并配置aria2</h2><p>这里推荐<a href="https://github.com/P3TERX/aria2.sh">P3TERX</a>大的一键脚本</p><pre><code class="Shell">wget -N git.io/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; ./aria2.sh</code></pre><p>这里因为<a href="https://github.com/P3TERX/aria2.sh">P3TERX</a>大已经配置好了aria2，目前已经是速度最快和BT trackers最多的配置，如果喜欢自定义配置可以参考aria2官方提供的安装脚本</p><p><strong>如果你使用的Linux系统，至此已经完成了Linux本地下载器的搭建</strong></p><h2 id="挂载Rclone"><a href="#挂载Rclone" class="headerlink" title="挂载Rclone"></a>挂载Rclone</h2><h3 id="客户端授权"><a href="#客户端授权" class="headerlink" title="客户端授权"></a>客户端授权</h3><p>在本地Windows电脑上下载rclone，下载地址：<a href="https://rclone.org/downloads/">https://rclone.org/downloads/</a>,解压文件夹，在此文件夹打开cmd命令，输入</p><pre><code class="cmd">rclone authorize &quot;onedrive&quot;</code></pre><p>然后会弹出浏览器登陆即可，在返回cmd</p><pre><code class="cmd">C:\Users\Administrator&gt;cd /d d:\rcloned:\rclone&gt;rclone authorize &quot;onedrive&quot;2018/01/23 20:28:56 NOTICE: Config file &quot;C:\\Users\\Administrator\\.config\\rclone\\rclone.conf&quot; not found - using defaultsChoose OneDrive account type? * Say b for a OneDrive business account * Say p for a personal OneDrive accountb) Businessp) Personalb/p&gt; p  #这里选择个人版，你想挂载Business就选择bIf your browser doesn&#39;t open automatically go to the following link: http://127.0.0.1:53682/auth  #接下来会弹出浏览器，要求你登录账号进行授权Log in and authorize rclone for accessWaiting for code...Got codePaste the following into your remote machine ---&gt;&#123;&quot;access_token&quot;:&quot;xxxx&quot;&#125;  #请复制&#123;xx&#125;整个内容，后面需要用到&lt;---End paste</code></pre><h3 id="安装Rclone"><a href="#安装Rclone" class="headerlink" title="安装Rclone"></a>安装Rclone</h3><ol><li>安装Rclone<br>用SSH连接Debian/Ubuntu，输入Rclone官方给的安装脚本<pre><code class="Shell">wget https://www.moerats.com/usr/shell/rclone_debian.sh &amp;&amp; bash rclone_debian.sh</code></pre></li><li>初始化配置<br>输入<pre><code class="Shell">rclone config</code></pre></li><li>按注释输入<pre><code class="Shell">n) New remotes) Set configuration passwordq) Quit confign/s/q&gt; nname&gt; Rats  #随便填，后面要用到Type of storage to configure.Choose a number from below, or type in your own value1 / Amazon Drive \ &quot;amazon cloud drive&quot;2 / Amazon S3 (also Dreamhost, Ceph, Minio) \ &quot;s3&quot;3 / Backblaze B2 \ &quot;b2&quot;4 / Box \ &quot;box&quot;5 / Cache a remote \ &quot;cache&quot;6 / Dropbox \ &quot;dropbox&quot;7 / Encrypt/Decrypt a remote \ &quot;crypt&quot;8 / FTP Connection \ &quot;ftp&quot;9 / Google Cloud Storage (this is not Google Drive) \ &quot;google cloud storage&quot;10 / Google Drive \ &quot;drive&quot;11 / Hubic \ &quot;hubic&quot;12 / Local Disk \ &quot;local&quot;13 / Microsoft Azure Blob Storage \ &quot;azureblob&quot;14 / Microsoft OneDrive \ &quot;onedrive&quot;15 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \ &quot;swift&quot;16 / Pcloud \ &quot;pcloud&quot;17 / QingCloud Object Storage \ &quot;qingstor&quot;18 / SSH/SFTP Connection \ &quot;sftp&quot;19 / Webdav \ &quot;webdav&quot;20 / Yandex Disk \ &quot;yandex&quot;21 / http Connection \ &quot;http&quot;Storage&gt; 14  #选择14，Microsoft OneDrive，，注意该序列号会随时变化，看清楚再填Microsoft App Client Id - leave blank normally.client_id&gt;  #留空 Microsoft App Client Secret - leave blank normally.client_secret&gt;  #留空 Remote configChoose OneDrive account type?* Say b for a OneDrive business account* Say p for a personal OneDrive accountb) Businessp) Personalb/p&gt; p  #这里选择个人版，你想挂载Business就选择bUse auto config?* Say Y if not sure* Say N if you are working on a remote or headless machiney) Yesn) Noy/n&gt; n  #选择nFor this to work, you will need rclone available on a machine that has a web browser available.Execute the following on your machine:  rclone authorize &quot;onedrive&quot;Then paste the result below:result&gt; &#123;&quot;access_token&quot;:&quot;&quot;&#125;  #输入之前在客户端授权的内容</code></pre></li></ol><hr><p>[Rats]<br>client_id =<br>client_secret =<br>token = {“access_token”:””}</p><hr><p>y) Yes this is OK<br>e) Edit this remote<br>d) Delete this remote<br>y/e/d&gt; y  选择y<br>Current remotes:</p><p>Name                 Type<br>====                 ====<br>Rats                 onedrive</p><p>e) Edit existing remote<br>n) New remote<br>d) Delete remote<br>r) Rename remote<br>c) Copy remote<br>s) Set configuration password<br>q) Quit config<br>e/n/d/r/c/s/q&gt; q  #选择q退出</p><pre><code>## 配置自动上传脚本- 输入nano /root/.aria2c/upload.sh打开自动上传脚本进行编辑```nano# Rclone 配置时填写的网盘名(name)DRIVE_NAME=&#39;Onedrive&#39;# 网盘目录。即上传目标路径，留空为网盘根目录，末尾不要有斜杠。DRIVE_PATH=&#39;/DRIVEX/Download&#39;</code></pre><ul><li>输入nano /root/.aria2c/aria2.conf打开 Aria2 配置文件进行修改。<pre><code class="nano"># 下载完成后执行的命令on-download-complete=/root/.aria2c/upload.sh</code></pre></li><li>重启<br><code>reboot</code></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>PC端使用请下载AriaNg这个前端管理界面并连接Aria2地址<br>下载地址：<a href="https://github.com/mayswind/AriaNg/releases">https://github.com/mayswind/AriaNg/releases</a></p></li><li><p>手机端可以用微信小程序，界面简洁还自带影视下载添加<br><img src="http://p.ananas.chaoxing.com/star3/origin/ae7ab95e08b39942315fee2baf3a613f.png"></p></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>离线下载完后脚本会自动删除本地文件，不用担心本地空间占用</li><li>严格按照教程来进行操作不会遇到问题，如果有问题那一定是你自身的问题，请仔细阅读教程中的每一个字。</li><li>如果你对nano编辑器不了解，可以看看这个<a href="https://blog.csdn.net/weixin_41293827/article/details/106812686">https://blog.csdn.net/weixin_41293827/article/details/106812686</a></li><li>Shell软件推荐免费的<strong>Xshell</strong>，手机端推荐<strong>termius</strong></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于一些大容量网盘，如OneDrive，Google云端硬盘等本身是不自带离线下载，现在我们可以借助第三方工具aria2实现高速多线程离线下载，如有Linux用户同样适用于多线程本地下载。&lt;/p&gt;</summary>
    
    
    
    <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="aria2" scheme="http://yoursite.com/tags/aria2/"/>
    
  </entry>
  
</feed>
