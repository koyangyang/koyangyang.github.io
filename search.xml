<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微信小程序学习(今日天气)</title>
      <link href="/archives/wxxcx.html"/>
      <url>/archives/wxxcx.html</url>
      
        <content type="html"><![CDATA[<p>这个是记录微信小程序的学习，开发一款今日天气<br>目前完成</p><ul><li>获取实时位置信息并显示天气信息</li><li>手动选择位置信息并获取天气</li></ul><p>所用<code>api</code>来自和风天气,请自行注册<code>key</code>,代码中的<code>key</code>皆用<code>****</code>表示。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>打开微信开发工具<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210712083155.png"></p><h2 id="删除所有内容"><a href="#删除所有内容" class="headerlink" title="删除所有内容"></a>删除所有内容</h2><p>删除初始化所有内容并新建<code>app.json</code>、<code>app.js</code>、<code>app.wxss</code>,在新建的<code>app.json</code>中输入<code>&#123;&#125;</code>并保存。</p><h2 id="新建page"><a href="#新建page" class="headerlink" title="新建page"></a>新建page</h2><p>在<code>pages/index</code>目录下右键新建<code>page</code><br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210712084526.png"></p><h2 id="文件作用"><a href="#文件作用" class="headerlink" title="文件作用"></a>文件作用</h2><ul><li>js:页面逻辑 (JavaScript)</li><li>json:负责标题栏和一些状态栏</li><li>wxml:管理页面有什么 (html)</li><li>wxss:页面排版 (css)</li></ul><h2 id="修改标题栏"><a href="#修改标题栏" class="headerlink" title="修改标题栏"></a>修改标题栏</h2><p>修改<code>app.json</code>文件，输入<code>window</code><br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210712100817.png"></p><h2 id="编写index-wxml内容"><a href="#编写index-wxml内容" class="headerlink" title="编写index.wxml内容"></a>编写<code>index.wxml</code>内容</h2><p>相当于编写小程序页面有什么内容</p><pre><code class="html">&lt;view class=&quot;container&quot;&gt;      &lt;!-- 区域一 选择器 --&gt;    &lt;picker mode=&quot;region&quot; bindchange=&quot;ChangeRegion&quot;&gt;      &lt;view&gt;&#123;&#123;region&#125;&#125;&lt;/view&gt;    &lt;/picker&gt;      &lt;!-- 区域二 文本区 --&gt;    &lt;text&gt;&#123;&#123;now.temp&#125;&#125; ℃ &#123;&#123;now.text&#125;&#125;&lt;/text&gt;      &lt;!--区域三 图片  --&gt;      &lt;image src=&quot;../../images/&#123;&#123;now.icon&#125;&#125;.png&quot;&gt;&lt;/image&gt;      &lt;!-- 区域四 天气信息 --&gt;      &lt;view class=&quot;detail&quot;&gt;          &lt;view class=&quot;bar&quot;&gt;              &lt;view class=&quot;box&quot;&gt;湿度&lt;/view&gt;              &lt;view class=&quot;box&quot;&gt;气压&lt;/view&gt;              &lt;view class=&quot;box&quot;&gt;能见度&lt;/view&gt;          &lt;/view&gt;          &lt;view class=&quot;bar&quot;&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.humidity&#125;&#125; %&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.pressure&#125;&#125; hPa&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.vis&#125;&#125; Km&lt;/view&gt;          &lt;/view&gt;          &lt;view class=&quot;bar&quot;&gt;            &lt;view class=&quot;box&quot;&gt;风向&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;风速&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;风力&lt;/view&gt;          &lt;/view&gt;          &lt;view class=&quot;bar&quot;&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.windDir&#125;&#125;&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.windSpeed&#125;&#125; Km/h&lt;/view&gt;            &lt;view class=&quot;box&quot;&gt;&#123;&#123;now.windScale&#125;&#125; 级&lt;/view&gt;          &lt;/view&gt;      &lt;/view&gt;&lt;/view&gt;</code></pre><h2 id="编写逻辑代码index-js"><a href="#编写逻辑代码index-js" class="headerlink" title="编写逻辑代码index.js"></a>编写逻辑代码<code>index.js</code></h2><pre><code class="js">Page(&#123;  data: &#123;      region:[&quot;北京市&quot;,&quot;北京市&quot;,&quot;东城区&quot;],      location:&quot;&quot;,      now:&#123;&quot;icon&quot;:999&#125;  &#125;,  onLoad:function()&#123;      this.getnowlocation();  &#125;,  ChangeRegion:function(e)&#123;    this.setData(&#123;      region:e.detail.value    &#125;)    this.getLocation()  &#125;,  getLocation:function()&#123;    var that=this;       wx.request(&#123;         url: &#39;https://geoapi.qweather.com/v2/city/lookup?&#39;,         data:&#123;           key:&#39;****&#39;,           location:that.data.region[2]         &#125;,         success:function(res)&#123;           that.setData(&#123;location:res.data.location[0].id&#125;);           that.getWeather();          &#125;        &#125;)      &#125;,  getnowlocation:function()&#123;    var that=this;    wx.getLocation(&#123;      type:&#39;wgs84&#39;,      success (res) &#123;        that.setData(&#123;location:res.longitude+&quot;,&quot;+res.latitude&#125;)        that.setCity();        that.getWeather();        &#125;    &#125;)  &#125;,  setCity:function()&#123;    var that=this;    wx.request(&#123;      url: &#39;https://geoapi.qweather.com/v2/city/lookup?&#39;,      data:&#123;        key:&#39;****&#39;,        location:that.data.location      &#125;,      success:function(res)&#123;        console.log(res.data.location[0])        that.setData(&#123;          region:[res.data.location[0].adm1,res.data.location[0].adm2,res.data.location[0].name]        &#125;)      &#125;    &#125;)  &#125;,  getWeather:function()&#123;      var that=this;      wx.request(&#123;        url: &#39;https://devapi.qweather.com/v7/weather/now?&#39;,        data:&#123;          key:&#39;****&#39;,          location:that.data.location        &#125;,        success:function(res)&#123;           that.setData(&#123;now:res.data.now&#125;)        &#125;      &#125;)  &#125;&#125;)</code></pre><h2 id="编写排版文件index-wxss"><a href="#编写排版文件index-wxss" class="headerlink" title="编写排版文件index.wxss"></a>编写排版文件<code>index.wxss</code></h2><pre><code class="css">.container&#123;  height: 100vh;  display: flex;  flex-direction: column;  align-items: center;  justify-content: space-around;&#125;.detail&#123;  width: 100%;  display: flex;  flex-direction: column;&#125;.bar&#123;  margin: 20rpx 0;  display: flex;  flex-direction: row;&#125;.box&#123;  width: 33.3%;  text-align: center;&#125;</code></pre><h2 id="最终样式"><a href="#最终样式" class="headerlink" title="最终样式"></a>最终样式</h2><p>加入了打开时获取当前位置信息，需要授权位置信息获取权限，稍后可以手动选择查询位置<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210713112518.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Terminal的美化</title>
      <link href="/archives/wterminal.html"/>
      <url>/archives/wterminal.html</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h2><p>与一般软件的设置界面不同，Windows Terminal 采用 json 文件对 Terminal 进行设置。单击设置，会打开一个settings.json的文件。现在的Windows 10应该会在你点击“设置”后提示你用什么软件来打开json文件。</p><h2 id="Windows-Terminal-美化"><a href="#Windows-Terminal-美化" class="headerlink" title="Windows Terminal 美化"></a>Windows Terminal 美化</h2><h3 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h3><p>设置中可以选择预设配置配色和字体，新版加入了可视化设置,可以设置透明度(毛玻璃)<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1625993057000.png"></p><h3 id="安装-Powerline-字体"><a href="#安装-Powerline-字体" class="headerlink" title="安装 Powerline 字体"></a>安装 Powerline 字体</h3><p>下载 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Meslo.zip">Meslo LGM NF 1</a>字体来支持 Oh-my-Posh V3 的特殊符号</p><h3 id="安装-posh-git-以及-oh-my-posh"><a href="#安装-posh-git-以及-oh-my-posh" class="headerlink" title="安装 posh-git 以及 oh-my-posh"></a>安装 posh-git 以及 oh-my-posh</h3><pre><code class="CMD">Install-Module posh-git -Scope CurrentUserInstall-Module oh-my-posh -Scope CurrentUser</code></pre><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1625993195000.png"></p><h3 id="在-PowerShell-中设置-Powerline"><a href="#在-PowerShell-中设置-Powerline" class="headerlink" title="在 PowerShell 中设置 Powerline"></a>在 PowerShell 中设置 Powerline</h3><p>在 PowerShell 中输入<code>notepad $profile</code>用文本文档打开 PowerShell 配置文件。</p><pre><code class="CMD">Import-Module posh-gitImport-Module oh-my-poshSet-PoshPrompt -Theme Paradox</code></pre><p>现在，每个新实例启动时都会导入 Posh-Git 和 Oh-My-Posh，然后从 Oh-My-Posh 设置 Paradox 主题。<a href="https://ohmyposh.dev/docs/themes">内置主题</a>。</p><h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><ol><li>win10左下角点击logo，找到Windows Powershell，右击，然后以管理员身份打开.</li><li>输入<pre><code class="CMD">get-ExecutionPolicy   # 查看系统执行策略状态set-executionpolicy remotesigned # 修改执行策略状态</code></pre></li><li>重新打开</li></ol><h3 id="PowerShell-的更新"><a href="#PowerShell-的更新" class="headerlink" title="PowerShell 的更新"></a>PowerShell 的更新</h3><p>自带的 PS 版本　是 5.0 的 ，可以升级到更高版本， 目前稳定版本为 7.x</p><pre><code class="CMD">$PSVersionTable.PSVersion.Major   #查看Powershell版本$PSVersionTable.CLRVersion.Major  #查看.NET Framework版本</code></pre><p>在<a href="https://github.com/PowerShell/PowerShell/releases">这里</a>找到<code>**x64.msi</code>,下载安装即可。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1625994201000.png"></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PYQT5的安装配置使用</title>
      <link href="/archives/pyqt5.html"/>
      <url>/archives/pyqt5.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装PYQT5"><a href="#安装PYQT5" class="headerlink" title="安装PYQT5"></a>安装PYQT5</h2><ol><li>pyqt5安装</li></ol><ul><li>直接使用pip安装,但是需要SIP的支持,所以先安装SIP,再安装pyqt5<pre><code class="cmd">pip install sippip install PyQt5</code></pre><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1616852334000.png"></li></ul><ol start="2"><li>安装QT Designer</li></ol><ul><li>同样使用pip安装<br><code>pip install PyQt5-tools</code></li></ul><h2 id="在Pycharm中配置QT-Designer"><a href="#在Pycharm中配置QT-Designer" class="headerlink" title="在Pycharm中配置QT Designer"></a>在Pycharm中配置QT Designer</h2><h3 id="配置QT-Designer"><a href="#配置QT-Designer" class="headerlink" title="配置QT Designer"></a>配置QT Designer</h3><ul><li>QT Designer默认路径<code>C:\Users\用户名\AppData\Local\Programs\Python\Python38\Lib\site-packages\qt5_applications\Qt\bin</code><blockquote><ul><li>Name：可自己定义 <ul><li>Program：指向上述路径里面的designer.exe</li><li>Work directory：使用变量 $FileDir$</li></ul></li></ul></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1616852877000.png"></p><h3 id="配置PyUIC"><a href="#配置PyUIC" class="headerlink" title="配置PyUIC"></a>配置PyUIC</h3><blockquote><ul><li>Name：可自己定义</li><li>Program：指向上述python.exe(默认<code>C:\Users\codeyang\AppData\Local\Programs\Python\Python38\python.exe</code>)</li><li>Arguments: <code>-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py</code></li><li>Work directory：使用变量 $FileDir$</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1616853200000.png"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在顶部<code>工具</code>栏中可以找到这两个工具</p><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1616853416000.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github Actions自动化部署</title>
      <link href="/archives/hexoaction.html"/>
      <url>/archives/hexoaction.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="一，import这个仓库"><a href="#一，import这个仓库" class="headerlink" title="一，import这个仓库"></a>一，import这个仓库</h3><p>点击新建一个仓库，你会在新建仓库页面看到这个<code>Import a repository</code>，点它</p><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921213026.png"></p><p>然后你会看到如下图的内容</p><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921213146.png"></p><p>在<code>You old repository&#39;s clone URL</code>下填我这个项目的链接</p><pre><code class="html">https://github.com/FuShaoLei/auto-hexo-template</code></pre><p>然后为了安全起见（或者说是为了隐私起见），将仓库设为<code>private</code></p><p>都设置完后点击下面那个绿色按钮<code>Begin import</code>即可</p><p>完成时如下</p><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921213520.png"></p><h3 id="二，根据你的情况修改参数"><a href="#二，根据你的情况修改参数" class="headerlink" title="二，根据你的情况修改参数"></a>二，根据你的情况修改参数</h3><p>要配置的有</p><ul><li>配置公钥和私钥</li><li><code>.github/workflows/main.yml</code>里的用户名和邮箱</li><li><code>_config.yml</code>里的<code>root</code>和<code>deploy</code></li></ul><p>下面一一说明</p><h4 id="a-配置公钥和私钥"><a href="#a-配置公钥和私钥" class="headerlink" title="a.配置公钥和私钥"></a>a.配置公钥和私钥</h4><p>在你的本地<code>ctrl+r</code>输入<code>cmd</code>调出小黑块，输入</p><pre><code>ssh-keygen -t rsa -C &quot;&lt;你的github邮箱&gt;&quot;</code></pre><p>然后在<code>C:\Users\用户名\.ssh</code>中可找到</p><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200920221956.png"></p><ul><li>公钥的配置（正常来说应该是配置过了），直接在这个<a href="https://github.com/settings/keys">链接</a>点击那个new SSH key就可配置</li><li>私钥的配置，点击 <a href="https://github.com/">https://github.com/</a>&lt;你的用户名&gt;/&lt;存放源文件的仓库名&gt;/settings/secrets，新建私钥，注意，这里的名称要填<code>HEXO_DEPLOY_PRIVATE_KEY</code></li></ul><h4 id="b-配置-github-workflows-main-yml里的用户名和邮箱"><a href="#b-配置-github-workflows-main-yml里的用户名和邮箱" class="headerlink" title="b.配置.github/workflows/main.yml里的用户名和邮箱"></a>b.配置<code>.github/workflows/main.yml</code>里的用户名和邮箱</h4><p>这个不多说了，底部可以找到<br><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921214724.png"></p><h4 id="c-配置-config-yml里的root和deploy"><a href="#c-配置-config-yml里的root和deploy" class="headerlink" title="c.配置_config.yml里的root和deploy"></a>c.配置<code>_config.yml</code>里的<code>root</code>和<code>deploy</code></h4><p>如果你部署的仓库名是<code>&lt;你的github用户名&gt;.github.io</code>），那么用默认的就行了，如果不是的话，要改成</p><pre><code class="yml">root: /&lt;仓库名&gt;/</code></pre><p>然后是<code>deploy</code>，大家根据自己的需求来改就好了</p><pre><code class="yml">deploy:  type: git  repository: git@github.com:&lt;你的用户名&gt;/&lt;部署hexo的仓库名&gt;.git  branch: master</code></pre><h3 id="三，允许使用github-aciton即可"><a href="#三，允许使用github-aciton即可" class="headerlink" title="三，允许使用github aciton即可"></a>三，允许使用github aciton即可</h3><p><img src="https://cdn.jsdelivr.net/gh/fushaolei/img2/20200921215108.png"></p><p>点击那个绿色的按钮即可</p><h3 id="四，自定义修改"><a href="#四，自定义修改" class="headerlink" title="四，自定义修改"></a>四，自定义修改</h3><ul><li>如果你使用了第三方主题，需要把主题目录的<code>.gitinit</code>删除后才能<code>push</code></li><li>如果你安装了第三方插件或一些主题需要的插件，需要在<code>mian.yml</code>中依次添加<code>npm</code>命令<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture@master/1614911848000.png"></li></ul><h3 id="五，编写文章"><a href="#五，编写文章" class="headerlink" title="五，编写文章"></a>五，编写文章</h3><p>每次本地写完文章后，只需要往源文件仓库<code>push</code>更新源文件，<code>GitHub Actions </code>监控到<code>push </code>操作时，就自动化执行<code> hexo clean</code>、<code>hexo g -d </code>操作，完成博文发布。这样可以将部署放到<code>Github Actions</code>,避免更换电脑或重装系统后每次都要重新下载部署配置的问题。进阶操作是配合<a href="https://github.com/HexoPlusPlus/HexoPlusPlus">HexoPlusPlus</a>,给Hexo加个后端管理界面，完美脱离本地主机，完全部署到云端</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java打包程序.exe</title>
      <link href="/archives/javaexe.html"/>
      <url>/archives/javaexe.html</url>
      
        <content type="html"><![CDATA[<p>Java编写的程序需要在有jre环境的设备上才能运行，在我们编写完程序后发给别人使用时，不能保证每个人的设备都安装有Java运行环境，所以需要将源码和运行所需要的环境打包成特定的可执行文件，比如Windows平台的可执行文件是.exe。</p><h2 id="新建一个项目目录"><a href="#新建一个项目目录" class="headerlink" title="新建一个项目目录"></a>新建一个项目目录</h2><p><strong>里面包含<code>file</code>、<code>res</code>、<code>jre</code>;</strong></p><ul><li>file:文件夹是放临时文件的可以没有</li><li>res:文件夹是放资源文件的，如图片，配置文件等也可以没有</li><li>jre:这个是必须的，该文件中的内容可以直接把JDK安装目录下jre的内容拷贝过来即可。有了它可以不用再装java运行环境 </li></ul><h2 id="将源码导出"><a href="#将源码导出" class="headerlink" title="将源码导出"></a>将源码导出</h2><p>第一步所需要的是将我们编写的Java整个项目导出成jar包。<br>在<code>IDEA</code>中<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210109104200.png" alt="20210109104200"><br>在项目结构中选取<img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/20210109104402.png" alt="20210109104402">选取主类即可导出<code>jar</code>包</p><h2 id="JRE环境"><a href="#JRE环境" class="headerlink" title="JRE环境"></a>JRE环境</h2><p>将安装的JRE环境拷贝到项目目录的<code>jre</code>文件夹里，如果不知道可以将整个<code>JRE</code>环境拷贝过来</p><h2 id="下载exe4j工具"><a href="#下载exe4j工具" class="headerlink" title="下载exe4j工具"></a>下载<code>exe4j</code>工具</h2><p><a href="https://www.ej-technologies.com/download/exe4j/files">下载地址</a></p><h2 id="打开exe4j开始生产-exe文件"><a href="#打开exe4j开始生产-exe文件" class="headerlink" title="打开exe4j开始生产.exe文件"></a>打开<code>exe4j</code>开始生产<code>.exe</code>文件</h2><ol><li>选择<code>JAR in EXE</code>模式<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/1.png"></li><li>名字和输出目录随便写<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/2.png"></li><li>选<code>GUI application</code><br><code>Executable name</code>写的.exe名字<br><code>Icon File</code>找到要的icon图标<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/3.png"></li><li>在<code>class path</code>中找到刚才导出的<code>jar</code>包<br>在<code>main class from</code>找到主类(有<code>main</code>方法的类)<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/4.png"></li><li>在<code>Advanced Options</code>选<code>Search sequence</code><br>删除默认的路径，把项目目录拷贝的<code>jre</code>环境选中<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/5.png"></li><li>默认即可<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/7.png"></li><li>生成成功<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/8.png"><br>点击即可打开测试</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在项目于目录就有一个<code>.exe</code>后缀的文件，打开即可运行</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fine in Codes</title>
      <link href="/archives/fineincode.html"/>
      <url>/archives/fineincode.html</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul><li>Code<pre><code class="Python">End = &quot;You&quot;while End is &quot;You&quot;:  print &quot;I wait %s&quot; % End</code></pre><blockquote><p>尽头是你我会一直等</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture//20201122195115.png"></p><h2 id="附文"><a href="#附文" class="headerlink" title="附文"></a>附文</h2><p>经常写爬虫，然后就爱上了<code>response</code>这个单词。有道词典给的翻译是：<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture//20201122200615.png"><br>最理想的状态就像：</p><pre><code class="Python">import requestsurl = &quot;everything&quot;params=&#123;&#125;data=&#123;&#125;response = requests.get(url,params=params,data=data)print(response)</code></pre><blockquote><p>事事有回应，件件有着落</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture//20201122201033.png"></p><blockquote><p>没有<code>&#39;params&#39;</code>和<code>&#39;data&#39;</code>，依然可以得到回应</p></blockquote><blockquote><p>它的应用场景应是我发消息不会等很久你才会回，和你聊天时你如果有事情要离开会提前告知我并结束话题。我不用花很多时间去等待，也不用花很多心思去猜疑，你给予我良好的反馈，于我亦是一种心安。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clash Premium For Magisk的使用</title>
      <link href="/archives/cpfm.html"/>
      <url>/archives/cpfm.html</url>
      
        <content type="html"><![CDATA[<h2 id="Clash-Premium-For-Magisk的用途"><a href="#Clash-Premium-For-Magisk的用途" class="headerlink" title="Clash Premium For Magisk的用途"></a>Clash Premium For Magisk的用途</h2><p>Google NB！</p><h2 id="需要文件下载地址"><a href="#需要文件下载地址" class="headerlink" title="需要文件下载地址"></a>需要文件下载地址</h2><p><a href="https://www.lanzoux.com/ifTojhc1i0d">Clash_Premium_For_Magisk</a></p><p><a href="https://www.lanzoux.com/inFhFhc1ixg">Dashboard</a></p><h2 id="面具刷入"><a href="#面具刷入" class="headerlink" title="面具刷入"></a>面具刷入</h2><p>Root后用面具刷入Clash Premium For Magisk/Clash For Magisk</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-093248.jpg" alt="Screenshot_20201011-093248"></p><p>刷入完成后重启这个时候clash就在后台运行了，担心需要<code>termux</code>来开启服务，下面介绍一个<code>Dashboard APP</code>这个图形化控制界面</p><h2 id="Dashboard-APP"><a href="#Dashboard-APP" class="headerlink" title="Dashboard APP"></a>Dashboard APP</h2><p>打开<code>Dashboard APP</code>，再点击<code>Premium</code>切换到<code>Premium</code>模式</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-093307.jpg" alt="Screenshot_20201011-093307"></p><p>右上角菜单，选择更新GeoIP，无需输入地址，点击确定来下载GeoIP文件，这是Clash工作所需要的文件。</p><p>再下载<code>config.yml</code>文件<img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-093320.jpg" alt="Screenshot_20201011-093320"></p><p>点击下载订阅，输入clash订阅地址<img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-093330.jpg" alt="Screenshot_20201011-093330"></p><p>下载完订阅地址就重新打开应用，然后开启<code>clash</code></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-094622.jpg" alt="Screenshot_20201011-094622"></p><p>这个时候就可以上网了</p><h2 id="进阶设置"><a href="#进阶设置" class="headerlink" title="进阶设置"></a>进阶设置</h2><h3 id="选择本地面板可以加载更快"><a href="#选择本地面板可以加载更快" class="headerlink" title="选择本地面板可以加载更快"></a>选择本地面板可以加载更快</h3><p>切换YACD面板</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-095157.jpg" alt="Screenshot_20201011-095157"></p><h3 id="关于clash地址"><a href="#关于clash地址" class="headerlink" title="关于clash地址"></a>关于clash地址</h3><ol><li><p>clash地址一般机场都会提供</p></li><li><p>自己搭建的服务器，可以使用订阅转换将vmess链接转为clash</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/Screenshot_20201011-100537.jpg" alt="Screenshot_20201011-100537"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用和一些应用安装</title>
      <link href="/archives/Docker.html"/>
      <url>/archives/Docker.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h2><p><code>Docker</code>也是目前很火的技术，当我在学习期间，因为学的东西比较多，部署环境很是麻烦，这时候就想把需要的环境搭建在<code>Docker</code>上，而且<code>Docker</code>搭建很是轻松，比如你安装<code>Centos</code>时候只需要几行命令便可以拉取安装，比起传统虚拟机安装方便快速很多，而且可以克隆部署多个。</p><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><ul><li>Ubuntu</li><li><code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></li><li>Debian</li><li><code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></li><li>Centos</li><li><code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></li></ul><h2 id="Docker加速镜像"><a href="#Docker加速镜像" class="headerlink" title="Docker加速镜像"></a>Docker加速镜像</h2><ol><li>编辑<br><code>vim /etc/docker/daemon.json</code></li><li>修改<br><code>&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;</code><br>推荐修改为<code>https://hub-mirror.c.163.com/</code></li><li>重启<br><code>sudo systemctl daemon-reload</code><br><code>sudo systemctl restart docker</code></li></ol><h3 id="一、安装Centos系统"><a href="#一、安装Centos系统" class="headerlink" title="一、安装Centos系统"></a>一、安装<code>Centos</code>系统</h3><h4 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h4><p>进入<code>Docker hub</code>官方镜像仓库<br><a href="https://hub.docker.com/search?q=&type=image">docker hub</a></p><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p><code>docker pull centos</code></p><h4 id="查看已经下载的镜像"><a href="#查看已经下载的镜像" class="headerlink" title="查看已经下载的镜像"></a>查看已经下载的镜像</h4><p><code>docker images</code></p><h4 id="查看正在运行的镜像"><a href="#查看正在运行的镜像" class="headerlink" title="查看正在运行的镜像"></a>查看正在运行的镜像</h4><p><code>docker ps</code></p><h4 id="运行一个容器"><a href="#运行一个容器" class="headerlink" title="运行一个容器"></a>运行一个容器</h4><p><code>docker run -itd --name centos-study centos</code><br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200903075810.png"></p><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p><code>docker exec -it centos-study /bin/bash</code><br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200903080139.png"><br>此时前面的名称就变了，此时已经进入centos这个容器了，查看一下系统信息<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200903080415.png"></p><h3 id="二、Docker安装portainer可视化界面"><a href="#二、Docker安装portainer可视化界面" class="headerlink" title="二、Docker安装portainer可视化界面"></a>二、Docker安装<code>portainer</code>可视化界面</h3><h4 id="搜索一下portainer"><a href="#搜索一下portainer" class="headerlink" title="搜索一下portainer"></a>搜索一下<code>portainer</code></h4><p><code>docker search portainer</code><br>看哪个镜像star多就优先选择</p><h4 id="拉去镜像"><a href="#拉去镜像" class="headerlink" title="拉去镜像"></a>拉去镜像</h4><p><code>docker pull portainer/portainer</code></p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><pre><code class="cmd">docker run -ti -d --name portainer -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock  portainer/portainer</code></pre><ul><li>–name 定义容器名</li><li>-p 9000：9000 定义9000端口</li></ul><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>打开浏览器输入<code>http://127.0.0.1:9000</code><br>登陆后就可以通过图形界面进行<code>Docker</code>的管理<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200903084415.png"></p><h3 id="三、安装MySQL-8"><a href="#三、安装MySQL-8" class="headerlink" title="三、安装MySQL 8"></a>三、安装MySQL 8</h3><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><p><code>docker pull mysql:8.0</code></p><h4 id="运行MySQL"><a href="#运行MySQL" class="headerlink" title="运行MySQL"></a>运行MySQL</h4><p><code>docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0</code></p><blockquote><p><code>-p 3306:3306</code> ：映射容器服务的 <code>3306</code> 端口到宿主机的 <code>3306</code> 端口，外部主机可以直接通过 宿主机<code>ip:3306</code> 访问到 <code>MySQL</code> 的服务。<code>MYSQL_ROOT_PASSWORD=123456</code>：设置 <code>MySQL</code> 服务 <code>root</code> 用户的密码。</p></blockquote><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>使用数据库管理工具连接数据块即可<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904105726.png"></p><h3 id="四、安装wordpress"><a href="#四、安装wordpress" class="headerlink" title="四、安装wordpress"></a>四、安装wordpress</h3><p>我用的是阿里云的服务器，国内服务器一般搭建网站是需要备案的，一般安装完初始化时候就会提示打不开。用<code>Docker</code>搭建wordpress就不会提示因为备案问题无法打开</p><h4 id="拉取wordpress镜像"><a href="#拉取wordpress镜像" class="headerlink" title="拉取wordpress镜像"></a>拉取wordpress镜像</h4><p><code>docker pull wordpress:latest</code></p><h4 id="拉取MySQL镜像"><a href="#拉取MySQL镜像" class="headerlink" title="拉取MySQL镜像"></a>拉取<code>MySQL</code>镜像</h4><p><code>docker pull mysql:latest</code></p><h4 id="运行MySQL-1"><a href="#运行MySQL-1" class="headerlink" title="运行MySQL"></a>运行MySQL</h4><p><code>docker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</code></p><blockquote><p><code>name</code>参数指定要启动的实例名称，<code>MYSQL_ROOT_PASSWORD</code>指定<code>ROOT</code>密码。<code>tag</code>参数是<code>MySQL</code>的版本号，可以是<code>5.7</code>、<code>5.6</code>、<code>8.0</code></p></blockquote><h4 id="运行wordpress"><a href="#运行wordpress" class="headerlink" title="运行wordpress"></a>运行wordpress</h4><p><code>docker run --name some-wordpress --link some-mysql:mysql -p 8080:80 -d wordpress</code></p><blockquote><p><code>name</code>参数指定要启动的<code>WordPress</code>实例名称，<code>link</code>参数指定要使用的<code>Docker MySQL</code>实例名称，<code>p</code>参数将<code>Docker</code>内部的<code>80</code>端口映射到本地的<code>8080</code>端口上</p></blockquote><h4 id="打开设置"><a href="#打开设置" class="headerlink" title="打开设置"></a>打开设置</h4><p>浏览器输入<code>ip + 端口号</code><br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904101122.png"></p><blockquote><p>安装<code>typecho</code>大体上一样，安装<code>MySQL</code>后安装主体</p></blockquote><h3 id="五、安装netdata"><a href="#五、安装netdata" class="headerlink" title="五、安装netdata"></a>五、安装netdata</h3><h4 id="直接安装运行netdata"><a href="#直接安装运行netdata" class="headerlink" title="直接安装运行netdata"></a>直接安装运行<code>netdata</code></h4><pre><code class="docker">docker run -d --name=netdata -p 19999:19999 -v netdatalib:/var/lib/netdata -v netdatacache:/var/cache/netdata -v /etc/passwd:/host/etc/passwd:ro -v /etc/group:/host/etc/group:ro -v /proc:/host/proc:ro -v /sys:/host/sys:ro -v /etc/os-release:/host/etc/os-release:ro --restart unless-stopped --cap-add SYS_PTRACE --security-opt apparmor=unconfined netdata/netdata</code></pre><h4 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h4><p>安装完浏览器输入<code>ip + 19999</code>，就进入了<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904103554.png"></p><h3 id="六、安装nextcloud"><a href="#六、安装nextcloud" class="headerlink" title="六、安装nextcloud"></a>六、安装nextcloud</h3><h4 id="安装nextcloud"><a href="#安装nextcloud" class="headerlink" title="安装nextcloud"></a>安装<code>nextcloud</code></h4><p><code>docker run -d --name nextcloud -p 80:80 -v /root/nextcloud:/data rootlogin/nextcloud</code></p><blockquote><p>登录地址为<code>http://ip</code>，<code>80</code>端口可自行替换，如果你改成<code>800</code>，那么登录地址会变成<code>http://ip:800</code>，<code>/root/nextcloud</code>为网盘的数据库，也可以自行修改</p></blockquote><h4 id="设置安装"><a href="#设置安装" class="headerlink" title="设置安装"></a>设置安装</h4><p>打开浏览器输入<code>ip + 80</code><br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904104142.png"><br>还可以安装<code>手机客户端</code>使用</p><h3 id="七、安装code-sever"><a href="#七、安装code-sever" class="headerlink" title="七、安装code-sever"></a>七、安装<code>code-sever</code></h3><h4 id="安装code-server"><a href="#安装code-server" class="headerlink" title="安装code-server"></a>安装<code>code-server</code></h4><p><code>docker run -dit --restart=always --name vscode -h vscode -u root  -p 8086:8080 -v /data/vscode:/root -e PASSWORD=mycode -v /etc/localtime:/etc/localtime:ro codercom/code-server:v2  --auth password</code></p><blockquote><p><code>--auth password</code> 启动密码<br><code>-e PASSWORD=mycode</code> 环境变量设置密码为<code>mycode</code></p></blockquote><h4 id="设置安装-1"><a href="#设置安装-1" class="headerlink" title="设置安装"></a>设置安装</h4><p>打开浏览器输入<code>ip + 端口号</code><br>输入设置的密码就可以进入了<br><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904104630.png"></p><h3 id="八、安装aira2下载器"><a href="#八、安装aira2下载器" class="headerlink" title="八、安装aira2下载器"></a>八、安装<code>aira2下载器</code></h3><h4 id="安装aria2"><a href="#安装aria2" class="headerlink" title="安装aria2"></a>安装<code>aria2</code></h4><p>下载<code>P大</code>调试维护的<code>aria2-pro</code></p><pre><code class="docker">docker run -d \    --name aria2-pro \    --restart unless-stopped \    --log-opt max-size=1m \    --network host \    -e PUID=$UID \    -e PGID=$GID \    -e RPC_SECRET=&lt;TOKEN&gt; \    -e RPC_PORT=6800 \    -e LISTEN_PORT=6888 \    -v ~/aria2-config:/config \    -v ~/aria2-downloads:/downloads \    p3terx/aria2-pro</code></pre><h4 id="链接aria2"><a href="#链接aria2" class="headerlink" title="链接aria2"></a>链接<code>aria2</code></h4><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200904105211.png"></p><h3 id="九-安装FAST-OS-DOCKER"><a href="#九-安装FAST-OS-DOCKER" class="headerlink" title="九.安装FAST OS DOCKER"></a>九.安装FAST OS DOCKER</h3><h4 id="安装FAST-OS-DOCKER"><a href="#安装FAST-OS-DOCKER" class="headerlink" title="安装FAST OS DOCKER"></a>安装FAST OS DOCKER</h4><pre><code class="docker">docker run --restart always -p 8081:8081 -d -v /var/run/docker.sock:/var/run/docker.sock wangbinxingkong/fast</code></pre><p><img src="https://www.dockernb.com/img/screenshot/img-1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMD虚拟机安装MacOS系统</title>
      <link href="/archives/Hackintosh.html"/>
      <url>/archives/Hackintosh.html</url>
      
        <content type="html"><![CDATA[<p>因为有些东西需要用到MacOS系统，而且AMD笔记本的CPU和显卡对黑苹果无法兼容，所以只能使用虚拟机来安装MacOS，记录一下安装过程中遇到的一些坑吧</p><h2 id="首先安装VMware"><a href="#首先安装VMware" class="headerlink" title="首先安装VMware"></a>首先安装VMware</h2><p>目前测试最新版VMwar15.10不行，VMware15.1可以</p><p>刚安装的VMware是没有支持安装MacOS，需要<a href="#%E4%B8%8B%E8%BD%BD%E8%A7%A3%E9%94%81%E5%B7%A5%E5%85%B7">下载解锁工具</a>解锁后才能选择安装MacOS</p><h2 id="下载解锁工具"><a href="#下载解锁工具" class="headerlink" title="下载解锁工具"></a>下载解锁工具</h2><p><a href="https://www.lanzoux.com/i32SQfqw44b">下载地址</a></p><p><strong>已管理员身份运行<code>win-install.cmd</code></strong></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818095345.png"></p><p>到目前为止，VMware就支持安装MacOS了</p><h2 id="创建MacOS"><a href="#创建MacOS" class="headerlink" title="创建MacOS"></a>创建MacOS</h2><p>解锁完创建就可以创建MacOS系统</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818100054.png"></p><h2 id="编辑-vmx文件"><a href="#编辑-vmx文件" class="headerlink" title="编辑.vmx文件"></a>编辑<code>.vmx</code>文件</h2><p>打开MacOS虚拟机目录，用编辑打开<code>.vmx</code>文件</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818095013.png"></p><pre><code class="vmx">smc.version = &quot;0&quot;cpuid.0.eax = &quot;0000:0000:0000:0000:0000:0000:0000:1011&quot;cpuid.0.ebx = &quot;0111:0101:0110:1110:0110:0101:0100:0111&quot;cpuid.0.ecx = &quot;0110:1100:0110:0101:0111:0100:0110:1110&quot;cpuid.0.edx = &quot;0100:1001:0110:0101:0110:1110:0110:1001&quot;cpuid.1.eax = &quot;0000:0000:0000:0001:0000:0110:0111:0001&quot;cpuid.1.ebx = &quot;0000:0010:0000:0001:0000:1000:0000:0000&quot;cpuid.1.ecx = &quot;1000:0010:1001:1000:0010:0010:0000:0011&quot;cpuid.1.edx = &quot;0000:1111:1010:1011:1111:1011:1111:1111&quot;featureCompat.enable = &quot;FALSE&quot;</code></pre><p><strong>一定要在这两行中插入代码</strong></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818100455.png"></p><h2 id="启动安装"><a href="#启动安装" class="headerlink" title="启动安装"></a>启动安装</h2><p><img src="http://p.ananas.chaoxing.com/star3/origin/90cfd4b8e52aae51e3ccc98a56c044ad.png"></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="1-没有网络"><a href="#1-没有网络" class="headerlink" title="1.没有网络"></a>1.没有网络</h3><p>把网络设为<code>桥接模式</code></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200818100916.png"></p><h3 id="2-报错”这个虚拟机需要avx2，但是没有avx”"><a href="#2-报错”这个虚拟机需要avx2，但是没有avx”" class="headerlink" title="2.报错”这个虚拟机需要avx2，但是没有avx”"></a>2.报错”这个虚拟机需要avx2，但是没有avx”</h3><p>将vmx文件中 <strong>virtualHW.version = “16”**改为 **virtualHW.version = “10”</strong></p><h3 id="3-无法使用鼠标键盘"><a href="#3-无法使用鼠标键盘" class="headerlink" title="3.无法使用鼠标键盘"></a>3.无法使用鼠标键盘</h3><p>1、关闭虚拟机。</p><p>2、找到 vmx文件，在其中添加：</p><p><strong>keyboard.vusb.enable = “TRUE”</strong></p><p><strong>mouse.vusb.enable = “TRUE”</strong></p><p>3、把虚拟机设置，选择“硬件”的“USB控制器”，</p><p>   在左侧的界面里勾选“显示所有USB输入设备（S）”，并把顶部的“USB兼容性（C）”改为USB2.0。</p><p>4、重启虚拟机。</p><h3 id="4-虚拟机进入BIOS"><a href="#4-虚拟机进入BIOS" class="headerlink" title="4.虚拟机进入BIOS"></a>4.虚拟机进入BIOS</h3><pre><code>1.常规方法：开启虚拟机，按F2键，注意要将鼠标点进虚拟机环境中2.特殊情况,按F2键无反应：进入虚拟机目录，找到vmx文件，在文件最前端加入一行：bios.forceSetupOnce = &quot;TRUE&quot;保存后开启虚拟机直接进入bios该方法只生效一次下次如需进入bios需重新编辑vmx文件3.延长bios等待时间：在vmx文件前端加入：bios.bootDelay = &quot;6000&quot;注意保存。6000=6秒，可自行设置。如果进入bios后无法引导进入光盘镜像，例如 .cdr 镜像文件，或许是 cdr文件本身经过修改，可更换为其他镜像。</code></pre>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hackintosh </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性表</title>
      <link href="/archives/data.html"/>
      <url>/archives/data.html</url>
      
        <content type="html"><![CDATA[<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><ol><li>首先定义一个单链表结构题</li></ol><pre><code class="C++">typedef struct LNode&#123;  ElemType data;//定义一个自定义类型的变量存放数据  LNode *Next;//定义一个指向结构体的指针&#125;LNode,*Linklist;//创建一个结构体指针</code></pre><p>*<em>LNode <em>p ==Linklist p</em></em></p><ol start="2"><li>链表的初始化</li></ol><pre><code class="C++">void init(Linklist &amp;L)&#123;    L=new LNode;//为L动态分配一块内存空间    L-&gt;Next=NULL;//将L的指针域设为空&#125;</code></pre><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200812155623.png"></p><ol start="3"><li><p>创建链表</p><p>图中是用尾插法构建单链表，头插法还请移步<a href="#%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95">头插法</a></p><pre><code class="C++">void created(Linklist &amp;L)&#123;    Linklist p=L;//新创建一个p指针指向头节点L    for(int i=0;i&lt;20;i++)//循环创建20个节点的单链表    &#123;        Linklist q=new LNode;//创建一个新的节点，并用q指针指向这个新的节点        q-&gt;data=i;//将i的值存入q的data域        q-&gt;Next=NULL;//将q的Next指针指向为空        p-&gt;Next=q;//将q/L的尾指针指向新创建的q这个结构体        p=q;//再将p指向位置移动到q（p指针后移）    &#125;&#125;</code></pre><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200812161052.png"></p></li><li><p>分别定义两个指针，一个快指针(high)一个慢指针(low)，查找一个有序链表的中间值</p><pre><code class="C++">int findmid(Linklist &amp;L)&#123;    Linklist high,low=L;    while(high-&gt;Next != NULL)    &#123;        if(high-&gt;Next-&gt;Next != NULL)        &#123;            high = high-&gt;Next-&gt;Next;//high每次后移两步            low = low-&gt;low;//low指针每次后移一步        &#125;     else        &#123;            high=high-&gt;Next;        &#125;    &#125;    return low-&gt;data;&#125;</code></pre><p><code>high</code>指针每次向后移动两步，<code>low</code>指针每次向后移动一步，这样当<code>high</code>指针移动到链表最后面时，恰巧<code>low</code>应该在链表中间位置。 </p><h4 id="头插法和尾插法"><a href="#头插法和尾插法" class="headerlink" title="头插法和尾插法"></a>头插法和尾插法</h4></li></ol><p>如果将数据结构的存储方式换为头插法，只需要将<code>created()</code>函数换为：</p><pre><code class="C++">void creat(Linklist &amp;L)&#123;    Linklist p=L;    Linklist q=new LNode;    q-&gt;data=0;    q-&gt;Next=NULL;    p-&gt;Next=q;    for (int i = 1; i &lt; 20; i++)    &#123;        /* code */        Linklist q=new LNode;        q-&gt;data=i;        q-&gt;Next=p-&gt;Next;        p-&gt;Next=q;    &#125;&#125;</code></pre><p><strong>头插法</strong>创建一个节点长度为20的有序单链表输出出来的循序则为逆序</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200812223221.png"></p><p>而<strong>尾插法</strong>创建一个节点长度为20的有序单链表输出出来的循序是正序：</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200812223459.png"></p><h3 id="链表节点的增、删"><a href="#链表节点的增、删" class="headerlink" title="链表节点的增、删"></a>链表节点的增、删</h3><p>创建一个增加节点的函数<code>push()</code></p><pre><code class="C++">void push(Linklist &amp;L)&#123;    int n,m;    Linklist p=L;    cout &lt;&lt; &quot;在第几个节点后面增加：&quot; &lt;&lt; &quot;\n&quot;;    cin &gt;&gt; n;    /*先将指针移动到插入节点*/    for (int i = 0; i &lt; n; i++)    &#123;        /* code */        p=p-&gt;Next;    &#125;    Linklist q=new LNode;    cout &lt;&lt; &quot;输入数值：&quot; &lt;&lt; &quot;\n&quot;;    cin &gt;&gt; m;    q-&gt;data=m;    q-&gt;Next=p-&gt;Next;    p-&gt;Next=q;&#125;</code></pre><p>创建一个删除节点的函数<code>deleted()</code></p><pre><code class="C++">void deleted(Linklist &amp;L)&#123;    int n;    Linklist p,q;    p=L;    cout &lt;&lt; &quot;在第几个节点后面删除：&quot; &lt;&lt; &quot;\n&quot;;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    &#123;        /* code */        p=p-&gt;Next;    &#125;    q=p-&gt;Next;    p-&gt;Next=q-&gt;Next;&#125;</code></pre><p>执行了增加节点的函数<code>push()</code>后输出有序链表结果如下图：</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200813092600.png"></p><p>执行删除节点函数<code>deleted()</code>后的输出结果如下图：</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200813092901.png"></p><p>对比发现增加了一个数值为100的节点，删除了一个数值为4的节点。</p><h3 id="创建一个有序链表并快速查找中间值的完整代码："><a href="#创建一个有序链表并快速查找中间值的完整代码：" class="headerlink" title="创建一个有序链表并快速查找中间值的完整代码："></a><strong>创建一个有序链表并快速查找中间值的完整代码：</strong></h3><pre><code class="C++">#include &quot;iostream&quot;#include &lt;stdlib.h&gt;using namespace std;#define OK 1#define ERROR 0typedef int Status;typedef int ElemType; typedef struct LNode&#123;    ElemType data;    LNode *next;&#125;LNode,*LinkList;Status init(LinkList &amp;L)    //初始化&#123;    L=new LNode;    L-&gt;next=NULL;    return OK;&#125;void creat(LinkList &amp;L)    //尾插法建立链表&#123;    LinkList p,q=L;    for(int i=0;i&lt;20;i++)    &#123;        p=new LNode;        p-&gt;data=i+1;        p-&gt;next=NULL;        q-&gt;next=p;        q=p;    &#125;&#125;void show(LinkList L)        //显示链表&#123;    LinkList p=L-&gt;next;    while(p)    &#123;        cout&lt;&lt;p-&gt;data&lt;&lt;&quot;\t&quot;;         p=p-&gt;next;    &#125;    cout&lt;&lt;endl;&#125;Status findmid(LinkList L)    //查找中间值&#123;    LinkList high,mid;    ElemType e;    high=mid=L;    while(high-&gt;next!=NULL)    &#123;        if(high-&gt;next-&gt;next!=NULL)        &#123;            high=high-&gt;next-&gt;next;            mid=mid-&gt;next;        &#125;        else        &#123;            high=high-&gt;next;        &#125;    &#125;    e=mid-&gt;data;    return e;&#125;int main()&#123;        LinkList L;    init(L);    creat(L);    cout&lt;&lt;&quot;显示链表：&quot;&lt;&lt;endl;    show(L);    cout&lt;&lt;&quot;显示中间值：&quot;&lt;&lt;endl;    cout&lt;&lt;findmid(L)&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p><strong>首先声明这里说的指针只是为了方便称呼，不是在C/C++中的指针</strong></p><ol><li><p>定义一个队列(线性表的顺序结构)</p><pre><code class="C++">typedef struct&#123;    int ID[10];//每个节点的编号    int front;//头指针    int rear;//尾指针&#125;Sql;</code></pre></li></ol><ol start="2"><li><p>队列初始化</p><pre><code class="C++">void init(Sql *data)&#123;    data-&gt;front=data-&gt;rear=0;    for (; data-&gt;rear &lt; 10; ++data-&gt;rear)//尾指针后移    &#123;        /* code */        data-&gt;ID[data-&gt;rear]=0;    &#125;    //此时头指针在头位，尾指针在尾位&#125;对队列赋值</code></pre></li></ol><ol start="3"><li><p>给列表赋值</p><pre><code class="C++">void creat(Sql *data)&#123;    int i=1;    while(data-&gt;front!=data-&gt;rear)//当头指针后移到尾指针时候循环结束    &#123;        data-&gt;ID[data-&gt;front]=i;        data-&gt;front++;        i++;    &#125;    data-&gt;front=0;//把头指针回归到首位&#125;</code></pre></li></ol><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200814131754.png"></p><ol start="4"><li><p>遍历列表输出整个顺序表</p><pre><code class="C++">void print(Sql *data)&#123;    while(data-&gt;front!=data-&gt;rear)    &#123;        cout &lt;&lt; data-&gt;ID[data-&gt;front] &lt;&lt; &quot;\n&quot;;        data-&gt;front++;//头指针后移直至结束    &#125;    data-&gt;front=0;//头指针回归到原位&#125;</code></pre></li></ol><h3 id="输出一个顺序表"><a href="#输出一个顺序表" class="headerlink" title="输出一个顺序表"></a><strong>输出一个顺序表</strong></h3><pre><code class="C++">#include &quot;iostream&quot;using namespace std;typedef struct&#123;    int ID[10];//每个节点的编号    int front;//头指针    int rear;//尾指针&#125;Sql;void init(Sql *data)&#123;    data-&gt;front=data-&gt;rear=0;    for (; data-&gt;rear &lt; 10; ++data-&gt;rear)    &#123;        /* code */        data-&gt;ID[data-&gt;rear]=0;    &#125;&#125;void creat(Sql *data)&#123;    int i=1;    while(data-&gt;front!=data-&gt;rear)    &#123;        data-&gt;ID[data-&gt;front]=i;        data-&gt;front++;        i++;    &#125;    data-&gt;front=0;&#125;void print(Sql *data)&#123;    while(data-&gt;front!=data-&gt;rear)    &#123;        cout &lt;&lt; data-&gt;ID[data-&gt;front] &lt;&lt; &quot;\n&quot;;        data-&gt;front++;    &#125;    data-&gt;front=0;&#125;int main()&#123;    /* code */    Sql data;    init(&amp;data);    creat(&amp;data);    print(&amp;data);    return 0;&#125;</code></pre><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200814133143.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用正则表达式</title>
      <link href="/archives/re.html"/>
      <url>/archives/re.html</url>
      
        <content type="html"><![CDATA[<p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。</p><p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p><p>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫<a href="https://deerchao.net/tutorials/regex/regex.htm">《正则表达式30分钟入门教程》</a>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p><h2 id="正则表达式相关知识"><a href="#正则表达式相关知识" class="headerlink" title="正则表达式相关知识"></a>正则表达式相关知识</h2><table><thead><tr><th>符号</th><th>解释</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符</td><td>b.t</td><td>可以匹配bat / but / b#t / b1t等</td></tr><tr><td>\w</td><td>匹配字母/数字/下划线</td><td>b\wt</td><td>可以匹配bat / b1t / b_t等 但不能匹配b#t</td></tr><tr><td>\s</td><td>匹配空白字符（包括\r、\n、\t等）</td><td>love\syou</td><td>可以匹配love you</td></tr><tr><td>\d</td><td>匹配数字</td><td>\d\d</td><td>可以匹配01 / 23 / 99等</td></tr><tr><td>\b</td><td>匹配单词的边界</td><td>\bThe\b</td><td></td></tr><tr><td>^</td><td>匹配字符串的开始</td><td>^The</td><td>可以匹配The开头的字符串</td></tr><tr><td>$</td><td>匹配字符串的结束</td><td>.exe$</td><td>可以匹配.exe结尾的字符串</td></tr><tr><td>\W</td><td>匹配非字母/数字/下划线</td><td>b\Wt</td><td>可以匹配b#t / b@t等 但不能匹配but / b1t / b_t等</td></tr><tr><td>\S</td><td>匹配非空白字符</td><td>love\Syou</td><td>可以匹配love#you等 但不能匹配love you</td></tr><tr><td>\D</td><td>匹配非数字</td><td>\d\D</td><td>可以匹配9a / 3# / 0F等</td></tr><tr><td>\B</td><td>匹配非单词边界</td><td>\Bio\B</td><td></td></tr><tr><td>[]</td><td>匹配来自字符集的任意单一字符</td><td>[aeiou]</td><td>可以匹配任一元音字母字符</td></tr><tr><td>[^]</td><td>匹配不在字符集中的任意单一字符</td><td>[^aeiou]</td><td>可以匹配任一非元音字母字符</td></tr><tr><td>*</td><td>匹配0次或多次</td><td>\w*</td><td></td></tr><tr><td>+</td><td>匹配1次或多次</td><td>\w+</td><td></td></tr><tr><td>?</td><td>匹配0次或1次</td><td>\w?</td><td></td></tr><tr><td>{N}</td><td>匹配N次</td><td>\w{3}</td><td></td></tr><tr><td>{M,}</td><td>匹配至少M次</td><td>\w{3,}</td><td></td></tr><tr><td>{M,N}</td><td>匹配至少M次至多N次</td><td>\w{3,6}</td><td></td></tr><tr><td>|</td><td>分支</td><td>foo|bar</td><td>可以匹配foo或者bar</td></tr><tr><td>(?#)</td><td>注释</td><td></td><td></td></tr><tr><td>(exp)</td><td>匹配exp并捕获到自动命名的组中</td><td></td><td></td></tr><tr><td>(?<name>exp)</td><td>匹配exp并捕获到名为name的组中</td><td></td><td></td></tr><tr><td>(?:exp)</td><td>匹配exp但是不捕获匹配的文本</td><td></td><td></td></tr><tr><td>(?=exp)</td><td>匹配exp前面的位置</td><td>\b\w+(?=ing)</td><td>可以匹配I’m dancing中的danc</td></tr><tr><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td><td>(?&lt;=\bdanc)\w+\b</td><td>可以匹配I love dancing and reading中的第一个ing</td></tr><tr><td>(?!exp)</td><td>匹配后面不是exp的位置</td><td></td><td></td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td><td></td><td></td></tr><tr><td>*?</td><td>重复任意次，但尽可能少重复</td><td>a.<em>b a.</em>?b</td><td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td></tr><tr><td>+?</td><td>重复1次或多次，但尽可能少重复</td><td></td><td></td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,N}?</td><td>重复M到N次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,}?</td><td>重复M次以上，但尽可能少重复</td><td></td><td></td></tr></tbody></table><blockquote><p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成(和)，否则圆括号被视为正则表达式中的分组。</p></blockquote><h2 id="Python对正则表达式的支持"><a href="#Python对正则表达式的支持" class="headerlink" title="Python对正则表达式的支持"></a>Python对正则表达式的支持</h2><p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>compile(pattern, flags=0)</td><td>编译正则表达式返回正则表达式对象</td></tr><tr><td>match(pattern, string, flags=0)</td><td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td></tr><tr><td>search(pattern, string, flags=0)</td><td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td></tr><tr><td>split(pattern, string, maxsplit=0, flags=0)</td><td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td></tr><tr><td>sub(pattern, repl, string, count=0, flags=0)</td><td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td></tr><tr><td>fullmatch(pattern, string, flags=0)</td><td>match函数的完全匹配（从字符串开头到结尾）版本</td></tr><tr><td>findall(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td></tr><tr><td>finditer(pattern, string, flags=0)</td><td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td></tr><tr><td>purge()</td><td>清除隐式编译的正则表达式的缓存</td></tr><tr><td>re.I / re.IGNORECASE</td><td>忽略大小写匹配标记</td></tr><tr><td>re.M / re.MULTILINE</td><td>多行匹配标记</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="例子1：从一段文字中提取出国内手机号码。"><a href="#例子1：从一段文字中提取出国内手机号码。" class="headerlink" title="例子1：从一段文字中提取出国内手机号码。"></a>例子1：从一段文字中提取出国内手机号码。</h3><p>下面这张图是截止到2017年底，国内三家运营商推出的手机号段。</p><pre><code class="Python">import redef main():    # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字    pattern = re.compile(r&#39;(?&lt;=\D)1[34578]\d&#123;9&#125;(?=\D)&#39;)    sentence = &#39;&#39;&#39;    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，    不是15600998765，也是110或119，王大锤的手机号才是15600998765。    &#39;&#39;&#39;    # 查找所有匹配并保存到一个列表中 （一）    mylist = re.findall(pattern, sentence)    print(mylist)    print(&#39;--------华丽的分隔线--------&#39;)    # 通过迭代器取出匹配对象并获得匹配的内容 （二）    for temp in pattern.finditer(sentence):        print(temp.group())    print(&#39;--------华丽的分隔线--------&#39;)    # 通过search函数指定搜索位置找出所有匹配 （三）    m = pattern.search(sentence)    while m:        print(m.group())        m = pattern.search(sentence, m.end())if __name__ == &#39;__main__&#39;:    main()</code></pre><blockquote><p>说明： 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：(?&lt;=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p></blockquote><ul><li>注释部分</li><li><strong>注释（一）：</strong> <code>findall(pattern, string, flags=0)</code>    查找字符串所有与正则表达式匹配的模式 返回<code>字符串的列表</code>，即<strong>在string中查询所有匹配模式为pattern的字符串，并将所有字符串添加到一个列表并返回</strong></li><li><strong>注释（二）：</strong> <code>finditer(pattern, string, flags=0)</code>查找字符串所有与正则表达式匹配的模式 返回一个<code>迭代器</code>，即<strong>在string中查找匹配模式为pattern的字符串，并将所有字符串添加到一个迭代器列表</strong><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></li><li><strong>注释（三）</strong> <code>m = pattern.search(sentence, m.end())</code>搜索字符串中第一次出现正则表达式的模式 成功返回<code>匹配对象</code> 否则返回<code>None</code>,用<code>m.end()</code>表示<code>m</code>的结束位置，作为下一次查找的起始位置，防止查找重复的问题<h3 id="例子2：验证输入用户名和QQ号是否有效并给出对应的提示信息。"><a href="#例子2：验证输入用户名和QQ号是否有效并给出对应的提示信息。" class="headerlink" title="例子2：验证输入用户名和QQ号是否有效并给出对应的提示信息。"></a>例子2：验证输入用户名和QQ号是否有效并给出对应的提示信息。</h3><pre><code class="Python">&quot;&quot;&quot;验证输入用户名和QQ号是否有效并给出对应的提示信息</code></pre></li></ul><p>要求：用户名必须由字母、数字或下划线构成且长度在6<del>20个字符之间，QQ号是5</del>12的数字且首位不能为0<br>“””<br>import re</p><p>def main():<br>    username = input(‘请输入用户名: ‘)<br>    qq = input(‘请输入QQ号: ‘)<br>    # match函数的第一个参数是正则表达式字符串或正则表达式对象<br>    # 第二个参数是要跟正则表达式做匹配的字符串对象<br>    m1 = re.match(r’^[0-9a-zA-Z_]{6,20}$’, username) #注释（一）<br>    if not m1:<br>        print(‘请输入有效的用户名.’)<br>    m2 = re.match(r’^[1-9]\d{4,11}$’, qq)<br>    if not m2:<br>        print(‘请输入有效的QQ号.’)<br>    if m1 and m2:<br>        print(‘你输入的信息是有效的!’)</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p><pre><code>&gt; 提示： 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。- **注释（一）：** `print(m1)` -&gt; `&lt;_sre.SRE_Match object; span=(0, 10), match=&#39;koyangyang&#39;&gt;` `print(type(m1))` -&gt; `&lt;class &#39;_sre.SRE_Match&#39;&gt;`### 例子3：替换字符串中的不良内容```Pythonimport redef main():    sentence = &#39;你丫是傻叉吗? 我操你大爷的. Fuck you.&#39;    purified = re.sub(&#39;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔&#39;,&#39;*&#39;, sentence, flags=re.IGNORECASE) #注释（一）    print(purified)  # 你丫是*吗? 我*你大爷的. * you.if __name__ == &#39;__main__&#39;:    main()</code></pre><blockquote><p>说明： re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用按位或运算符进行叠加，如flags=re.I | re.M。</p></blockquote><ul><li><strong>注释（一）：</strong> <code>sub(pattern, repl, string, count=0, flags=0)</code>    用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数，具体还请看<a href="#sub%E5%87%BD%E6%95%B0">sub函数</a><h3 id="例子4：拆分长字符串"><a href="#例子4：拆分长字符串" class="headerlink" title="例子4：拆分长字符串"></a>例子4：拆分长字符串</h3><pre><code class="Python">import re</code></pre></li></ul><p>def main():<br>    poem = ‘窗前明月光，疑是地上霜。举头望明月，低头思故乡。’<br>    sentence_list = re.split(r’[，。, .]’, poem) #注释（一）<br>    while ‘’ in sentence_list:<br>        sentence_list.remove(‘’)<br>    print(sentence_list)  # [‘窗前明月光’, ‘疑是地上霜’, ‘举头望明月’, ‘低头思故乡’]</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    main()</p><pre><code>- **注释（一）：** `split(pattern, string, maxsplit=0, flags=0)`    用正则表达式指定的模式分隔符拆分字符串 返回`列表`&lt;br&gt;最开始的`sentence_list`&gt; [&#39;窗前明月光&#39;, &#39;疑是地上霜&#39;, &#39;举头望明月&#39;, &#39;低头思故乡&#39;, &#39;&#39;]经过```Pythonwhile &#39;&#39; in sentence_list:        sentence_list.remove(&#39;&#39;)</code></pre><blockquote><p>[‘窗前明月光’, ‘疑是地上霜’, ‘举头望明月’, ‘低头思故乡’]<br><strong>所以经过<code>split()</code>函数后返回的列表中除了切割部分还包含一个<code>&#39;&#39;</code>空字符串</strong></p></blockquote><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ol><li>迭代器是一个可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li><li>迭代器有两个基本的方法：<code>iter()</code> 和 <code>next()</code>。</li><li>字符串，列表或元组对象都可用于创建<a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>：</li></ol><p><strong>例如：</strong></p><pre><code class="python">datas = [1,2,3,4,5,6,7,8,9,0]data = iter(datas)for x in data:    print(x)</code></pre><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200807232743.png"><br>了解更多请移步：<a href="https://www.runoob.com/python3/python3-iterator-generator.html">传送门</a></p><h3 id="sub函数"><a href="#sub函数" class="headerlink" title="sub函数"></a>sub函数</h3><p>在Python中，re模块用来实现正则表达式功能。<br><code>sub(pattern, repl, string, count=0, flags=0)</code>具体参数如下：</p><ol><li>pattern： 是re.compile()方法生成Pattern类型，也就是索要匹配的模式。</li><li>repl ： 可以是一段字符串，或者是一个方法</li><li>string： 需要被匹配和替换的原字符串</li><li>count： 指的是最大的可以被替换的匹配到的字符串的个数，默认为0，就是所有匹配到的字符串。</li><li>flags ： 标志位</li></ol><p><strong>其中repl比较特殊：</strong></p><ul><li>当repl为字符串的时候，也就是需要 将string中与pattern匹配的字符串都替换成repl</li><li>当repl为方法的时候，就必须是一个带有一个参数，且参数为MatchObject类型的方法，该方法需要返回一个字符串。</li></ul><p><strong>比如：</strong></p><pre><code class="Python"> __author__ = &#39;zhoujinyu&#39;import fileinput,refield_pat = re.compile(r&#39;\[(.+?)\]&#39;)scope = &#123;&#125;def replacement(match):    code = match.group(1)    try:        return str(eval(code,scope))    except SyntaxError:        exec code in scope        return &#39;&#39;lines = []for line in fileinput.input():    lines.append(line)text=&#39;&#39;.join(lines)print field_pat.sub(replacement,text)</code></pre><blockquote><p>该例子的最后一句 print field_pat.sub(replacement,text)<br>中的replacement就是replacement(match)函数，其中match就是一个MatchObject对象。<br>由于sub()方法是一个循环方法，也就是会逐个找出text（string）中与field_pat（pattern）中匹配的字符串并将其替换成replacement（repl）返回的字符串。<br>所以每次进行匹配查找的时候都会运行一次replacement(match)函数，而每次运行这个函数的时候，match.group(1)这个方法会找到和field_pat（pattern）中第一个括号匹配的字符，由于sub方法是循环不重复进行的（下一次会从上一次匹配到的字符串之后开始匹配），所以在第二次匹配过程中<br>并不会重复上次一匹配到的字符串，会自动找到下一个可以匹配到的字符串。<br>经过多次循环，最终会找到所有匹配的字符串进行替换。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于一般的爬虫工作者来说，掌握正则表达式可以帮助我们更快的通过指定的匹配模式来查找提取文字中想要的、有用的信息。<code>Beautiful Soup</code>或<code>Lxml</code>来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦。而且再有的地方还是需要用到正则表达式，除了爬虫还有<code>Django</code>中的<code>path</code>函数匹配规则。</p>]]></content>
      
      
      <categories>
          
          <category> Wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫小练习</title>
      <link href="/archives/pachongtest.html"/>
      <url>/archives/pachongtest.html</url>
      
        <content type="html"><![CDATA[<p>通过爬取下载<strong>斗图啦</strong><a href="https://www.doutula.com/photo/list?page=0">https://www.doutula.com/photo/list?page=0</a>中的表情包，来练习爬虫</p><h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>声明一个变量来引用<code>requests</code>的对象</p><pre><code class="python">response = requests.get(url, headers...)</code></pre><p>此时输出<code>response</code>是一个html文档</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//static.doutula.com/css/bootstrap.css?id=ecc6bb0e2e008ee4306a&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//static.doutula.com/css/main.css?id=583df7ef1aba1be8ec1b&quot;&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;meta http-equiv=&quot;content-language&quot; content=&quot;zh-CN&quot;&gt;        &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;        &lt;meta name=&quot;force-rendering&quot; content=&quot;webkit&quot;&gt;        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt;        &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://www.doutula.com/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;        &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;        &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;斗图啦&quot;&gt;        &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;        &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;&gt;        &lt;meta name=&quot;keywords&quot; content=&quot;斗图,斗图啦,斗图网,斗图大会,表情三巨头,蘑菇头,小学生,撕逼图片,搞笑斗图,熊猫表情,微信滑稽表情,猥琐表情,斗图大会开始了,斗图图片,斗图大赛,金馆长斗图表情,金馆长表情,金馆长斗图吧,金馆长qq表情包&quot;/&gt;        &lt;meta name=&quot;description&quot; content=&quot;斗图啦，收集了成千上万的撕逼斗图表情包，在这里你可以快速找到想要的表情，通过在线表情制作可以快速生成自定义表情。&quot;/&gt;        &lt;title&gt;最新斗图表情 - 斗图表情包 - 金馆长表情库 - 真正的斗图网站 - doutula.com&lt;/title&gt;        &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform&quot; /&gt;        &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;        &lt;style&gt;        @media  screen and (max-width: 768px)        &#123;            .center-wrap.col-sm-9 &#123;                padding: 0;            &#125;            .center-wrap.col-xs-12 &#123;                padding: 0;            &#125;        &#125;        &lt;/style&gt;&lt;script&gt;var _hmt = _hmt || [];(function() &#123;  var hm = document.createElement(&quot;script&quot;);  hm.src = &quot;https://hm.baidu.com/hm.js?2fc12699c699441729d4b335ce117f40&quot;;  var s = document.getElementsByTagName(&quot;script&quot;)[0];  s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;//cpro.baidustatic.com/cpro/ui/cm.js&quot; async=&quot;async&quot; defer=&quot;defer&quot; &gt;&lt;/script&gt;        &lt;script src=&quot;//dup.baidustatic.com/js/ds.js&quot; async=&quot;async&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;    &lt;!--&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;--&gt;    &lt;script&gt;        (adsbygoogle = window.adsbygoogle || []).push(&#123;            google_ad_client: &quot;ca-pub-8376044552838383&quot;,            enable_page_level_ads: true        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h3><p>通过<code>BeautifulSoup</code>是用来从<code>HTML</code>或<code>XML</code>中提取数据的<code>Python</code>库</p><pre><code class="python">result = BeautifulSoup(response, &quot;html.parser)</code></pre><p>此时<code>result</code>这个变量就是一个经过转换的<code>soup</code>对象<br>分别输出<code>response</code>和<code>result</code>的数据类型</p><pre><code>&lt;class &#39;str&#39;&gt;&lt;class &#39;bs4.BeautifulSoup&#39;&gt;</code></pre><h3 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h3><p>创建一个变量<code>data</code>用了存放从<code>result</code>中提取出来的信息</p><pre><code>[&lt;img alt=&quot;等他说完在电他&quot; class=&quot;img-responsive lazy image_dta&quot; data-backup=&quot;http://img.doutula.com/production/uploads/image/2020/07/31/20200731175866_BnSbGs.png&quot; data-original=&quot;http://img.doutula.com/production/uploads/image/2020/07/31/20200731175866_BnSbGs.png&quot; referrerpolicy=&quot;no-referrer&quot; src=&quot;//static.doutula.com/img/loader.gif?33&quot;/&gt;,..., &lt;img alt=&quot;那耶@好吃到飞起&quot; class=&quot;img-responsive lazy image_dta&quot; data-backup=&quot;http://img.doutula.com/production/uploads/image/2020/07/30/20200730078726_eJqKRZ.jpg&quot; data-original=&quot;http://img.doutula.com/production/uploads/image/2020/07/30/20200730078726_eJqKRZ.jpg&quot; referrerpolicy=&quot;no-referrer&quot; src=&quot;//static.doutula.com/img/loader.gif?33&quot;/&gt;]</code></pre><p>是一个包含多个<code>img</code>标签的列表，列表是一个<code>python</code>数据结构</p><h3 id="筛选数据"><a href="#筛选数据" class="headerlink" title="筛选数据"></a>筛选数据</h3><p>遍历<code>data</code>这个<code>list</code>，分别用<code>img_name</code>、<code>img_url</code>去引用<code>data</code>中的属性<code>alt</code>和<code>data-backup</code></p><pre><code class="python">for imgs in data:    img_name = imgs[&#39;alt&#39;]    img_url = imgs[&#39;data-backup&#39;]    img = requests.get(img_url)    print(&quot;正在下载&quot; + &quot;  &quot; + img_name + &quot;  &quot; + img_url)    try:        f = open(&quot;C://Users/Koyang/Desktop/表情包/%s.png&quot; % img_name, &#39;wb&#39;)        f.write(img.content)    except Exception as result:        print(result)</code></pre><p>到目前为止就已经完成了对斗图啦的表情包的爬取和批量下载</p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200731153043.png"></p><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200731153001.png"></p><h3 id="附上完整的代码"><a href="#附上完整的代码" class="headerlink" title="附上完整的代码"></a><strong>附上完整的代码</strong></h3><pre><code class="python"># --*-- coding : utf-8 --*--# @Author : Koyang import requestsfrom bs4 import BeautifulSoupclass Doutu:    def __init__(self):        self.url = &quot;https://www.doutula.com/photo/list?page=0&quot;        self.headers = &#123;            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36&quot;&#125;    def get_html(self):        response = requests.get(self.url, headers=self.headers).text        result = BeautifulSoup(response, &quot;html.parser&quot;)        data = result.find_all(attrs=&#123;&quot;alt&quot;: True&#125;)        # 对数据进行筛选和下载        for imgs in data:            img_name = imgs[&#39;alt&#39;]            img_url = imgs[&#39;data-backup&#39;]            img = requests.get(img_url)            print(&quot;正在下载&quot; + &quot;  &quot; + img_name + &quot;  &quot; + img_url)            try:                f = open(&quot;C://Users/Koyang/Desktop/表情包/%s.png&quot; % img_name, &#39;wb&#39;)                f.write(img.content)            except Exception as result:                print(result)if __name__ == &quot;__main__&quot;:    test = Doutu()    test.get_html()</code></pre><h2 id="附页"><a href="#附页" class="headerlink" title="附页"></a>附页</h2><h3 id="Beautiful解析器的区别"><a href="#Beautiful解析器的区别" class="headerlink" title="Beautiful解析器的区别"></a>Beautiful解析器的区别</h3><table><thead><tr><th>解析器</th><th>使用方法</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Python标准库</td><td>BeautifulSoup(markup, “html.parser”)</td><td>Python的内置标准库执行速度适中文档容错能力强</td><td>Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差</td></tr><tr><td>lxml HTML 解析器</td><td>BeautifulSoup(markup, “lxml”)</td><td>速度快文档容错能力强</td><td>需要安装C语言库</td></tr><tr><td>lxml XML 解析器</td><td>BeautifulSoup(markup, [“lxml”, “xml”])BeautifulSoup(markup, “xml”)</td><td>速度快唯一支持XML的解析器</td><td>需要安装C语言库</td></tr><tr><td>html5lib</td><td>BeautifulSoup(markup, “html5lib”)</td><td>最好的容错性以浏览器的方式解析文档生成HTML5格式的文档</td><td>速度慢不依赖外部扩展</td></tr></tbody></table><h3 id="BeautifulSoup函数讲解"><a href="#BeautifulSoup函数讲解" class="headerlink" title="BeautifulSoup函数讲解"></a>BeautifulSoup函数讲解</h3><h4 id="（1）find-all-name-attrs-recursive-text-kwargs"><a href="#（1）find-all-name-attrs-recursive-text-kwargs" class="headerlink" title="（1）find_all( name , attrs , recursive , text , **kwargs )"></a>（1）find_all( name , attrs , recursive , text , **kwargs )</h4><p><code>find_all()</code> 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件</p><p><strong>1）name 参数</strong></p><p><code>name</code> 参数可以查找所有名字为 <code>name</code> 的tag,字符串对象会被自动忽略掉</p><p><strong>A.传字符串</strong></p><p>最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的<b>标签</p><table><thead><tr><th>12</th><th>soup.find_all(‘b’)# [<b>The Dormouse’s story</b>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>12</th><th>print soup.find_all(‘a’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>, <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>, <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>B.传正则表达式</strong></p><p>如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 <code>match()</code> 来匹配内容.下面例子中找出所有以b开头的标签,这表示<body>和<b>标签都应该被找到</p><table><thead><tr><th>12345</th><th>import refor tag in soup.find_all(re.compile(“^b”)):  print(tag.name)# body# b</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>C.传列表</strong></p><p>如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有<a>标签和<b>标签</p><table><thead><tr><th>12345</th><th>soup.find_all([“a”, “b”])# [<b>The Dormouse’s story</b>,# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,# <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>D.传 True</strong></p><p><code>True</code> 可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点</p><table><thead><tr><th>1234567891011</th><th>for tag in soup.find_all(True):  print(tag.name)# html# head# title# body# p# b# p# a# a</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>E.传方法</strong></p><p>如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 [<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id85">4]</a> ,如果这个方法返回 <code>True</code> 表示当前元素匹配并且被找到,如果不是则反回 <code>False</code></p><p>下面方法校验了当前元素,如果包含 <code>class</code> 属性却不包含 <code>id</code> 属性,那么将返回 <code>True</code>:</p><table><thead><tr><th>12</th><th>def has_class_but_no_id(tag):  return tag.has_attr(‘class’) and not tag.has_attr(‘id’)</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>将这个方法作为参数传入 <code>find_all()</code> 方法,将得到所有<p>标签:</p><table><thead><tr><th>1234</th><th>soup.find_all(has_class_but_no_id)# [<p class="title"><b>The Dormouse’s story</b></p>,# <p class="story">Once upon a time there were…</p>,# <p class="story">…</p>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>2）keyword 参数</strong></p><blockquote><p><strong>注意：如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 <code>id</code> 的参数,Beautiful Soup会搜索每个tag的”id”属性</strong></p></blockquote><table><thead><tr><th>12</th><th>soup.find_all(id=’link2’)# [<a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>如果传入 <code>href</code> 参数,Beautiful Soup会搜索每个tag的”href”属性</p><table><thead><tr><th>12</th><th>soup.find_all(href=re.compile(“elsie”))# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>使用多个指定名字的参数可以同时过滤tag的多个属性</p><table><thead><tr><th>12</th><th>soup.find_all(href=re.compile(“elsie”), id=’link1’)# [<a class="sister" href="http://example.com/elsie" id="link1">three</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>在这里我们想用 class 过滤，不过 class 是 python 的关键词，这怎么办？加个下划线就可以</p><table><thead><tr><th>1234</th><th>soup.find_all(“a”, class_=”sister”)# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>,# <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性</p><table><thead><tr><th>123</th><th>data_soup = BeautifulSoup(‘<div data-foo="value">foo!</div>‘)data_soup.find_all(data-foo=”value”)# SyntaxError: keyword can’t be an expression</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>但是可以通过 <code>find_all()</code> 方法的 <code>attrs</code> 参数定义一个字典参数来搜索包含特殊属性的tag</p><table><thead><tr><th>12</th><th>data_soup.find_all(attrs={“data-foo”: “value”})# [<div data-foo="value">foo!</div>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>3）text 参数</strong></p><p>通过 <code>text</code> 参数可以搜搜文档中的字符串内容.与 <code>name</code> 参数的可选值一样, <code>text</code> 参数接受 字符串 , 正则表达式 , 列表, True</p><table><thead><tr><th>12345678</th><th>soup.find_all(text=”Elsie”)# [u’Elsie’] soup.find_all(text=[“Tillie”, “Elsie”, “Lacie”])# [u’Elsie’, u’Lacie’, u’Tillie’] soup.find_all(text=re.compile(“Dormouse”))[u”The Dormouse’s story”, u”The Dormouse’s story”]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>4）limit 参数</strong></p><p><code>find_all()</code> 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 <code>limit</code> 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 <code>limit</code> 的限制时,就停止搜索返回结果.</p><p>文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量</p><table><thead><tr><th>123</th><th>soup.find_all(“a”, limit=2)# [<a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>,# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><strong>5）recursive 参数</strong></p><p>调用tag的 <code>find_all()</code> 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 <code>recursive=False</code> .</p><p>一段简单的文档:</p><table><thead><tr><th>1234567</th><th><html><head> <title>  The Dormouse’s story </title></head>…</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>是否使用 <code>recursive</code> 参数的搜索结果:</p><table><thead><tr><th>12345</th><th>soup.html.find_all(“title”)# [<title>The Dormouse’s story</title>] soup.html.find_all(“title”, recursive=False)# []</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（2）find-name-attrs-recursive-text-kwargs"><a href="#（2）find-name-attrs-recursive-text-kwargs" class="headerlink" title="（2）find( name , attrs , recursive , text , **kwargs )"></a>（2）find( name , attrs , recursive , text , **kwargs )</h4><p>它与 find_all() 方法唯一的区别是 <code>find_all()</code> 方法的返回结果是值包含一个元素的列表,而 <code>find()</code> 方法直接返回结果</p><h4 id="（3）find-parents-find-parent"><a href="#（3）find-parents-find-parent" class="headerlink" title="（3）find_parents()  find_parent()"></a>（3）find_parents()  find_parent()</h4><p><code>find_all()</code> 和 <code>find()</code> 只搜索当前节点的所有子节点,孙子节点等. <code>find_parents()</code> 和 <code>find_parent()</code> 用来搜索当前节点的父辈节点,搜索方法与普通tag的搜索方法相同,搜索文档搜索文档包含的内容</p><h4 id="（4）find-next-siblings-find-next-sibling"><a href="#（4）find-next-siblings-find-next-sibling" class="headerlink" title="（4）find_next_siblings()  find_next_sibling()"></a>（4）find_next_siblings()  find_next_sibling()</h4><p>这2个方法通过 .next_siblings 属性对当 tag 的所有后面解析的兄弟 tag 节点进行迭代, <code>find_next_siblings()</code> 方法返回所有符合条件的后面的兄弟节点,<code>find_next_sibling()</code> 只返回符合条件的后面的第一个tag节点</p><h4 id="（5）find-previous-siblings-find-previous-sibling"><a href="#（5）find-previous-siblings-find-previous-sibling" class="headerlink" title="（5）find_previous_siblings()  find_previous_sibling()"></a>（5）find_previous_siblings()  find_previous_sibling()</h4><p>这2个方法通过 .previous_siblings 属性对当前 tag 的前面解析的兄弟 tag 节点进行迭代, <code>find_previous_siblings()</code>方法返回所有符合条件的前面的兄弟节点, <code>find_previous_sibling()</code> 方法返回第一个符合条件的前面的兄弟节点</p><h4 id="（6）find-all-next-find-next"><a href="#（6）find-all-next-find-next" class="headerlink" title="（6）find_all_next()  find_next()"></a>（6）find_all_next()  find_next()</h4><p>这2个方法通过 .next_elements 属性对当前 tag 的之后的 tag 和字符串进行迭代, <code>find_all_next()</code> 方法返回所有符合条件的节点, <code>find_next()</code> 方法返回第一个符合条件的节点</p><h4 id="（7）find-all-previous-和-find-previous"><a href="#（7）find-all-previous-和-find-previous" class="headerlink" title="（7）find_all_previous() 和 find_previous()"></a>（7）find_all_previous() 和 find_previous()</h4><p>这2个方法通过 .previous_elements 属性对当前节点前面的 tag 和字符串进行迭代, <code>find_all_previous()</code> 方法返回所有符合条件的节点, <code>find_previous()</code>方法返回第一个符合条件的节点</p><blockquote><p><strong>注：以上（2）（3）（4）（5）（6）（7）方法参数用法与 find_all() 完全相同，原理均类似，在此不再赘述。</strong></p></blockquote><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>我们在写 CSS 时，标签名不加任何修饰，类名前加点，id名前加 #，在这里我们也可以利用类似的方法来筛选元素，用到的方法是 <strong>soup.select()，</strong>返回类型是 <strong>list</strong></p><h4 id="（1）通过标签名查找"><a href="#（1）通过标签名查找" class="headerlink" title="（1）通过标签名查找"></a>（1）通过标签名查找</h4><table><thead><tr><th>12</th><th>print soup.select(‘title’) #[<title>The Dormouse’s story</title>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>12</th><th>print soup.select(‘a’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>, <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>, <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>12</th><th>print soup.select(‘b’)#[<b>The Dormouse’s story</b>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（2）通过类名查找"><a href="#（2）通过类名查找" class="headerlink" title="（2）通过类名查找"></a>（2）通过类名查找</h4><table><thead><tr><th>12</th><th>print soup.select(‘.sister’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>, <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>, <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（3）通过-id-名查找"><a href="#（3）通过-id-名查找" class="headerlink" title="（3）通过 id 名查找"></a>（3）通过 id 名查找</h4><table><thead><tr><th>12</th><th>print soup.select(‘#link1’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（4）组合查找"><a href="#（4）组合查找" class="headerlink" title="（4）组合查找"></a>（4）组合查找</h4><p>组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开</p><table><thead><tr><th>12</th><th>print soup.select(‘p #link1’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>直接子标签查找</p><table><thead><tr><th>12</th><th>print soup.select(“head &gt; title”)#[<title>The Dormouse’s story</title>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="（5）属性查找"><a href="#（5）属性查找" class="headerlink" title="（5）属性查找"></a>（5）属性查找</h4><p>查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。</p><table><thead><tr><th>12</th><th>print soup.select(‘a[class=”sister”]’)#[<a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>, <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>, <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>12</th><th>print soup.select(‘a[href=”<a href="http://example.com/elsie&quot;]&#39;)#[">http://example.com/elsie&quot;]&#39;)#[</a><a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>同样，属性仍然可以与上述查找方式组合，不在同一节点的空格隔开，同一节点的不加空格</p><table><thead><tr><th>12</th><th>print soup.select(‘p a[href=”<a href="http://example.com/elsie&quot;]&#39;)#[">http://example.com/elsie&quot;]&#39;)#[</a><a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。</p><table><thead><tr><th>123456</th><th>soup = BeautifulSoup(html, ‘lxml’)print type(soup.select(‘title’))print soup.select(‘title’)[0].get_text() for title in soup.select(‘title’):  print title.get_text()</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>好，这就是另一种与 find_all 方法有异曲同工之妙的查找方法，是不是感觉很方便？</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫中的数据提取</title>
      <link href="/archives/pachong.html"/>
      <url>/archives/pachong.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96">数据提取</a><ul><li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li><li><a href="#%E6%A6%82%E8%A6%81">概要</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E6%A6%82%E5%BF%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E7%B1%BB">数据提取概念和数据的分类</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96">什么是数据提取</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E7%A7%8D%E7%B1%BB">数据的种类</a><ul><li><a href="#%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE">构化数据</a></li><li><a href="#%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE">非结构化数据</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul></li></ul><h2 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>用网络获取的数据中提取出想要的数据。</p></blockquote><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><ul><li>数据提取概念和数据的分类</li><li>使用 <code>json</code> 模块提取数据</li><li>使用正则表达式提取数据</li><li>使用 <code>xpath</code> 提取数据</li><li>使用 <code>beautifulsoup</code> 提取数据</li><li><code>json</code>、<code>csv</code> 数据转换</li></ul><h3 id="数据提取概念和数据的分类"><a href="#数据提取概念和数据的分类" class="headerlink" title="数据提取概念和数据的分类"></a>数据提取概念和数据的分类</h3><h4 id="什么是数据提取"><a href="#什么是数据提取" class="headerlink" title="什么是数据提取"></a>什么是数据提取</h4><blockquote><p>简单的来说，数据提取就是从响应中获取我们想要的数据的过程</p></blockquote><h4 id="数据的种类"><a href="#数据的种类" class="headerlink" title="数据的种类"></a>数据的种类</h4><h5 id="构化数据"><a href="#构化数据" class="headerlink" title="构化数据"></a>构化数据</h5><ul><li><p><strong>数据类型</strong></p></li><li><p>json 格式数据</p><pre><code class="json">&#123;&quot;name&quot;:&quot;hello&quot;,&quot;age&quot;:18,&quot;parents&quot;:&#123;  &quot;mother&quot;:&quot;妈妈&quot;,  &quot;father&quot;:&quot;爸爸&quot;&#125;&#125;</code></pre></li><li><p>xml 格式数据</p><pre><code class="xml">&lt;bookstore&gt;&lt;book category=&quot;COOKING&quot;&gt;  &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;   &lt;author&gt;Giada De Laurentiis&lt;/author&gt;   &lt;year&gt;2005&lt;/year&gt;   &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;CHILDREN&quot;&gt;  &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;   &lt;author&gt;J K. Rowling&lt;/author&gt;   &lt;year&gt;2005&lt;/year&gt;   &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt;  &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt;   &lt;author&gt;Erik T. Ray&lt;/author&gt;   &lt;year&gt;2003&lt;/year&gt;   &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt;</code></pre></li><li><p>处理方式</p><blockquote><p>通过 json 模块等直接转成 Python 数据类型</p></blockquote></li></ul><h5 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h5><ul><li>数据类型<ul><li>html 格式数据</li><li>word 格式数据</li><li>等</li></ul></li><li><strong>处理方式</strong><blockquote><p>通过 <code>正则表达式</code> 、 <code>xpath</code> 、<code>beautifulsoup</code> 等模块提取数据</p></blockquote></li></ul><h2 id="爬取大学排行"><a href="#爬取大学排行" class="headerlink" title="爬取大学排行"></a>爬取大学排行</h2><p>接下来通过一篇实例来了解<code>爬取html格式数据转换</code><br>因为正值高考报名期间，便以大学软科排名网站(<strong>这里只是学习爬虫。如何排名无关紧要</strong>)</p><h3 id="获取网站url"><a href="#获取网站url" class="headerlink" title="获取网站url"></a>获取网站url</h3><ol><li>打开<br><a href="http://www.zuihaodaxue.cn/zuihaodaxuepaiming2020.html">2020软科中国大学排名</a><br><img src="https://gitee.com/koyangyang/pictures/raw/master/pachong(1).png"></li><li>按f12进入开发者控制台（谷歌浏览器等）<br><img src="https://gitee.com/koyangyang/pictures/raw/master/pachong(2).png"><br>按照图示指示获得url，并知道是get请求方式</li><li>打开测试软件获得爬取的结果<br><img src="https://gitee.com/koyangyang/pictures/raw/master/pachong(3).png"><br>通过结果找到自己想要爬取的数据，并对结果进行筛选，这里爬取获得的是html数据<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="python"># coding=UTF-8import requestsfrom bs4 import BeautifulSoup</code></pre></li></ol><h1 id="目标网站url"><a href="#目标网站url" class="headerlink" title="目标网站url"></a>目标网站url</h1><p>url = “<a href="http://www.zuihaodaxue.cn/zuihaodaxuepaiming2020.html&quot;">http://www.zuihaodaxue.cn/zuihaodaxuepaiming2020.html&quot;</a></p><h1 id="自定义请求头部"><a href="#自定义请求头部" class="headerlink" title="自定义请求头部"></a>自定义请求头部</h1><p>headers = {<br>    “User-Agent”: “Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36”<br>}</p><h1 id="获取请求返回内容"><a href="#获取请求返回内容" class="headerlink" title="获取请求返回内容"></a>获取请求返回内容</h1><p>respoense = requests.get(url, headers=headers).content.decode(‘utf-8’)</p><h1 id="将内容通过BeautifulSoup转换数据"><a href="#将内容通过BeautifulSoup转换数据" class="headerlink" title="将内容通过BeautifulSoup转换数据"></a>将内容通过BeautifulSoup转换数据</h1><p>trans = BeautifulSoup(respoense, “html.parser”)</p><h1 id="在所有数据中查找div标签"><a href="#在所有数据中查找div标签" class="headerlink" title="在所有数据中查找div标签"></a>在所有数据中查找<code>div</code>标签</h1><p>re_div = trans.find_all(‘div’)</p><h1 id="遍历所有含div标签的内容"><a href="#遍历所有含div标签的内容" class="headerlink" title="遍历所有含div标签的内容"></a>遍历所有含<code>div</code>标签的内容</h1><p>for names in re_div:<br>    if(names.get(‘align’) == ‘left’):<br>        print(names.string)</p><p>```</p><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="https://gitee.com/koyangyang/pictures/raw/master/20200730155230.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是爬虫的初步学习，对于一些简单的网站基本适用，关键在于如何对爬取获得的请求返回信息进行一个转换和提取才是关键</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息纷繁复杂时代的RSS利器</title>
      <link href="/archives/rss.html"/>
      <url>/archives/rss.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们目前生活在一个每天充斥着大量信息时代，微博、杂志、短视频、公众号等等每天都在给我们推送很多复杂并未经分类的信息，其中有不少是娱乐信息，社会猎奇新闻，国际前沿信息，而我们的兴趣却被慢慢忽视掉了，各种团体疯狂抢取流量的竞争，也正是为啥我们需要了解使用一种合适的获取信息的方法。</p><h2 id="RSS简介"><a href="#RSS简介" class="headerlink" title="RSS简介"></a>RSS简介</h2><ul><li>可以简单的理解为一种订阅方式，其实官方名字应该叫作<strong>简单信息聚合</strong>（也叫聚合内容）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议，它的英文全称叫作<strong>Really Simple Syndication</strong>。</li><li><strong>RSS</strong>广泛用于网上新闻频道，blog和wiki，主要的版本有0.91, 1.0, 2.0。使用RSS订阅能更快地获取信息，网站提供RSS输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持RSS的聚合工具软件，在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。<h2 id="如何获得RSS"><a href="#如何获得RSS" class="headerlink" title="如何获得RSS"></a>如何获得RSS</h2><h3 id="网站提供"><a href="#网站提供" class="headerlink" title="网站提供"></a>网站提供</h3>最简单的方法是直接查找现成的RSS订阅地址，比如我们有时候看到网址有不起眼的RSS超链接或图标等类似提示标志，如图：<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/rss1.png"><br>这时我们点开网址，既可以看到类似这样充满摘选文字信息的网页<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/rss2.png"><br>然后我们复制并记录这个网页的链接，并将其添加到<strong>RSS阅读器</strong>中,即可获得当下网址的内容<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/rss3.png"><h3 id="自己获取RSS订阅地址"><a href="#自己获取RSS订阅地址" class="headerlink" title="自己获取RSS订阅地址"></a>自己获取RSS订阅地址</h3><h4 id="扩展程序获取"><a href="#扩展程序获取" class="headerlink" title="扩展程序获取"></a>扩展程序获取</h4>这里推荐的是<strong>RSShub Reader</strong>这款扩展程序，可以在谷歌扩展程序商店搜到<img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/rss4.png"><br>当你浏览那些把RSS订阅按钮隐藏起来的网站，可以点击这个扩展程序，它可以发现这个网页隐藏的RSS订阅地址，然后可以收集复制这个链接去RSS阅读器使用并订阅这个网站。<h4 id="试探性查找"><a href="#试探性查找" class="headerlink" title="试探性查找"></a>试探性查找</h4>一般可以尝试在你想要找到RSS订阅地址的网址后面加上<code>/feed</code>或者<code>aatom.xml</code>，这两个是一般RSS订阅默认提供的方式，如果有更多欢迎补充。比如我们在我的网站<a href="https://www.koyang.shop/">https://www.koyang.shop</a>后加上<code>atom.xml</code>成<a href="https://www.koyang.shop/atmo.xml">https://www.koyang.shop/atmo.xml</a>,这个网址就是我的网站的RSS订阅地址，很多人添加RSS功能没有修改订阅地址一般默认就是网址后面加<code>/feed</code>或<code>atom.xml</code><h4 id="第三方提供服务"><a href="#第三方提供服务" class="headerlink" title="第三方提供服务"></a>第三方提供服务</h4>在<strong>RSShub Reader</strong>的官方网址也是提供了很多RSS订阅地址，这个已经是<strong>RSShub Reader</strong>搭建完成并提供给大家使用的订阅服务，找到你喜欢的网站或内容的RSS订阅地址，复制到RSS阅读器上去，即可开始订阅网址，特别简单方便，<strong>不用动手的感觉真爽</strong>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看透一件事，没必要说破</title>
      <link href="/archives/test1.html"/>
      <url>/archives/test1.html</url>
      
        <content type="html"><![CDATA[<p><strong>这是测试文本转语言功能，由于hexo没有后台数据库，目前我找到的办法是把文件传到Onedrive里面，在解析外链引用，如果听不到声音是因为网络问题加载，稍等一会就好，后续有更好办法在更新修改</strong></p><center><audio id="audio" controls="" preload="auto" radius="50%">      <source id="mp3" src="https://onedrive.gimhoy.com/sharepoint/aHR0cHM6Ly8yOWp0MC1teS5zaGFyZXBvaW50LmNvbS86dTovZy9wZXJzb25hbC9rb3lhbmdfY3N1X2Nvb2wvRWFkX1dSRDJVMGhMcnRlb0wzQ2RGYXdCWVpFOHdDSllMSkJQZ3M2TUxCWGFTdz9lPVc1Y3hEWQ==.mp3"></audio></center><p>做人，不是多说话，而是要会说话；不懂时，不说，懂时，少说。<br>与小人争辩，辨不出道理；与家人争辩，伤的是和气；与朋友争辩，伤的是感情。<br>守嘴是福，不多吵，不多说，不多问，嘴上不多说，心里明白就行。<br>为人处世，不会说的，就不要说；不该说的，就不必说，直话，转弯说；反话，正着说。<br>不要不懂装懂，夸夸其谈，少说几句，没有人会把你当哑巴，话多了，容易得罪人，也会给自己带来祸害，守好一张嘴，把好是非关，生活才会心安。<br>自古，树大招风，言多必失。祸从口出的道理要牢记。<br>有些话，只适合藏着，不适合说；有些事，只适合看破，不可以说。<br>￼<br>看清一个人，没必要拆穿；讨厌一个人，没必要翻脸；看透一件事，没必要说破。<br>心里明白，嘴上不要说出来，这样才不会伤到自己，招惹别人。<br>人生路上，要学会沉默，该明白的要明白，该看透的就要看透，不该说的 就不要说。<br>经历了岁月，才能明白人生的苦痛，经历了磨练才能懂得生活的艰辛，要明白，学会说话，说好话，是人的一生中必修的功课。<br>沉默不是懦弱，不是无能，而是心灵通透后的豁达，选择后的安静，凡事看开，人生才坦然，学会沉默，让岁月走过清简流年，岁月静好。<br>说话，让着别人，不去争，不去吵，与人和善；凡事看透不说透，凡事看破不说破，与人留余地，与自己留后路。<br>有些人，只是点头之交，没必要掏心掏肺；有些人，只是表面和善，没必要全抛一颗真心。<br>￼<br>学着糊涂一点，学会愚笨一点，这样才安静，才从容。<br>沉默是最好的自救，尤其是在情绪不稳定的情况下，一定要学会闭嘴。<br>人在极度愤怒的时候，最容易出口伤人，也许是有口无心，图个痛快，但是生气的话往往失去了理智，伤人伤己，等你冷静下来的时候，后悔也无用，话从口出就会覆水难收。<br>极度生气的时候，最好能够自己冷静片刻，忍住冲动的表达，给自己留点余地，才不给自己惹祸伤身，免得犯下大错。<br>￼<br>受到打击的时候，人最容易陷入悲哀痛苦的负面情绪中，看不到希望，看不到未来，人很容易悲观，绝望，很多时候会想不通，说出傻话。<br>一个人在颓废消极的时候，不要去胡乱说话，免得被人笑话你的懦弱，走出去呼吸呼吸空气散散心，接近大自然，在广阔的天地之间体会人生的坚强。<br>人在大悲的时候，容易悲观，在大喜的时候，容易兴奋过度，这个时候，人往往容易失态，一开心，口无遮拦的说出了很多掏心窝的实话，给嫉妒恨你的人留下暗算你的隐患；要记住，自己的成绩虽然可喜，但是人外有人，天外有天，不要太过高调。<br>说话，是每个正常人最简单的能力，往往我们说一句话，毫不费力，却因为多说一句话，而招惹是非；做人，不能太过自我，要考虑到所处的说话环境，顾及他人的感受，有所把握，然后才能好好说话，好好生活。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何进行内网穿透</title>
      <link href="/archives/xiaomy.html"/>
      <url>/archives/xiaomy.html</url>
      
        <content type="html"><![CDATA[<p>最近因为生产环境的需要，把自己的主力实体机换成了Linux(强调不是虚拟机)，但是因为经常外出，为了方便出门在外仍然可以操作家中电脑，所以现在考虑尝试内网穿透<br>说起内网穿透很多人不知道是干啥的，接下来简单的讲解一下内外网区别</p><h2 id="内网和外网区别"><a href="#内网和外网区别" class="headerlink" title="内网和外网区别"></a>内网和外网区别</h2><p>内网和外网的定义：</p><ul><li>内网通俗的说就是局域网，是几台或者几十台电脑之间互相连接用于资源共享的网络。比如邻居之间的电脑连成内网打CS。</li><li>外网通俗的说就是与因特网相通的。可以访问因特网上的所有网络资源。如果你用的是ADSL连接的就是外网<br>具体详细解答还请移步：<a href="https://m.sohu.com/a/321883781_100195755/?pvid=000115_3w_a">传送门</a><br>因为中国的三大运营商是不主动提供公网IP，你也可以跟客服申请公网IP(基本不给，给也不是固定IP)</li></ul><p>所以现在往内网穿透方向考虑</p><h2 id="注册一个网穿云账号"><a href="#注册一个网穿云账号" class="headerlink" title="注册一个网穿云账号"></a>注册一个网穿云账号</h2><p>网上很多提供内网穿透服务的厂商，现在拿<strong>网穿云</strong>做教程，因为这个才刚起步，有条免费隧道，个人使用还是很不错<br><a href="https://www.xiaomy.net/">注册地址</a></p><ol><li>进入控制台-开通一条隧道<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou2.png"><br>个人使用一条3Mbps的免费隧道应该够用，如果你需要多条隧道或者搭建游戏服务器开黑、搭建语音聊天平台、搭建多人在线网站和资源文件下载站可以考虑升级配置，输入优惠码uwn8qw即可，一般个人使用一条免费隧道即可<br>输入本地需要穿透的内网地址，端口号，隧道类型后点击开通就可以</li><li>下载服务端<br>点击顶部下载自己电脑系统的服务端，网穿云是提供全平台的服务端，我这里用的Linux所以我下载Linux版本<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou1.png"></li><li>运行服务端<br>打开后输入控制台里面的令牌即可，几秒钟解析完毕就可以外网连接<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou3.png"></li></ol><h2 id="外网连接"><a href="#外网连接" class="headerlink" title="外网连接"></a>外网连接</h2><p>输入控制台里面的域名和端口号连接即可</p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>随机给的域名太贵可以修改域名，也可以自己绑定自己购买的域名(免费隧道不支持)</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>我这里显示的是Linux系统，也只是方便我在外控制家中电脑终端，更多用途比如连接家中服务器，网站搭建，数据库远程访问等就不展示，内网穿透用途懂得自然懂<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou5.jpg"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>内网穿透是干什么的：最直白讲就是出门在外可以连接家中任何局域网设备，比如电脑、NAS、下载器</li><li>网穿云是否永久免费：目前阶段是永久免费<img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/neiwangchuantou4.jpg"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的Git命令</title>
      <link href="/archives/git.html"/>
      <url>/archives/git.html</url>
      
        <content type="html"><![CDATA[<p>经常用Github怎么能不会Git命令，收录一些常用的Git命令</p><a id="more"></a><p>听说Linux和git搭配更加好用，附上我正在使用的Linux系统<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/desktop.png"></p><h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h2><h3 id="1-1-git-配置"><a href="#1-1-git-配置" class="headerlink" title="1.1. git 配置"></a>1.1. git 配置</h3><pre><code class="shell"># 显示 config 的配置 加--list# 优先级：local &gt; global &gt; systemgit config --list --local # local 的范围是某个仓库git config --list --global # global 的范围是登录的用户git config --list --system # system 的范围是系统所有登录的用户# 配置用户 name 和 emailgit config --global user.name &#39;your_name &#39;git config --global user.email &#39;your_email@domain.com&#39;# 清除配置信息git config --unset --global user.name</code></pre><h3 id="1-2-仓库初始化"><a href="#1-2-仓库初始化" class="headerlink" title="1.2. 仓库初始化"></a>1.2. 仓库初始化</h3><pre><code class="shell"># 将执行该命令时所在的目录初始化为一个 git 仓库（如：进入某目录后执行该命令会将该目录初始化为一个 git 仓库）git init# 会在当前路径下创建和项目名称同名的文件夹，并将其初始化为 git 仓库git init your_project</code></pre><h3 id="1-3-git-add"><a href="#1-3-git-add" class="headerlink" title="1.3. git add"></a>1.3. git add</h3><pre><code class="shell">git add readme.md # 将 readme.md 文件添加到暂存区git add . # 将当前工作目录的所有文件添加到暂存区git add -u # 把修改之后的文件（这些文件已经被管理起来了）一次性提交到暂存区</code></pre><h3 id="1-4-git-status"><a href="#1-4-git-status" class="headerlink" title="1.4. git status"></a>1.4. git status</h3><pre><code class="shell">git status # 查看工作目录和暂存区的状态</code></pre><h3 id="1-5-git-commit"><a href="#1-5-git-commit" class="headerlink" title="1.5. git commit"></a>1.5. git commit</h3><pre><code class="shell">git commit -m &#39;Add readme.md&#39; # -m 指定 commit 的信息git commit # 这时候会跳出一个文本输入界面，让你输入更多的 commit 信息</code></pre><h3 id="1-6-git-mv"><a href="#1-6-git-mv" class="headerlink" title="1.6. git mv"></a>1.6. git mv</h3><pre><code class="shell">git mv readme readme.md # 将 git 管理的文件进行重命名</code></pre><h3 id="1-7-git-rm"><a href="#1-7-git-rm" class="headerlink" title="1.7. git rm"></a>1.7. git rm</h3><pre><code class="shell">git rm filename # 从 git 管理的文件删除某个已管理的文件，同时把修改的情况添加到暂存区</code></pre><h3 id="1-8-git-log"><a href="#1-8-git-log" class="headerlink" title="1.8. git log"></a>1.8. git log</h3><pre><code class="shell">git log # 只查看当前分支(Head所指的分支)的log情况git log --oneline # 简洁的显示版本更新信息git log -n2  # n2 代表查看最近两次commit历史git log -2   # 2 代表查看最近两次commit历史git log -n2 --oneline # 简洁的显示最近两次的版本更新信息git log branch_name # 后面跟上分支名表示查看该分支的log日志git log -all # 列出所有分支的loggit log --all --graph # 以图形化的方式查看git log --oneline --all # 以简洁的方式查看所有分支的loggit log --oneline --all -n4# 以简洁的方式查看所有分支的loggit help log # 以web的方式查看log的帮助文档，等同于git help --web log # 和上面那条效果一样</code></pre><h2 id="2-分支相关"><a href="#2-分支相关" class="headerlink" title="2. 分支相关"></a>2. 分支相关</h2><pre><code class="shell">git branch -v # 查看本地分支的详细情况git branch -a # 查看所有分支，包括远端分支，但没有过于详细的信息git branch -av # 查看所有分支情况git branch branch_name hash_value # 创建一个新的分支，基于 hash_value 的这个 commit 创建一个新的分支，hash_value 可以省略，那么默认是基于当前分支的最后一个 commit 创建。git branch -d branch_namegit branch -D branch_name  # 这个分支已经有了一些 commitgit checkout branch_name # 切换分支git checkout mastergit checkout -b branch_name git_id # 创建一个新的分支并切换过去，git_id可以是hash_value，也可以是某个分支的名字（分支的名字其实就指向了某个 commit）git checkout -b temp 9ef147dgit checkout -b temp2 mastergit checkout hash_value  # 分离头指针</code></pre><h2 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h2><pre><code class="shell">git diff hash_value1 hash_value2 # hash_value1 对应的 comimit 和 hash_value2 对应的 commit 进行比较git diff hash_value1 hash_value2 -- file_name1 file_name2 # 在上述基础之上，只比较 file_name1、file_name2 这两个文件git diff branch_name1 branch_name2 # 对两个分支进行比较，也可以跟 -- 只看某些文件git diff HEAD HEAD^  # HEAD 指向的 commit 与该 commit 的父亲 commit 进行比较git diff HEAD HEAD^^ # HEAD 指向的 commit 与该 commit 的父亲的父亲 commit 进行比较git diff HEAD HEAD~  # HEAD 指向的 commit 与该 commit 的父亲 commit 进行比较git diff HEAD HEAD~1 # 同上 git diff HEAD HEAD~2 # HEAD 指向的 commit 与该 commit 的父亲的父亲 commit 进行比较git diff --cached  # 暂存区和 HEAD 做比较，也可以跟 -- 只看某些文件git diff      # 工作目录和暂存区中所有文件进行比较，也可以跟 -- 只看某些文件</code></pre><h2 id="4-版本历史更改"><a href="#4-版本历史更改" class="headerlink" title="4. 版本历史更改"></a>4. 版本历史更改</h2><pre><code class="shell">git commit --amend # 最近一次 commit 的 message 修改git rebase -i hash_value # 交互文件中选择 reword，老旧 commit 的 message 修改。hash_value，是需要的 commit 的父亲 commit 的 hash_valuegit rabase -i hash_value # 交互文件中选择 squash，多个连续 commit 合并成一个，hash_value 同上git rebase -i hash_value # 交互文件中选择 squash，把间隔的 commit 移到一块，即可合并成一个，hash_valuegit rebase origin/master # 把当前分支基于 origin/master 做 rebase 操作，也就相当于把当前分支的东西加到 origin/master 中</code></pre><h2 id="5-回滚操作"><a href="#5-回滚操作" class="headerlink" title="5. 回滚操作"></a>5. 回滚操作</h2><pre><code class="shell">git reset HEAD        # 暂存区恢复成和 HEAD 一样git reset HEAD -- file_name1 file_name2 # 暂存区部分文件变得跟 HEAD 一样git checkout -- file_name # 工作目录指定文件恢复为和暂存区一样git checkout -- *|. ## 工作目录全部文件恢复为和暂存区一样git reset --hard hash_value # 把 HEAD、暂存区、工作目录都回滚到 hash_value 所代表的 commit 中。git reset --hard  # 把暂存区里面的修改去掉，也就是让暂存区、工作目录默认恢复到 HEAD 的位置</code></pre><h2 id="6-工作目录、暂存区状态保存"><a href="#6-工作目录、暂存区状态保存" class="headerlink" title="6. 工作目录、暂存区状态保存"></a>6. 工作目录、暂存区状态保存</h2><pre><code class="shell">git stash # 把相应的修改内容给存下来，之后 git status 查看的话又变为什么都没改变的了git stash list # 查看存下来的内容git stash apply # 存下来的内容又恢复了，但是存下来的内容还在 stash 中git stash pop   # 存下来的内容恢复了，但是存下来的内容也没了</code></pre><h2 id="7-合并"><a href="#7-合并" class="headerlink" title="7. 合并"></a>7. 合并</h2><pre><code class="shell">git merge branch_name1 branch_name2git merge hash_value1 hash_value2git merge --squash # 以 squash 方式进行 merge</code></pre><h2 id="8-Git-对象操作"><a href="#8-Git-对象操作" class="headerlink" title="8. Git 对象操作"></a>8. Git 对象操作</h2><pre><code class="shell">git cat-file -t|p|s hash_value # 显示版本库对象的内容，类型及大小信息git cat-file -t hash_value  # 查看版本库对象的类型git cat-file -p hash_value  # 查看版本库对象的内容git cat-file -s hash_value  # 查看版本库对象的大小</code></pre><h2 id="9-Git-远端操作"><a href="#9-Git-远端操作" class="headerlink" title="9. Git 远端操作"></a>9. Git 远端操作</h2><pre><code class="shell">git remote add &lt;远端名&gt; &lt;远端仓库地址&gt; # 这边远端名的意思是远端仓库的别名，push、pull 都将用到远端名git remote -v  # 查看远端仓库连接情况git remote set-url &lt;远端名&gt; 你新的远程仓库地址 # 修改远端仓库地址git remote rm &lt;远端名&gt;      # 删除远端仓库git clone &lt;远端仓库地址&gt; # 把远端仓库 clone 下来git clone --bare  &lt;远端仓库地址&gt; # bare 是指不带工作目录，也就相当于只 clone .git 目录git push &lt;远端名&gt; &lt;本地分支名&gt; git push -u &lt;远端名&gt; &lt;本地分支名&gt; # -u 表示将本地分支的内容推到远端分支，并且将本地分支和远端分支关联起来git push -u origin master # 表示把本地 master 分支的内容推到远端分支 origin/master，并且将本地分支 master 和远端分支 origin/master 关联起来git push # 这条命令也可以使用，默认是将当前本地所在分支推到相关联的远端分支git fetch &lt;远端名&gt; &lt;本地分支名&gt;git fetch origin master # 将远端分支 origin/master fetch 到本地git pull &lt;远端名&gt; &lt;本地分支名&gt; # 将远端分支 fetch 到本地，并且将远端分支和本地所处分支进行合并git pull --rebase # 以 rebase 方式进行合并，也就是将本地分支 rebase 到远端分支</code></pre><h2 id="Github上传项目"><a href="#Github上传项目" class="headerlink" title="Github上传项目"></a>Github上传项目</h2><ol><li>在Github上new一个Repository</li><li>打开Git Bash输入<pre><code class="git">git clone https://github.com/用户名/项目名.git</code></pre></li><li>把项目文件移动这个文件夹</li><li>依次输入<pre><code class="git">git add .git commit -m &quot;内容&quot;git push -u origin master</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wiki </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux帮助信息命令指北</title>
      <link href="/archives/linux1.html"/>
      <url>/archives/linux1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-查看-Linux-命令帮助信息的要点"><a href="#1-查看-Linux-命令帮助信息的要点" class="headerlink" title="1. 查看 Linux 命令帮助信息的要点"></a>1. 查看 Linux 命令帮助信息的要点</h2><ul><li>查看 Shell 内部命令的帮助信息 - 使用 <a href="#help">help</a></li><li>查看命令的简要说明 - 使用 <a href="#whatis">whatis</a></li><li>查看命令的详细说明 - 使用 <a href="#info">info</a></li><li>查看命令的位置 - 使用 <a href="#which">which</a></li><li>定位指令的二进制程序、源代码文件和 man 手册页等相关文件的路径 - 使用 <a href="#whereis">whereis</a></li><li>查看命令的帮助手册（包含说明、用法等信息） - 使用 <a href="#man">man</a></li><li>只记得部分命令关键字 - 使用 man -k</li></ul><h2 id="2-命令常见用法"><a href="#2-命令常见用法" class="headerlink" title="2. 命令常见用法"></a>2. 命令常见用法</h2><h3 id="2-1-help"><a href="#2-1-help" class="headerlink" title="2.1. help"></a>2.1. help</h3><p><strong>help命令</strong>用于显示shell内部命令的帮助信息。help命令只能显示shell内部的命令帮助信息。而对于外部命令的帮助信息只能使用man或者info命令查看。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>help(选项)(参数)</code></pre><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><pre><code>-s：输出短格式的帮助信息。仅包括命令格式。</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>内部命令：指定需要显示帮助信息的shell内部命令。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>使用help命令显示shell内部shopt命令的帮助信息，输入如下命令：</p><pre><code>help shopt                #获取shopt命令的帮助信息shopt: shopt [-pqsu] [-o long-option] optname [optname...]    Toggle the values of variables controlling optional behavior.    The -s flag means to enable (set) each OPTNAME; the -u flag    unsets each OPTNAME.  The -q flag suppresses output; the exit    status indicates whether each OPTNAME is set or unset.  The -o    option restricts the OPTNAMEs to those defined for use with    `set -o&#39;.  With no options, or with the -p option, a list of all    settable options is displayed, with an indication of whether or    not each is set.</code></pre><h3 id="2-2-whatis"><a href="#2-2-whatis" class="headerlink" title="2.2. whatis"></a>2.2. whatis</h3><p><strong>whatis命令</strong>是用于查询一个命令执行什么功能，并将查询结果打印到终端上。</p><p>whatis命令在用<code>catman -w</code>命令创建的数据库中查找command参数指定的命令、系统调用、库函数或特殊文件名。whatis命令显示手册部分的页眉行。然后可以发出man命令以获取附加的信息。whatis命令等同于使用<code>man -f</code>命令。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code>whatis</code></pre><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>[root@localhost ~]# whatis lsls                   (1)  - list directory contentsls                   (1p)  - list directory contents[root@localhost ~]# whatis cpcp                   (1)  - copy files and directoriescp                   (1p)  - copy files[root@localhost ~]# whatis chownchown                (1)  - change file owner and groupchown                (1p)  - change the file ownershipchown                (2)  - change ownership of a filechown                (3p)  - change owner and group of a file[root@localhost ~]# whatis manman                  (1)  - format and display the on-line manual pagesman                  (1p)  - display system documentationman                  (7)  - macros to format man pagesman                 (rpm) - A set of documentation tools: man, apropos and whatis.man-pages           (rpm) - Man (manual) pages from the Linux Documentation Project.man.config [man]     (5)  - configuration data for man</code></pre><h3 id="2-3-info"><a href="#2-3-info" class="headerlink" title="2.3. info"></a>2.3. info</h3><p><strong>info命令</strong>是Linux下info格式的帮助指令。</p><p>就内容来说，info页面比man page编写得要更好、更容易理解，也更友好，但man page使用起来确实要更容易得多。一个man page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。理解这个命令的窍门就是不仅要学习如何在单独的Info页面中浏览导航，还要学习如何在节点和子节点之间切换。可能刚开始会一时很难在info页面的节点之间移动和找到你要的东西，真是具有讽刺意味：原本以为对于新手来说，某个东西比man命令会更好些，但实际上学习和使用起来更困难。</p><p><code>info(选项)(参数)</code></p><h4 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h4><pre><code>-d：添加包含info格式帮助文档的目录；-f：指定要读取的info格式的帮助文档；-n：指定首先访问的info帮助文件的节点；-o：输出被选择的节点内容到指定文件。</code></pre><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>帮助主题：指定需要获得帮助的主题，可以是指令、函数以及配置文件。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p>在info后面输入命令的名称就可以查看该命令的info帮助文档了：</p><pre><code>info info</code></pre><p>面介绍一下它的几个常用快捷键。</p><pre><code>?键：它就会显示info的常用快捷键。N键：显示（相对于本节点的）下一节点的文档内容。P键：显示（相对于本节点的）前一节点的文档内容。U键：进入当前命令所在的主题。M键：敲M键后输入命令的名称就可以查看该命令的帮助文档了。G键：敲G键后输入主题名称，进入该主题。L键：回到上一个访问的页面。SPACE键：向前滚动一页。BACKUP或DEL键：向后滚动一页。Q：退出info。</code></pre><p><strong>命令</strong></p><pre><code>？     显示帮助窗口在帮助窗口中：Ctrl-x 0          关闭帮助窗口Ctrl-x Ctrl-c    关闭整个 Infoq      退出 infon      打开与本 Node 关联的下一个 Nodep      打开与本 Node 关联的前一个 Nodeu      打开与本 Node 关联的上一个 Nodel      回到上一次访问的 Nodem或g   选择一个菜单项（Node 的名字）       输入指定菜单的名字后按回车，打开指定菜单项关联的 Node空格键 下一页（PageDown 也可以，下一页从当前页的最后两行开始算起）       下一个 Node （若当前页在 Node 文档的末尾）Del 键 上一页（PageUp 也可以，上一页从当前页的开始两行开始算起）       上一个 Node （若当前页 Node 文档的开始）b 或 t 或 Home   文档的开始（b 是 begining 的意思）e 或 End         文档的末尾（b 是 ending 的意思）Ctrl-l    刷新当前页，若当前文档显示情况有问题时Ctrl-g    取消所键入的指令</code></pre><h3 id="2-4-which"><a href="#2-4-which" class="headerlink" title="2.4. which"></a>2.4. which</h3><p><strong>which命令</strong>用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre><code>which(选项)(参数)</code></pre><h4 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h4><pre><code>-n&lt;文件名长度&gt;：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；-p&lt;文件名长度&gt;：与-n参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径；-w：指定输出时栏位的宽度；-V：显示版本信息。</code></pre><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><p>指令名：指令名列表。</p><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><p>查找文件、显示命令路径：</p><pre><code>[root@localhost ~]# which pwd/bin/pwd[root@localhost ~]#  which adduser/usr/sbin/adduser</code></pre><p>说明：which是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p><h3 id="2-5-whereis"><a href="#2-5-whereis" class="headerlink" title="2.5. whereis"></a>2.5. whereis</h3><p><strong>whereis命令</strong>用来定位指令的二进制程序、源代码文件和<a href="#man">man</a>手册页等相关文件的路径。</p><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p><p>和<a href="#find">find</a>相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的<a href="#locate">locate</a>时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre><code>whereis(选项)(参数)</code></pre><h4 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h4><pre><code>-b：只查找二进制文件；-B&lt;目录&gt;：只在设置的目录下查找二进制文件；-f：不显示文件名前的路径名称；-m：只查找说明文件；-M&lt;目录&gt;：只在设置的目录下查找说明文件；-s：只查找原始代码文件；-S&lt;目录&gt;只在设置的目录下查找原始代码文件；-u：查找不包含指定类型的文件。</code></pre><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><p>指令名：要查找的二进制程序、源文件和man手册页的指令名。</p><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><p>将相关的文件都查找出来</p><pre><code>[root@localhost ~]# whereis tomcattomcat:[root@localhost ~]# whereis svnsvn: /usr/bin/svn /usr/local/svn /usr/share/man/man1/svn.1.gz</code></pre><p>说明：tomcat没安装，找不出来，svn安装找出了很多相关文件</p><p>只将二进制文件查找出来 </p><pre><code>[root@localhost ~]# whereis -b svnsvn: /usr/bin/svn /usr/local/svn[root@localhost ~]# whereis -m svnsvn: /usr/share/man/man1/svn.1.gz[root@localhost ~]# whereis -s svnsvn:</code></pre><p>说明：<code>whereis -m svn</code>查出说明文档路径，<code>whereis -s svn</code>找source源文件。</p><h3 id="2-6-man"><a href="#2-6-man" class="headerlink" title="2.6. man"></a>2.6. man</h3><p><strong>man命令</strong>是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><pre><code>man(选项)(参数)</code></pre><h4 id="选项-4"><a href="#选项-4" class="headerlink" title="选项"></a>选项</h4><pre><code>-a：在所有的man帮助手册中搜索；-f：等价于whatis指令，显示给定关键字的简短描述信息；-P：指定内容时使用分页程序；-M：指定man手册搜索的路径。</code></pre><h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><ul><li>数字：指定从哪本man手册中搜索帮助；</li><li>关键字：指定要搜索帮助的关键字。</li></ul><p>示例：</p><pre><code>$ man date # 查看 date 命令的帮助手册$ man 3 printf # 查看 printf 命令的帮助手册中的第 3 类$ man -k keyword # 根据命令中部分关键字来查询命令</code></pre><h5 id="2-6-1-man-要点"><a href="#2-6-1-man-要点" class="headerlink" title="2.6.1. man 要点"></a>2.6.1. man 要点</h5><p>在 man 的帮助手册中，可以使用 page up 和 page down 来上下翻页。</p><p>man 的帮助手册中，将帮助文档分为了 9 个类别，对于有的关键字可能存在多个类别中， 我们就需要指定特定的类别来查看；（一般我们查询 bash 命令，归类在 1 类中）。</p><p>man 页面的分类(常用的是分类 1 和分类 3)：</p><ol><li>可执行程序或 shell 命令</li><li>系统调用(内核提供的函数)</li><li>库调用(程序库中的函数)</li><li>特殊文件(通常位于 /dev)</li><li>文件格式和规范，如 /etc/passwd</li><li>游戏</li><li>杂项(包括宏包和规范，如 man(7)，groff(7))</li><li>系统管理命令(通常只针对 root 用户)</li><li>内核例程 [非标准]</li></ol><p>前面说到使用 whatis 会显示命令所在的具体的文档类别，我们学习如何使用它</p><pre><code>$ whatis printfprintf (1) - format and print dataprintf (1p) - write formatted outputprintf (3) - formatted output conversionprintf (3p) - print formatted outputprintf [builtins](1) - bash built-in commands, see bash(1)</code></pre><p>我们看到 printf 在分类 1 和分类 3 中都有；分类 1 中的页面是命令操作及可执行文件的帮助；而 3 是常用函数库说明；如果我们想看的是 C 语言中 printf 的用法，可以指定查看分类 3 的帮助：</p><pre><code>$ man 3 printf</code></pre><h3 id="Linux命令查询"><a href="#Linux命令查询" class="headerlink" title="Linux命令查询"></a>Linux命令查询</h3><p><a href="https://man.linuxde.net/">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wiki </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下搭建Hexo</title>
      <link href="/archives/linuxhexo.html"/>
      <url>/archives/linuxhexo.html</url>
      
        <content type="html"><![CDATA[<p>因为一些原因，我已经把我的工作环境从Windows10换到了Linux，所以一些环境的搭建需要更换，接下来介绍如何配置Linux环境来搭建Hexo。</p><a id="more"></a><h2 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h2><p>这个是必须的，因为hexo就是基于nodejs的，从<a href="https://link.jianshu.com/?t=http://nodejs.cn/">官网</a>下载压缩包，解压即可</p><p>不过这里的命令不是全局的，所以需要把node和npm设置成全局</p><pre><code class="bash">ln -s /home/node-v4.4.4-linux-x64/bin/node /usr/local/bin/node  ln -s /home/node-v4.4.4-linux-x64/bin/npm /usr/local/bin/npm  </code></pre><p>前边的**/home/node-v4.4.4-linux-x64/bin/npm** 是自己的node所在的路径，这个记得改成自己的</p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>打开终端输入：</p><pre><code class="bash">sudo apt install git</code></pre><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>打开终端输入：</p><pre><code class="bash">npm install hexo-cli -g</code></pre><h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><pre><code class="bash">hexo init hexo</code></pre><h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><p>具体操作和Windows上一样<br>在终端输入：</p><pre><code class="bash">ssh-keygen -t rsacd .ssh/cat id_rsa.pub</code></pre><p><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/linuxhexo.png"></p><p>将说的key填入Github中<br>参考<a href="https://www.koyang.shop/archives/blog.html">利用Hexo+Github Pages搭建个人博客</a></p><h2 id="Hexo-部署到-GitHub-Pages"><a href="#Hexo-部署到-GitHub-Pages" class="headerlink" title="Hexo 部署到 GitHub Pages"></a>Hexo 部署到 GitHub Pages</h2><h3 id="config-yml-配置修改"><a href="#config-yml-配置修改" class="headerlink" title="_config.yml 配置修改"></a>_config.yml 配置修改</h3><pre><code class="bash">[root@zhangblog hexo]# pwd/app/softinsall/hexo[root@zhangblog hexo]# vim _config.yml………………# Deployment## Docs: https://hexo.io/docs/deployment.html  # 修改或添加如下信息deploy:  type: git  repo: git@github.com:zhanglianghhh/zhanglianghhh.github.io.git  branch: master</code></pre><h2 id="上传Github"><a href="#上传Github" class="headerlink" title="上传Github"></a>上传Github</h2><p>打开终端输入</p><pre><code class="bash">hexo n 文章名hexo cleanhexo ghexo d</code></pre><p>即可推送到Github仓库</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rclone+aria2实现OneDrive高速离线下载</title>
      <link href="/archives/aria2.html"/>
      <url>/archives/aria2.html</url>
      
        <content type="html"><![CDATA[<p>对于一些大容量网盘，如OneDrive，Google云端硬盘等本身是不自带离线下载，现在我们可以借助第三方工具aria2实现高速多线程离线下载，如有Linux用户同样适用于多线程本地下载。</p><a id="more"></a><p>先附上一张效果图：</p><p><img src="http://p.ananas.chaoxing.com/star3/origin/e15213cc87391633c6a82575db9d9fd4.png"></p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><ol><li>装有Linux系统的电脑，推荐Debian/Ubuntu(大流量VPS更好)</li><li>懂点SSH连接</li></ol><h2 id="安装并配置aria2"><a href="#安装并配置aria2" class="headerlink" title="安装并配置aria2"></a>安装并配置aria2</h2><p>这里推荐<a href="https://github.com/P3TERX/aria2.sh">P3TERX</a>大的一键脚本</p><pre><code class="Shell">wget -N git.io/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; ./aria2.sh</code></pre><p>这里因为<a href="https://github.com/P3TERX/aria2.sh">P3TERX</a>大已经配置好了aria2，目前已经是速度最快和BT trackers最多的配置，如果喜欢自定义配置可以参考aria2官方提供的安装脚本</p><p><strong>如果你使用的Linux系统，至此已经完成了Linux本地下载器的搭建</strong></p><h2 id="挂载Rclone"><a href="#挂载Rclone" class="headerlink" title="挂载Rclone"></a>挂载Rclone</h2><h3 id="客户端授权"><a href="#客户端授权" class="headerlink" title="客户端授权"></a>客户端授权</h3><p>在本地Windows电脑上下载rclone，下载地址：<a href="https://rclone.org/downloads/">https://rclone.org/downloads/</a>,解压文件夹，在此文件夹打开cmd命令，输入</p><pre><code class="cmd">rclone authorize &quot;onedrive&quot;</code></pre><p>然后会弹出浏览器登陆即可，在返回cmd</p><pre><code class="cmd">C:\Users\Administrator&gt;cd /d d:\rcloned:\rclone&gt;rclone authorize &quot;onedrive&quot;2018/01/23 20:28:56 NOTICE: Config file &quot;C:\\Users\\Administrator\\.config\\rclone\\rclone.conf&quot; not found - using defaultsChoose OneDrive account type? * Say b for a OneDrive business account * Say p for a personal OneDrive accountb) Businessp) Personalb/p&gt; p  #这里选择个人版，你想挂载Business就选择bIf your browser doesn&#39;t open automatically go to the following link: http://127.0.0.1:53682/auth  #接下来会弹出浏览器，要求你登录账号进行授权Log in and authorize rclone for accessWaiting for code...Got codePaste the following into your remote machine ---&gt;&#123;&quot;access_token&quot;:&quot;xxxx&quot;&#125;  #请复制&#123;xx&#125;整个内容，后面需要用到&lt;---End paste</code></pre><h3 id="安装Rclone"><a href="#安装Rclone" class="headerlink" title="安装Rclone"></a>安装Rclone</h3><ol><li>安装Rclone<br>用SSH连接Debian/Ubuntu，输入Rclone官方给的安装脚本<pre><code class="Shell">wget https://www.moerats.com/usr/shell/rclone_debian.sh &amp;&amp; bash rclone_debian.sh</code></pre></li><li>初始化配置<br>输入<pre><code class="Shell">rclone config</code></pre></li><li>按注释输入<pre><code class="Shell">n) New remotes) Set configuration passwordq) Quit confign/s/q&gt; nname&gt; Rats  #随便填，后面要用到Type of storage to configure.Choose a number from below, or type in your own value1 / Amazon Drive \ &quot;amazon cloud drive&quot;2 / Amazon S3 (also Dreamhost, Ceph, Minio) \ &quot;s3&quot;3 / Backblaze B2 \ &quot;b2&quot;4 / Box \ &quot;box&quot;5 / Cache a remote \ &quot;cache&quot;6 / Dropbox \ &quot;dropbox&quot;7 / Encrypt/Decrypt a remote \ &quot;crypt&quot;8 / FTP Connection \ &quot;ftp&quot;9 / Google Cloud Storage (this is not Google Drive) \ &quot;google cloud storage&quot;10 / Google Drive \ &quot;drive&quot;11 / Hubic \ &quot;hubic&quot;12 / Local Disk \ &quot;local&quot;13 / Microsoft Azure Blob Storage \ &quot;azureblob&quot;14 / Microsoft OneDrive \ &quot;onedrive&quot;15 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \ &quot;swift&quot;16 / Pcloud \ &quot;pcloud&quot;17 / QingCloud Object Storage \ &quot;qingstor&quot;18 / SSH/SFTP Connection \ &quot;sftp&quot;19 / Webdav \ &quot;webdav&quot;20 / Yandex Disk \ &quot;yandex&quot;21 / http Connection \ &quot;http&quot;Storage&gt; 14  #选择14，Microsoft OneDrive，，注意该序列号会随时变化，看清楚再填Microsoft App Client Id - leave blank normally.client_id&gt;  #留空 Microsoft App Client Secret - leave blank normally.client_secret&gt;  #留空 Remote configChoose OneDrive account type?* Say b for a OneDrive business account* Say p for a personal OneDrive accountb) Businessp) Personalb/p&gt; p  #这里选择个人版，你想挂载Business就选择bUse auto config?* Say Y if not sure* Say N if you are working on a remote or headless machiney) Yesn) Noy/n&gt; n  #选择nFor this to work, you will need rclone available on a machine that has a web browser available.Execute the following on your machine:  rclone authorize &quot;onedrive&quot;Then paste the result below:result&gt; &#123;&quot;access_token&quot;:&quot;&quot;&#125;  #输入之前在客户端授权的内容</code></pre></li></ol><hr><p>[Rats]<br>client_id =<br>client_secret =<br>token = {“access_token”:””}</p><hr><p>y) Yes this is OK<br>e) Edit this remote<br>d) Delete this remote<br>y/e/d&gt; y  选择y<br>Current remotes:</p><p>Name                 Type<br>====                 ====<br>Rats                 onedrive</p><p>e) Edit existing remote<br>n) New remote<br>d) Delete remote<br>r) Rename remote<br>c) Copy remote<br>s) Set configuration password<br>q) Quit config<br>e/n/d/r/c/s/q&gt; q  #选择q退出</p><pre><code>## 配置自动上传脚本- 输入nano /root/.aria2c/upload.sh打开自动上传脚本进行编辑```nano# Rclone 配置时填写的网盘名(name)DRIVE_NAME=&#39;Onedrive&#39;# 网盘目录。即上传目标路径，留空为网盘根目录，末尾不要有斜杠。DRIVE_PATH=&#39;/DRIVEX/Download&#39;</code></pre><ul><li>输入nano /root/.aria2c/aria2.conf打开 Aria2 配置文件进行修改。<pre><code class="nano"># 下载完成后执行的命令on-download-complete=/root/.aria2c/upload.sh</code></pre></li><li>重启<br><code>reboot</code></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>PC端使用请下载AriaNg这个前端管理界面并连接Aria2地址<br>下载地址：<a href="https://github.com/mayswind/AriaNg/releases">https://github.com/mayswind/AriaNg/releases</a></p></li><li><p>手机端可以用微信小程序，界面简洁还自带影视下载添加<br><img src="http://p.ananas.chaoxing.com/star3/origin/ae7ab95e08b39942315fee2baf3a613f.png"></p></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>离线下载完后脚本会自动删除本地文件，不用担心本地空间占用</li><li>严格按照教程来进行操作不会遇到问题，如果有问题那一定是你自身的问题，请仔细阅读教程中的每一个字。</li><li>如果你对nano编辑器不了解，可以看看这个<a href="https://blog.csdn.net/weixin_41293827/article/details/106812686">https://blog.csdn.net/weixin_41293827/article/details/106812686</a></li><li>Shell软件推荐免费的<strong>Xshell</strong>，手机端推荐<strong>termius</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> aria2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步更改Django生成网页内容</title>
      <link href="/archives/django2.html"/>
      <url>/archives/django2.html</url>
      
        <content type="html"><![CDATA[<p>紧接着上部内容，现在进一步学习Django</p><a id="more"></a><h2 id="了解目录文件"><a href="#了解目录文件" class="headerlink" title="了解目录文件"></a>了解目录文件</h2><p>创建一个app名为Helloworld的应用<br>.<br>|– HelloWorld<br>|   |– <strong>init</strong>.py<br>|   |– asgi.py<br>|   |– settings.py<br>|   |– urls.py<br>|   <code>-- wsgi.py </code>– manage.py</p><ul><li>HelloWorld: 项目的容器。</li><li>manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。</li><li>HelloWorld/<strong>init</strong>.py: 一个空文件，告诉 Python 该目录是一个 Python 包。</li><li>HelloWorld/asgi.py: 一个 ASGI 兼容的 Web 服务器的入口，以便运行你的项目。</li><li>HelloWorld/settings.py: 该 Django 项目的设置/配置。</li><li>HelloWorld/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。</li><li>HelloWorld/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。</li></ul><h2 id="创建views-py文件"><a href="#创建views-py文件" class="headerlink" title="创建views.py文件"></a>创建views.py文件</h2><p>并输入代码：</p><pre><code class="Python">from django.http import HttpResponsedef hello(request):    return HttpResponse(&quot;Hello world ! &quot;)</code></pre><h2 id="修改urls-py文件"><a href="#修改urls-py文件" class="headerlink" title="修改urls.py文件"></a>修改urls.py文件</h2><p>修改内容：</p><pre><code class="Python">from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r&#39;^$&#39;, views.hello),]</code></pre><p>或：</p><pre><code class="Python">from django.urls import pathfrom . import viewsurlpatterns = [    path(&#39;hello/&#39;, views.hello),]</code></pre><p>通过浏览器打开 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a>,出现Hello world!即可</p><p><img src="http://p.ananas.chaoxing.com/star3/origin/d473bd16e14de53eb69b0348208e8133.png"></p><h2 id="path-函数"><a href="#path-函数" class="headerlink" title="path() 函数"></a>path() 函数</h2><p>Django path() 可以接收四个参数，分别是两个必选参数：route、view 和两个可选参数：kwargs、name。</p><blockquote><p>path(route, view, kwargs=None, name=None)</p></blockquote><ul><li>route: 字符串，表示 URL 规则，与之匹配的 URL 会执行对应的第二个参数 view。</li><li>view: 用于执行与正则表达式匹配的 URL 请求。</li><li>kwargs: 视图使用的字典类型的参数。</li><li>name: 用来反向获取 URL。</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><ul><li><code>runoo+b</code>，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</li><li><code>runoo*b</code>，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li><li><code>colou?r</code> 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</li></ul><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">\cx</td><td align="center">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\f</td><td align="center">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="center">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="center">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="center">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left">\S</td><td align="center">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="center">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="center">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr></tbody></table><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 <strong><strong>*，简单的说就是表示任何字符串的意思。如果要查找字符串中的 *</strong></strong> 符号，则需要对 <strong>*** 进行转义，即在其前加一个 <strong>\</strong>: *<em>runo\</em>ob</strong> 匹配 runo*ob。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<strong>\</strong> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th align="left">特别字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">$</td><td align="center">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td></tr><tr><td align="left">( )</td><td align="center">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td align="left">*</td><td align="center">匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td></tr><tr><td align="left">+</td><td align="center">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td align="left">.</td><td align="center">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td align="left">[</td><td align="center">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td align="left">?</td><td align="center">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td align="left">\</td><td align="center">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="center">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td align="left">{</td><td align="center">标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td align="left">|</td><td align="center">指明两项之间的一个选择。要匹配 |，请使用 |。</td></tr></tbody></table><hr><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 *<strong>** 或 **+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\b</strong> 描述单词的前或后边界，<strong>\B</strong> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td align="left">\B</td><td align="left">非单词边界匹配。</td></tr></tbody></table><p><strong>注意</strong>：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <strong>^*</strong> 之类的表达式。若要匹配一行文本开始处的文本，请在正则表达式的开始使用 <strong>^</strong> 字符。不要将 <strong>^</strong> 的这种用法与中括号表达式内的用法混淆。若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 <strong>$</strong> 字符。</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。</p><p>其中 <strong>?:</strong> 是非捕获元之一，还有两个非捕获元是 <strong>?=</strong> 和 **?!**，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p><hr><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>可以使用非捕获元字符 <strong>?:**、</strong>?=** 或 <strong>?!</strong> 来重写捕获，忽略对相关匹配的保存。</p><h2 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a>工具网站</h2><p>一个学习正则表达式的网站和一个练习正则表达式的网站<br>1.<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a><br>2.<a href="https://tool.oschina.net/regex/">https://tool.oschina.net/regex/</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解Python的Django框架</title>
      <link href="/archives/django1.html"/>
      <url>/archives/django1.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在学习完Python之后，我便开始了Python的一个web框架的学习，现在开始是初步了解Django</p><a id="more"></a><h1 id="什么是Django"><a href="#什么是Django" class="headerlink" title="什么是Django"></a>什么是Django</h1><p>Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务 Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式，MVC 模式使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。</p><p><strong>（跳过Django的安装）</strong></p><h2 id="Django的项目目录介绍"><a href="#Django的项目目录介绍" class="headerlink" title="Django的项目目录介绍"></a>Django的项目目录介绍</h2><p><img src="http://p.ananas.chaoxing.com/star3/origin/5c1b225c961bdf53e6f4877426857c79.png" alt="Django根目录"></p><pre><code>|---mysite # 项目的/目录   |---mysite # 项目目录       |---__init__.py       |---settings.py # 配置文件       |---urls.py # 路由系统 ===&gt; url与视图的对应关系       |---wsgi.py # runserver命令就使用wsgiref模块做简单的web server |---manage.py # 管理文件</code></pre><h2 id="使用Pycharm创建应用"><a href="#使用Pycharm创建应用" class="headerlink" title="使用Pycharm创建应用"></a>使用Pycharm创建应用</h2><p>file —&gt; new project —- 选择Django —&gt; 配置路径和项目名称 —&gt; 配置环境(默认用系统环境) —-&gt; 点击create(完成创建)<br><img src="http://p.ananas.chaoxing.com/star3/origin/8e737572dac4fe616123702b8c3ed3de.png"><br>如需更改配置信息，请下拉选择 edit configurations，进行配置。<br><img src="http://p.ananas.chaoxing.com/star3/origin/3d5cda4c9ec55438dadf8c89bd1710b7.png"><br><img src="http://p.ananas.chaoxing.com/star3/origin/76e0fec51243fecf497e122f96b099d4.png"><br>创建完成之后点击右上角运行即可运行Django，点击控制台链接或者直接浏览器输入<a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a><br>显示这个画面创建Django就成功了<br><img src="http://p.ananas.chaoxing.com/star3/origin/f6d5dde0ec2ba1e568f89f102dac93ee.png"></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法的几个小练习</title>
      <link href="/archives/python-3.html"/>
      <url>/archives/python-3.html</url>
      
        <content type="html"><![CDATA[<p><strong>Python基础语法已经学完了。来分享几个自己写的简单的程序：</strong></p><a id="more"></a><h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><ol><li><strong>计算直角三角形第三边并输出最大边：</strong><pre><code class="python">def zhijiao(X,Y): return (X*X+Y*Y) ** 0.5def feizhijiao(X,Y): return (X*X-Y*Y) ** 0.5print(&#39;所求的角是否为执直角：&#39;)print(&#39;1.Yes 2.No&#39;)tag = int(input())if(tag==1): X=int(input()) Y=int(input()) Z=zhijiao(X,Y) print(&#39;最大边2是&#39;,max(X,Y,Z))else: X = int(input()) Y = int(input()) Z=zhijiao(X, Y) print(&#39;最大边是&#39;,max(X,Y,Z))</code></pre></li><li><strong>随机生成0-10000个随机数并计算花费时间（变相测试电脑性能）：</strong><pre><code class="Python">import timeimport randomnumber = []fu = []dan = []a = float(time.time())for num in range(10000): number.append(random.randint(0,100000))while len(number) &gt;0: number1 = number.pop() if(number1 % 2 == 0):     fu.append(number1) else:     dan.append(number1)b = float(time.time())print(dan)print(fu)print(b-a)</code></pre></li><li><strong>在桌面生产一个具有格式的99乘法表：</strong><pre><code class="Python">file = open(&#39;C://Users/Administrator/Desktop/99.txt&#39;,&#39;w&#39;)for i in range(1,10): j=i while j&lt;=9:     file.write(&#39;&#123;&#125; * &#123;&#125; = &#123;&#125; &#39;.format(i,j,i*j))     j+=1 file.write(&#39;\n&#39;)file.close()</code></pre></li><li><strong>查找并统计一篇英文短文中每个词汇出现的次数：</strong><ul><li>先在桌面存放一个test.txt文件并放入一篇文章</li><li>再运行查词结果会出现在桌面result.txt文件中<pre><code class="Python">import stringpath = &#39;C://Users/Administrator/Desktop/test.txt&#39; #可以文章自定义路径file = open(&#39;C://Users/Administrator/Desktop/result.txt&#39;,&#39;w&#39;) #可以自定义输出结果路径with open(path,&#39;r&#39;) as text:words = [raw_word.strip(string.punctuation).lower() for raw_word in text.read().split()]words_index = set(words)counts_dict = &#123;index:words.count(index) for index in words_index&#125;for word in sorted(counts_dict,key=lambda x: counts_dict[x],reverse=True):print(&#39;&#123;&#125; -- &#123;&#125; times&#39;.format(word,counts_dict[word]))file.write(&#39;&#123;&#125; -- &#123;&#125; times\n&#39;.format(word,counts_dict[word]))</code></pre></li></ul></li><li><strong>输出一个Adidas的Logo</strong><pre><code class="Python">for i in range(1,7): print(&quot; &quot; * 3 * (6 - i) + &quot; &quot; * 44 + &quot;* &quot; * i * 2)</code></pre></li></ol><p>for i in range(1,3):<br>    print(“ “ * i + “ “ * 44 + “* “ * 6 * 2)</p><p>for i in range(1,7):<br>    print(“ “ * 3 * (6 - i) + “ “ * 22 + “* “ * i * 2 + “ “ * 6 + “* “ * 6 * 2)</p><p>for i in range(1,3):<br>    print(“ “ * i + “ “ * 22 + “* “ * 6 * 2 + “ “ * 6 + “* “ * 6 * 2)</p><p>for i in range(1,7):<br>    print(“ “ * 3 * (6 - i) + “* “ * i * 2 + “ “ * 6 + “* “ * 6 * 2 + “ “ * 6 + “* “ * 6 * 2)</p><p>for i in range(1,3):<br>    print(“ “ * i + “* “ * 6 * 2 + “ “ * 6 + “* “ * 6 * 2 + “ “ * 6 + “* “ * 6 * 2)</p><pre><code>效果图：</code></pre><pre><code>                                                       * *                                                     * * * *                                                  * * * * * *                                               * * * * * * * *                                            * * * * * * * * * *                                         * * * * * * * * * * * *                                          * * * * * * * * * * * *                                           * * * * * * * * * * * *                                  * *       * * * * * * * * * * * *                               * * * *       * * * * * * * * * * * *                            * * * * * *       * * * * * * * * * * * *                         * * * * * * * *       * * * * * * * * * * * *                      * * * * * * * * * *       * * * * * * * * * * * *                   * * * * * * * * * * * *       * * * * * * * * * * * *                    * * * * * * * * * * * *       * * * * * * * * * * * *                     * * * * * * * * * * * *       * * * * * * * * * * * *            * *       * * * * * * * * * * * *       * * * * * * * * * * * *         * * * *       * * * * * * * * * * * *       * * * * * * * * * * * *      * * * * * *       * * * * * * * * * * * *       * * * * * * * * * * * *   * * * * * * * *       * * * * * * * * * * * *       * * * * * * * * * * * * </code></pre><hr><hr><hr><hr><pre><code>## 总结**五个简单的小程序是我在学习Python基础语法时候的小练习，目的也是为了掌握Python这门计算机语言，Python和Java同为面向对象的编程语言，上手很快，接下来便是再了解一下第三方库等，慢慢进阶学习爬虫、Django等**</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个精致的Linux系统elementary OS</title>
      <link href="/archives/elementaryos.html"/>
      <url>/archives/elementaryos.html</url>
      
        <content type="html"><![CDATA[<p>elementary OS 操作系统是最漂亮的 Linux 发行版之一。它基于 macOS 外观，同时为 Linux 用户提供了出色的用户体验。如果你已经习惯使用 macOS，则使用 elementary OS 不会有任何问题。</p><a id="more"></a><p><strong>另外，elementary OS 操作系统基于 Ubuntu，因此你可以轻松找到大量应用程序来完成任务。</strong></p><p>elementary OS 不仅限于外观，而且在不断的改进。因此，用户体验会随着每次更新而改善。</p><p>官方网站：<a href="https://elementaryos.cn/">https://elementaryos.cn/</a></p><p>几张预览图：<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-1.png"><br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-5.png"><br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-4.png"><br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-3.png"><br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-2.png"></p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><h3 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h3><ol><li><a href="https://nyc3.dl.elementary.io/download/MTU5NDQzMzQ0NQ==/elementaryos-5.1-stable.20200706.iso">下载地址</a></li><li>磁力链接<pre><code>magnet:?xt=urn:btih:2d27ecbc35c83953aa72778f361355469416a85d&amp;dn=elementaryos-5.1-stable.20200706.iso&amp;tr=https%3A%2F%2Fashrise.com%3A443%2Fphoenix%2Fannounce&amp;tr=udp%3A%2F%2Fopen.demonii.com%3A1337%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.ccc.de%3A80%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.publicbt.com%3A80%2Fannounce&amp;ws=http%3A%2F%2Fnyc3.dl.elementary.io%2Fdownload%2FMTU5NDQzMzQ0NQ%3D%3D%2Felementaryos-5.1-stable.20200706.iso</code></pre></li></ol><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>这里推荐Rufus：<a href="https://rufus.ie/">下载地址</a></p><h3 id="开始安装-1"><a href="#开始安装-1" class="headerlink" title="开始安装"></a>开始安装</h3><p>启动Logo<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-6.png"><br>安装过程:</p><ol><li>选择安装硬盘<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-7.png"></li><li>选择中文和输入法<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-8.png"></li><li>更新和软件设置<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-9.png"></li><li>选择安装类型<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-10.png"></li><li>设置时区<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-11.png"></li><li>设置账户和密码(很重要)<br><img src="https://cdn.jsdelivr.net/gh/HandsomeKY/picture/elementary-12.png"><br>接下来就是等待自行安装</li></ol><h3 id="替换中文软件源"><a href="#替换中文软件源" class="headerlink" title="替换中文软件源"></a>替换中文软件源</h3><ol><li>终端执行命令导入软件仓库密钥串<br><code>sudo wget -O - http://package.elementaryos.cn/bionic/key/package.gpg.key | sudo apt-key add -</code></li><li>使用命令<code>sudo io.elementary.code /etc/apt/sources.list</code>打开文件夹并在最后一行粘贴下面软件源地址信息并保存，添加<code>deb http://package.elementaryos.cn/bionic/ bionic main</code></li><li>终端执行<code>sudo apt update</code>更新软件包缓存</li><li>安装软件包命令为：<br><code>sudo apt install 软件包名</code><br>例如安装TIM命令为：<code>sudo apt install deepin.com.qq.office</code><br>现阶段所有软件包如下：<pre><code>elementary-tweaks (elementary-tweaks配置工具)wingpanel-indicator-ayatana (第三方应用状态栏图标修复、安装后重启)deepin.cn.360.yasuo (360压缩)deepin.cn.com.winrar (WinRAR)deepin.com.baidu.pan (百度网盘（Wine）)baidunetdisk (百度网盘（Linux）)deepin.com.foxmail (Foxmial邮件客户端)deepin.com.qq.im (QQ)deepin.com.taobao.wangwang (阿里旺旺)deepin.com.thunderspeed (迅雷)deepin.com.wechat.devtools (微信开发工具)deepin.com.wechat (微信)deepin.com.weixin.work (企业微信)deepin.org.7-zip (7-zip)deepin.org.foobar2OOO (foobar2000)electron-ssr (酸酸乳)navicat (Navicat数据库管理客户端)netease-cloud-music (网易云音乐)sogoupinyin (搜狗拼音输入法)wps-office (WPS)motrix (motrix下载软件)anydesk (anydesk跨平台远程协助软件)symbol-fonts (WPS字体缺失修复包)</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python换国内镜像源加速下载</title>
      <link href="/archives/python-2.html"/>
      <url>/archives/python-2.html</url>
      
        <content type="html"><![CDATA[<p>由于中国的特殊网络环境，我在下载Python的第三方库时不是网速慢就是网络阻断，这时候就需要把镜像源换成国内的提供商提供的源</p><a id="more"></a><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul><li><p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p></li><li><p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p></li><li><p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p></li><li><p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p></li><li><p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a> </p></li><li><p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p></li></ul><p><strong>note：新版ubuntu要求使用https源，要注意。</strong></p><p><strong>例如：pip3 install -i <a href="https://pypi.doubanio.com/simple/">https://pypi.doubanio.com/simple/</a> 包名</strong></p><h3 id="单次下载"><a href="#单次下载" class="headerlink" title="单次下载"></a>单次下载</h3><p>可以在使用pip的时候加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>例如：pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyspider，这样就会从清华这边的镜像去安装pyspider库。</p><h3 id="固定配置"><a href="#固定配置" class="headerlink" title="固定配置"></a>固定配置</h3><h4 id="Linux下"><a href="#Linux下" class="headerlink" title="Linux下"></a>Linux下</h4><p>修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)</p><p>内容如下：</p><pre><code class="CMD">[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com</code></pre><h4 id="windows下"><a href="#windows下" class="headerlink" title="windows下"></a>windows下</h4><p>直接在user目录中创建一个pip目录，再新建文件pip.ini。（例如：C:\Users\WQP\pip\pip.ini）内容同上。</p><h2 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h2><p>打开files-settings-Project Interpreter-右边加号<br>点击右边‘+’或者‘铅笔’修改即可<br><img src="http://p.ananas.chaoxing.com/star3/origin/029c5ccd900a0ce1128be438ee95f4ac.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一下学习Python</title>
      <link href="/archives/python-1.html"/>
      <url>/archives/python-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>  今天是2020年06月28日，在经历期末课程答辩之后，我也正式迎来了假中假之寒暑连着放，在略懂一点C/C++、Java和Html、CSS后我决定开始了Python的学习，并在这里记录我的学习：</p><a id="more"></a><h2 id="Java和Python语言的优势对比，可以通过以下几个方面来描述："><a href="#Java和Python语言的优势对比，可以通过以下几个方面来描述：" class="headerlink" title="Java和Python语言的优势对比，可以通过以下几个方面来描述："></a>Java和Python语言的优势对比，可以通过以下几个方面来描述：</h2><ol><li>语法结构。在语法结构上，Java语言是纯粹的面向对象语言，语法结构严谨，遵循严格的面向对象编程过程（类的定义、对象的创建、方法的调用）。虽然Java的语法结构比较严谨，但是Java的模块化却是一个“短板”，直到JDK9才解决了这一问题。相对于Java来说，Python的语法结构则更受程序员的欢迎，Python语言的语法结构结合了函数式编程的直接性和面向对象语言的灵活性。</li><li>开发周期。在开发周期方面，Python语言无疑具有较为明显的优势，一个重要的原因在于Python语言有丰富的“库”，Python程序员可以从“造轮子”中解放出来，从而把关注点放在业务逻辑的实现上，这会在很大程度上提升程序的开发效率。</li><li>执行效率。在执行效率方面，Java语言具有一定的优势。Java语言的特点就是稳定的性能表现和较强的扩展能力，这也是为什么大型互联网平台往往更愿意采用Java编写的重要原因。当然，目前Python语言的执行效率也在逐步提升（3系列版本），相信未来在执行效率方面Python会有所改善。<br>Python语言伴随着大数据和人工智能的快速发展而获得了广泛的关注，目前Python语言上升趋势比较明显，也被认为在未来有广阔的发展前景，所以当前学习一下Python语言是个不错的选择。<h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2>Python同样也是面向对象的高级语言，所以安装Python程序安装编译环境同样重要</li></ol><ul><li>打开 WEB 浏览器访问<a href="https://www.python.org/downloads/release/python-383/">https://www.python.org/downloads/release/python-383/</a></li><li>下载并安装<br><img src="http://p.ananas.chaoxing.com/star3/origin/ffa4b5e4418a8ca7286108dff6fe76c5.png"></li><li><strong>一定要点击添加到Path</strong><br><img src="https://img2018.cnblogs.com/blog/1730012/201907/1730012-20190702161422909-257449123.png"><h2 id="安装Pycharm"><a href="#安装Pycharm" class="headerlink" title="安装Pycharm"></a>安装Pycharm</h2>在官网下载安装<a href="https://www.jetbrains.com/pycharm/download/#section=windows">Pycharm</a>即可，下载社区版本（专业版可以学生认证免费用），默认配置安装即可<h2 id="学习电子书"><a href="#学习电子书" class="headerlink" title="学习电子书"></a>学习电子书</h2>虽然已经略懂一点编程，但是入门我还是选择《编程小白的第一本python入门书》<br><img src="http://p.ananas.chaoxing.com/star3/origin/bafe3e4c10968b2d67218709a6fb5447.png"><br>很容易读懂了，上手应该很快，页数也不多</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hxeo插件安装/卸载/推荐</title>
      <link href="/archives/hexo-plug.html"/>
      <url>/archives/hexo-plug.html</url>
      
        <content type="html"><![CDATA[<p>在搭建完利用Github Pages+Hexo搭建完自己的个人博客网站后，需要一些各式各样的插件来实现优化和丰富网站功能的插件，接下来介绍如何安装和卸载hexo的插件，以及一些好用的插件推荐</p><a id="more"></a><h2 id="安装-卸载插件"><a href="#安装-卸载插件" class="headerlink" title="安装/卸载插件"></a>安装/卸载插件</h2><h3 id="安装插件命令"><a href="#安装插件命令" class="headerlink" title="安装插件命令"></a>安装插件命令</h3><p>安装命令一般为：</p><pre><code class="Git">npm install 插件名 --save</code></pre><p>比如：<br><img src="https://raw.githubusercontent.com/HandsomeKY/picture/master/hexo-plug-1.png"></p><h3 id="卸载命令"><a href="#卸载命令" class="headerlink" title="卸载命令"></a>卸载命令</h3><p>打开Git Base，输入</p><pre><code class="Git">npm list</code></pre><p><img src="https://raw.githubusercontent.com/HandsomeKY/picture/master/hexo-plug-3.png"><br>找到要删除插件的名字输入命令：</p><pre><code class="Git">npm uninstall 插件名即可</code></pre><h2 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h2><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p><strong>hexo-prism-plugin</strong> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre><code class="npm">npm i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：</p><pre><code class="YAML">prism_plugin:  mode: &#39;preprocess&#39;    # realtime/preprocess  theme: &#39;tomorrow&#39;     #主题选项  line_number: false    # default false  custom_css:</code></pre><p>可用的主题有</p><blockquote><p>coy,dark,funky,okaidia,solarizedlight,tomorrow,twilight,a11y-dark,atom-dark,base16-ateliersulphurpool.light,cb,darcula,dracula,duotone-dark,duotone-earth,duotone-forest,duotone-light,duotone-sea,duotone-space,ghcolors,hopscotch,material-dark,material-light,material-oceanic,pojoaque,shades-of-purple,synthwave84,vs,xonokai,default</p></blockquote><p>具体样式还转移到这里观看：<a href="https://github.com/PrismJS/prism-themes#available-themes">传送门</a></p><h3 id="搜索插件"><a href="#搜索插件" class="headerlink" title="搜索插件"></a>搜索插件</h3><p><a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre><code class="npm">npm install hexo-generator-search --save</code></pre><h3 id="中文链接转拼音"><a href="#中文链接转拼音" class="headerlink" title="中文链接转拼音"></a>中文链接转拼音</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。<br>安装命令如下：</p><pre><code class="npm">npm i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre><code class="YAML">permalink_pinyin:  enable: true  separator: &#39;-&#39; # default: &#39;-&#39;</code></pre><blockquote><p>注：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a>插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件"><a href="#文章字数统计插件" class="headerlink" title="文章字数统计插件"></a>文章字数统计插件</h3><p>在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。<br>安装命令如下：</p><pre><code class="npm">npm i --save hexo-wordcount</code></pre><p>然后在主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可：</p><pre><code class="YAML">postInfo:  date: true  update: false  wordCount: false # 设置文章字数统计为 true.  totalCount: false # 设置站点文章总字数统计为 true.  min2read: false # 阅读时长.  readCount: false # 阅读次数.</code></pre><h3 id="添加emoji表情支持"><a href="#添加emoji表情支持" class="headerlink" title="添加emoji表情支持"></a>添加emoji表情支持</h3><p>本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下：</p><pre><code class="npm">npm install hexo-filter-github-emojis --save</code></pre><p>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre><code class="YAML">githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:</code></pre><h3 id="添加-RSS-订阅支持"><a href="#添加-RSS-订阅支持" class="headerlink" title="添加 RSS 订阅支持"></a>添加 RSS 订阅支持</h3><p>本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下：</p><pre><code class="npm">npm install hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre><code class="YAML">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: &#39; &#39;  order_by: -date</code></pre><p><strong>执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。</strong></p><h3 id="生成网站地图"><a href="#生成网站地图" class="headerlink" title="生成网站地图"></a>生成网站地图</h3><p>我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎<br>安装sitemap插件如下:</p><pre><code class="bash">npm install hexo-generator-sitemap --save     npm install hexo-generator-baidu-sitemap --save</code></pre><p>修改博客配置文件<br>在根目录配置文件.yml中修改url为你的站点地址</p><pre><code class="YAML"># URL# If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;# url: https://www.zdyn.cn/url: https://www.zdynb.cnroot: /permalink: :year/:month/:day/:title/permalink_defaults:</code></pre><p>执行完hexo g命令之后就会在网站根目录生成sitemap.xml文件和baidusitemap.xml文件，可以通过：<a href="https://www.zdynb.cn/baidusitemap.xml">https://www.zdynb.cn/baidusitemap.xml</a>, 查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。</p><h3 id="设置主动推送"><a href="#设置主动推送" class="headerlink" title="设置主动推送"></a>设置主动推送</h3><p>安装插件hexo-baidu-url-submit</p><pre><code class="bash">npm install hexo-baidu-url-submit --save</code></pre><p>然后再根目录的配置文件中新增字段</p><pre><code class="YAML">baidu_url_submit:  count: 80             # 提交最新链接数量  host: www.zdynb.cn    # 在百度站长平台中注册的域名  token: xxxxxxxxxxxxxx # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt  # 文本文档的地址， 新链接会保存在此文本文档里</code></pre><h3 id="设置自动推送"><a href="#设置自动推送" class="headerlink" title="设置自动推送"></a>设置自动推送</h3><p>在主题配置文件下设置,将baidu_push设置为true:</p><pre><code class="yml"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true</code></pre><p>然后主题文件目录加入下面代码，一般在目录/themes/matery/layout/_partial中的head.ejs中加入下面JS代码（有可能你的目录不是这样，原理类似），这样全站都有了：</p><pre><code class="js">&lt;% if (theme.baidu_push) &#123; %&gt;    &lt;script&gt;        (function()&#123;            var bp = document.createElement(&#39;script&#39;);            var curProtocol = window.location.protocol.split(&#39;:&#39;)[0];            if (curProtocol === &#39;https&#39;) &#123;                bp.src = &#39;https://zz.bdstatic.com/linksubmit/push.js&#39;;                    &#125;            else &#123;                bp.src = &#39;http://push.zhanzhang.baidu.com/push.js&#39;;            &#125;            var s = document.getElementsByTagName(&quot;script&quot;)[0];            s.parentNode.insertBefore(bp, s);        &#125;)();    &lt;/script&gt;&lt;% &#125; %&gt; </code></pre><h3 id="提交-robots-txt"><a href="#提交-robots-txt" class="headerlink" title="提交 robots.txt:"></a>提交 robots.txt:</h3><p>robots.txt 是一种存放于网站根目录下的 ASCII 编码的文本文件，它的作用是告诉搜索引擎此网站中哪些内容是可以被爬取的，哪些是禁止爬取的。robots.txt 放在博客目录下的 source 文件夹中，博客生成后在站点目录 /public/ 下。</p><p>我的 robots.txt 文件内容如下：</p><pre><code class="txt">User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /about/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/</code></pre><p>robots.txt 文件更新至网站后可进入 Google Search Console - 抓取 - robots.txt 测试工具进行测试。</p><h3 id="修改hexo的url"><a href="#修改hexo的url" class="headerlink" title="修改hexo的url"></a>修改hexo的url</h3><p>SEO搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们需要优化一下网站文章url</p><p>安装hexo-abbrlink:</p><pre><code class="npm">npm install hexo-abbrlink --save</code></pre><p>配置博客根目录下的_config.yml文件:</p><pre><code class="YAML"># permalink: :title/permalink: archives/:abbrlink.htmlabbrlink:  alg: crc32  # 算法：crc16(default) and crc32  rep: hex    # 进制：dec(default) and hex</code></pre><p>修改前：</p><p><img src="https://raw.githubusercontent.com/HandsomeKY/picture/master/hexo-plug-2.png"></p><p>修改后：<br><img src="https://raw.githubusercontent.com/HandsomeKY/picture/master/hexo-plugs-4.png"><br>这样就更有利于百度、Google的搜索收录。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>Hexo有丰富的插件和各式各样的主题，如果有更好的主题和插件可以评论或者私信我补充上去，持续更新</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《提问的智慧》</title>
      <link href="/archives/askquestions.html"/>
      <url>/archives/askquestions.html</url>
      
        <content type="html"><![CDATA[<h1 id="提问的智慧"><a href="#提问的智慧" class="headerlink" title="提问的智慧"></a>提问的智慧</h1><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square" alt="PRs Welcome"></a></p><p><strong>How To Ask Questions The Smart Way</strong></p><a id="more"></a><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html">http://www.catb.org/~esr/faqs/smart-questions.html</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p><p>本中文指南是基于原文 3.10 版以及 2010 年由 <a href="https://github.com/gasolin">Gasolin</a> 所翻译版本的最新翻译；</p><p>本文另有<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md">繁體中文版</a>。</p><h2 id="原文版本历史"><a href="#原文版本历史" class="headerlink" title="原文版本历史"></a><a href="https://github.com/ryanhanwu/smartquestions/blob/master/history.md">原文版本历史</a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">在提问之前</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E6%8F%90%E9%97%AE%E6%97%B6">当你提问时</a><ul><li><a href="#%E6%85%8E%E9%80%89%E6%8F%90%E9%97%AE%E7%9A%84%E8%AE%BA%E5%9D%9B">慎选提问的论坛</a></li><li><a href="#stack-overflow">Stack Overflow</a></li><li><a href="#%E7%BD%91%E7%AB%99%E5%92%8C-irc-%E8%AE%BA%E5%9D%9B">网站和 IRC 论坛</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8">第二步，使用项目邮件列表</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%94%E6%8F%8F%E8%BF%B0%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%87%E9%A2%98">使用有意义且描述明确的标题</a></li><li><a href="#%E4%BD%BF%E9%97%AE%E9%A2%98%E5%AE%B9%E6%98%93%E5%9B%9E%E5%A4%8D">使问题容易回复</a></li><li><a href="#%E7%94%A8%E6%B8%85%E6%99%B0%E6%AD%A3%E7%A1%AE%E7%B2%BE%E5%87%86%E5%B9%B6%E5%90%88%E6%B3%95%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AF%AD%E5%8F%A5">用清晰、正确、精准并合法语法的语句</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%98%93%E4%BA%8E%E8%AF%BB%E5%8F%96%E4%B8%94%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98">使用易于读取且标准的文件格式发送问题</a></li><li><a href="#%E7%B2%BE%E7%A1%AE%E5%9C%B0%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E5%B9%B6%E8%A8%80%E4%B9%8B%E6%9C%89%E7%89%A9">精确地描述问题并言之有物</a></li><li><a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a></li><li><a href="#%E5%88%AB%E5%8A%A8%E8%BE%84%E5%A3%B0%E7%A7%B0%E6%89%BE%E5%88%B0-bug">别动辄声称找到 Bug</a></li><li><a href="#%E4%BD%8E%E5%A3%B0%E4%B8%8B%E6%B0%94%E4%B8%8D%E8%83%BD%E4%BB%A3%E6%9B%BF%E4%BD%A0%E7%9A%84%E5%8A%9F%E8%AF%BE">低声下气不能代替你的功课</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6%E8%80%8C%E9%9D%9E%E4%BD%A0%E7%9A%84%E7%8C%9C%E6%B5%8B">描述问题症状而非你的猜测</a></li><li><a href="#%E6%8C%89%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4%E5%85%88%E5%90%8E%E5%88%97%E5%87%BA%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6">按发生时间先后列出问题症状</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BF%87%E7%A8%8B">描述目标而不是过程</a></li><li><a href="#%E5%88%AB%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E7%A7%81%E4%BA%BA%E7%94%B5%E9%82%AE%E5%9B%9E%E5%A4%8D">别要求使用私人电邮回复</a></li><li><a href="#%E6%B8%85%E6%A5%9A%E6%98%8E%E7%A1%AE%E7%9A%84%E8%A1%A8%E8%BE%BE%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E9%9C%80%E6%B1%82">清楚明确的表达你的问题以及需求</a></li><li><a href="#%E8%AF%A2%E9%97%AE%E6%9C%89%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%97%B6">询问有关代码的问题时</a></li><li><a href="#%E5%88%AB%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A%E7%9A%84%E9%97%AE%E9%A2%98%E8%B4%B4%E4%B8%8A%E6%9D%A5">别把自己家庭作业的问题贴上来</a></li><li><a href="#%E5%8E%BB%E6%8E%89%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E6%8F%90%E9%97%AE%E5%8F%A5">去掉无意义的提问句</a></li><li><a href="#%E5%8D%B3%E4%BD%BF%E4%BD%A0%E5%BE%88%E6%80%A5%E4%B9%9F%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%A0%87%E9%A2%98%E5%86%99%E7%B4%A7%E6%80%A5">即使你很急也不要在标题写紧急</a></li><li><a href="#%E7%A4%BC%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%80%AA%E8%80%8C%E4%B8%94%E6%9C%89%E6%97%B6%E8%BF%98%E5%BE%88%E6%9C%89%E5%B8%AE%E5%8A%A9">礼多人不怪，而且有时还很有帮助</a></li><li><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%8E%E5%8A%A0%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%AD%94%E6%A1%88">如何解读答案</a><ul><li><a href="#rtfm-%E5%92%8C-stfw%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E8%BF%98%E6%98%AF%E6%90%9E%E4%B8%8D%E6%87%82">如果还是搞不懂</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%A4%BC%E7%9A%84%E5%9B%9E%E5%BA%94">处理无礼的回应</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%89%AE%E6%BC%94%E5%A4%B1%E8%B4%A5%E8%80%85">如何避免扮演失败者</a></li><li><a href="#%E4%B8%8D%E8%AF%A5%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98">不该问的问题</a></li><li><a href="#%E5%A5%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A0%A2%E9%97%AE%E9%A2%98">好问题与蠢问题</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E5%BE%97%E4%B8%8D%E5%88%B0%E5%9B%9E%E7%AD%94">如果得不到回答</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98">如何更好地回答问题</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90">相关资源</a></li><li><a href="#%E9%B8%A3%E8%B0%A2">鸣谢</a></li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p><p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 <a href="http://groups.google.com/">Google 论坛</a>和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-IRC-论坛"><a href="#网站和-IRC-论坛" class="headerlink" title="网站和 IRC 论坛"></a>网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="用清晰、正确、精准并语法正确的语句"><a href="#用清晰、正确、精准并语法正确的语句" class="headerlink" title="用清晰、正确、精准并语法正确的语句"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确的表达你的问题以及需求"><a href="#清楚明确的表达你的问题以及需求" class="headerlink" title="清楚明确的表达你的问题以及需求"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><p><a id="RTFM"></a></p><h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **<a href="http://lmgtfy.com/">Google 是你的朋友</a>**！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><p><a id="q1"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com/">Google</a> 吗？</p><p><a id="q2"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a></p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我有什么屁事？</li></ul><p><a id="q6"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a>操作。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>]]></content>
      
      
      <categories>
          
          <category> Wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wiki </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动编译OrangeZero的Openwrt固件</title>
      <link href="/archives/openwrt.html"/>
      <url>/archives/openwrt.html</url>
      
        <content type="html"><![CDATA[<p>经过一个星期的整理和完善，也咨询了不少大佬(大佬们不在这个平台，我也不一一艾特了，反正每个项目的完成都不是闭门造车，也希望大家互相交流)，其实项目前几天就完成了，我测试了两天经过没问题，所以现在放出项目链接，也希望各位继续支持。</p><a id="more"></a><p>下图就是我目前经过各位小伙伴推荐和我自己认为不错的插件，在日用插件的基础上又加了一些比较有意思的和和个别人可能会需要插件，编译集成到了固件里面，麻雀虽小五脏俱全。<br><img src="http://p.ananas.chaoxing.com/star3/origin/f51019e4e3b28f7d1d5903e625897d19.png"></p><p>如果继续有好的插件，小伙伴们也可以评论或者私信我下次改进补充。<br>再说一下具体的下载方式，项目地址我是放在Github上了，大家自行搜索，或者打开我放的链接，下载下图那个img结尾的文件，解压刷入就可以，特别提醒可能Github是国外网站，下载速度有点慢，请在合适的网络下下载，如果实在没有，你私信问我，我给你放奶牛快传链接吧，谢谢理解。由于大雕大佬的源码几乎每天都有更新，所以我设置的也是每天早上就更新最新的固件，也不是最新的固件就是好的，所以大家若是觉得那个版本固件好用，记得保存，不要问这个项目固件是不是最新的，你看到的就是最新的，谢谢大家支持,Github:<a href="https://github.com/koyangyang/OrangePi-Zero-OpenWrt">传送门</a><br><img src="http://p.ananas.chaoxing.com/star3/origin/128b541507a79a9543682281900725ea.png"></p>]]></content>
      
      
      <categories>
          
          <category> Openwrt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> openwrt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown写作指北</title>
      <link href="/archives/markdown.html"/>
      <url>/archives/markdown.html</url>
      
        <content type="html"><![CDATA[<p>作为一个写博客的仔，我真的是爱死了Markdown这个编辑语法，语法简洁明了、易读易写，轻量、纯文本、跨平台、兼容性极强还可以转换为 HTML/XHTML、EPUB、PDF、Word、纂写 Gitbook。目前被广泛使用在Wordpress、typehco、Github等主流应用</p><a id="more"></a><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>代码：</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 最小只有六级标题</code></pre><p>效果：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="最小只有六级标题"><a href="#最小只有六级标题" class="headerlink" title="最小只有六级标题"></a>最小只有六级标题</h6><h2 id="2-加粗："><a href="#2-加粗：" class="headerlink" title="2. 加粗："></a>2. 加粗：</h2><p>代码：</p><pre><code>**我被加粗了**</code></pre><p>效果：</p><p><strong>我被加粗了</strong></p><h2 id="3-斜体："><a href="#3-斜体：" class="headerlink" title="3.斜体："></a>3.斜体：</h2><p>代码：</p><pre><code>*我倾斜了了*</code></pre><p>效果：</p><p><em>我倾斜了了</em></p><h2 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4.删除线"></a>4.删除线</h2><p>使用两个 ~ 来标记删除线文本<br>代码：</p><pre><code>~~这是加删除线的文字~~</code></pre><p>效果：<br><del>这是加删除线的文字</del></p><h2 id="5-代码引用："><a href="#5-代码引用：" class="headerlink" title="5.代码引用："></a>5.代码引用：</h2><p>代码：</p><pre><code>&gt; hello markdown!&gt;&gt; hello markdown!</code></pre><p>效果:</p><blockquote><p>hello markdown!</p><blockquote><p>hello markdown!</p></blockquote></blockquote><h2 id="6-代码块："><a href="#6-代码块：" class="headerlink" title="6.代码块："></a>6.代码块：</h2><p>一般的在代码块前使用 4 个空格或者一个 TAB 键：</p><p>SpaceSpaceSpaceSpace 或者 TAB</p><p>但是比较常用的是使用 <code>包住代码块，在开头的</code> 后还可以标记代码的语言类型，比如：<br>代码：</p><pre><code>    ```JavaScript    $(document).ready(function () &#123;    alert(‘RUNOOB’);    &#125;);    ```</code></pre><p>效果：</p><pre><code class="JavaScript">$(document).ready(function () &#123;alert(‘RUNOOB’);&#125;);</code></pre><h2 id="7-短代码块"><a href="#7-短代码块" class="headerlink" title="7.短代码块"></a>7.短代码块</h2><p>对于短代码，使用 ` 包裹住<br>代码：</p><pre><code>`printf`</code></pre><p>效果：</p><p><code>printf</code></p><h2 id="8-链接"><a href="#8-链接" class="headerlink" title="8.链接"></a>8.链接</h2><p>代码:</p><pre><code>[这是链接名称](这是链接地址)&lt;这是自动链接&gt;</code></pre><p>效果：<br>这是我的博客<a href="www.koyang.shop">Koyang’Blog</a><br>这是Koyang’Blog&lt;<a href="http://www.koyang.shop&gt;/">www.koyang.shop&gt;</a><br>这是邮箱：<a href="mailto:&#109;&#x72;&#x2e;&#x6b;&#111;&#x79;&#97;&#110;&#103;&#x79;&#97;&#110;&#x67;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#109;&#x72;&#x2e;&#x6b;&#111;&#x79;&#97;&#110;&#103;&#x79;&#97;&#110;&#x67;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></p><h2 id="9-图片"><a href="#9-图片" class="headerlink" title="9.图片"></a>9.图片</h2><p>代码</p><pre><code>![alt 属性文本](图片地址 “图片标题”)</code></pre><p>效果：<br><img src="https://upload-images.jianshu.io/upload_images/1496626-851332d4c4ebc3d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/450/format/webp" alt="Markdown"></p><h2 id="10-列表"><a href="#10-列表" class="headerlink" title="10.列表"></a>10.列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>代码:</p><pre><code>1. one2. two 3. three</code></pre><p>效果：</p><ol><li>one</li><li>two </li><li>three</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>代码：</p><pre><code>* one* two* three- four- five- six</code></pre><p>效果：</p><ul><li>one</li><li>two</li><li>three</li></ul><ul><li>four</li><li>five</li><li>six</li></ul><h2 id="11-分割线"><a href="#11-分割线" class="headerlink" title="11.分割线"></a>11.分割线</h2><p>代码:</p><pre><code>---</code></pre><p>效果：</p><hr><h2 id="12-数学公式（行内嵌）"><a href="#12-数学公式（行内嵌）" class="headerlink" title="12.数学公式（行内嵌）"></a>12.数学公式（行内嵌）</h2><p>代码：</p><pre><code>内嵌数学公式$\sum_&#123;i=1&#125;^&#123;10&#125;f(i)\,\,\text&#123;thanks&#125;$</code></pre><p>效果：<br>内嵌数学公式$\sum_{i=1}^{10}f(i),,\text{thanks}$</p><h2 id="数学公式（块状）"><a href="#数学公式（块状）" class="headerlink" title="数学公式（块状）"></a>数学公式（块状）</h2><p>代码：</p><pre><code>$$\sum_&#123;i=1&#125;^&#123;10&#125;f(i)\,\,\text&#123;thanks&#125;$$</code></pre><p>效果：<br>$$<br>\sum_{i=1}^{10}f(i),,\text{thanks}<br>$$</p><h2 id="13-媒体部分"><a href="#13-媒体部分" class="headerlink" title="13. 媒体部分"></a>13. 媒体部分</h2><ul><li><p>在markdown里，添加 gif动画</p><pre><code>&lt;img src=&quot;https://n.sinaimg.cn/tech/transform/50/w435h415/20200211/66a2-ipfprtp5563490.gif&quot; alt=&quot;show&quot; /&gt;</code></pre></li><li><p>在markdown里，添加 视频</p><pre><code>&lt;video id=&quot;video&quot; controls=&quot;&quot; preload=&quot;none&quot; poster=&quot;http://img.blog.fandong.me/2017-08-26-Markdown-Advance-Video.jpg&quot;&gt;&lt;source id=&quot;mp4&quot; src=&quot;http://img.blog.fandong.me/2017-08-26-Markdown-Advance-Video.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt;</code></pre></li><li><p>在markdown里，添加 音频</p><pre><code>&lt;audio id=&quot;audio&quot; controls=&quot;&quot; preload=&quot;none&quot;&gt;&lt;source id=&quot;mp3&quot; src=&quot;http://qiniu.cloud.fandong.me/Music_iP%E8%B5%B5%E9%9C%B2%20-%20%E7%A6%BB%E6%AD%8C%20%28Live%29.mp3&quot;&gt;&lt;/audio&gt;</code></pre></li></ul><p><strong>（未完待补充…）</strong></p>]]></content>
      
      
      <categories>
          
          <category> Wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wiki </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何与电脑无线传输</title>
      <link href="/archives/ftp.html"/>
      <url>/archives/ftp.html</url>
      
        <content type="html"><![CDATA[<p>在生活中传一个文件还需要遍地找线？两台电脑之间怎么更方便传输文件？电视怎么浏览电脑视频文件播放？しんじつはいつもbaiひとつ—-搭建Ftp服务，接下来变教你如何搭建Ftp服务并为Ftp服务设置密码</p><a id="more"></a><p><strong>本教程以Windows10 Professional系统为演示，其余Windows系统大同小异，请自行查找对应选项</strong></p><h2 id="什么是Ftp"><a href="#什么是Ftp" class="headerlink" title="什么是Ftp"></a>什么是Ftp</h2><p>FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。</p><h2 id="开启电脑Ftp"><a href="#开启电脑Ftp" class="headerlink" title="开启电脑Ftp"></a>开启电脑Ftp</h2><ul><li>在开始菜单里面找到控制面板-程序-启用或关闭windwos功能<br><img src="http://p.ananas.chaoxing.com/star3/origin/c22993201803f9382db81a804275aa3e.png"></li><li>并找到图中所框区域选中<br><img src="http://p.ananas.chaoxing.com/star3/origin/79ce32de3fdaf7c8027196738ca3485a.png"></li><li>重启电脑</li></ul><h2 id="添加Ftp站点"><a href="#添加Ftp站点" class="headerlink" title="添加Ftp站点"></a>添加Ftp站点</h2><ul><li>在开始菜单找到这个IIS服务<br><img src="http://p.ananas.chaoxing.com/star3/origin/35b09c290fad3198603c7d4fb4238802.png"></li><li>右键添加Ftp站点并设置名称和共享路径<br><img src="http://p.ananas.chaoxing.com/star3/origin/1b79139cfb600ebe365cde37939aaee8.png"></li><li>分配Ip地址，端口默认即可，关闭SSL<br><img src="http://p.ananas.chaoxing.com/star3/origin/a4af906e0bad5e017eeb1e6b4cd7b757.png"></li><li>按图中设置账户等<br><img src="http://p.ananas.chaoxing.com/star3/origin/bd2eecc32b2e95052af3343a3de645fe.png"></li></ul><p><strong>Ps:需要设置密码的把匿名关闭</strong></p><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><h3 id="Pc端"><a href="#Pc端" class="headerlink" title="Pc端"></a>Pc端</h3><p>完成之后便可以在浏览器输入<code>http://你分配的ip</code>，点击文件即可下载</p><h3 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h3><p>在手机下载<strong>X-plore</strong>这个软件并打开，在Ftp这一项新建，输入刚才搭建的Ftp配置信息即可连接<br><img src="http://p.ananas.chaoxing.com/star3/origin/19d6b44547e311b33db2d2c435d61a05.png"></p><h2 id="添加密码"><a href="#添加密码" class="headerlink" title="添加密码"></a>添加密码</h2><ul><li>在计算机右键-管理-本地用户和组-用户-右键添加用户<br><img src="http://p.ananas.chaoxing.com/star3/origin/c847a436ab341fcea6422f5df23f0aae.png"></li><li>再回到IIS这个软件-基本设置-按图上顺序配置添加账户<br><img src="http://p.ananas.chaoxing.com/star3/origin/e62bdadb8baa6b23083aee17c0566703.png"></li></ul><p>现在即可完成账户密码的设置</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ol><li>在自己家使用，没必要设置密码(懂这个的人又不多，你不说也没人知道你搭建了Ftp，更不知道准确的Ip地址)，而且电视访问不需要密码比较方便(电视遥控器输密码真麻烦)</li><li>这个是内网使用，各个设备得在同一个网段下使用</li><li>需要外网可以弄内网穿透，同意也可以向运营商申请公网ip，这样使用范围更广，内网穿透请自行百度，公网申请请致电运营商客服</li><li>Ftp服务可以解锁更多新玩法，比如手机刷机备份…自行发觉交流</li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Hexo+Github Pages搭建个人博客</title>
      <link href="/archives/blog.html"/>
      <url>/archives/blog.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>📰博客 —— 可能这个东西在大多数眼中已经落后于时代甚至压根没听过。在这个信息碎片化、人人信息获取不对等的时代，各个社交平台可以很快速地发送动态、短视频，方便的跟自己的朋友们点赞、互动，而花大量时间金钱和精力去维护一个没人看的博客未免显得有点蠢？</p></blockquote><a id="more"></a><p>其实我觉得这个问题没有一个准确标准的答案，也是价值观的驱动，无非就是你情我愿的事情，对于个人来讲，拥有自己的域名、自己的博客、通过自己的能力创建一个独立空间，完全的自定义建设自己的博客，能够在网络留下自己的所见所得、所想所思、拥有自己的清静的一亩三分地、能够和一同坚持维护自己的博客的人一起交流、交朋友（互换友链）…… 何尝不是一个有意义的事情，总的来说，在允许的范围做任何自己觉得值得的事</p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><p>讲述一下我的博客历程</p><ul><li>第一阶段：接触 WordPress 等大型博客程序，对各种复杂的功能插件和精美的主题感觉很新鲜</li><li>第二阶段：追求更加轻量简洁的 Typecho 程序，使用 MarkDown 进行创作</li><li>第三阶段：希望能够脱离服务器，降低博客维护成本，更加专心于写作而不必花费大量时间在服务器维护上</li></ul><p>接下来讲述用Github Pages + Hexo代码托管仓库的 Pages 功能托管自己的静态博客。</p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><ul><li><p>安装<a href="https://nodejs.org/dist/v12.18.2/node-v12.18.2-x86.msi">Node.js</a></p></li><li><p>安装<a href="https://git-scm.com/">Git</a></p></li></ul><p><strong>上面的两个如果不懂都以默认设置安装就行，如果你需要更改安装路径可能需要自己配置环境变量，这个请自行百度</strong></p><h2 id="安装并搭建Hexo"><a href="#安装并搭建Hexo" class="headerlink" title="安装并搭建Hexo"></a>安装并搭建Hexo</h2><ul><li>全局使用NPM安装Hexo，输入命令<pre><code class="Git">npm install -g hexo-cli</code></pre></li><li>初始化Hexo<br>在你以后想要存储 Hexo 本地源文件的目录打开 Git Bash，然后初始化Hexo，比如我想要在 C 盘的一个名为 hexo 的文件夹进行写作，那我在 C 盘打开 Git Bash 使用下面的命令初始化 Hexo 博客：<pre><code class="Git">hexo init hexo</code></pre>这时候你在C盘打开hexo目录，就是如图所示<br><img src="http://p.ananas.chaoxing.com/star3/origin/2e68523a5aad8c64ede3587dff875419.png"><br>这时候讲一下hexo的目录结构：</li></ul><pre><code>.├── _config.yml # hexo的全局配置文件，在此配置网站的主要参数├── package.json # npm软件包以及版本信息├── scaffolds # 模版文件夹├── source  # 资源文件夹|   ├── _drafts # 草稿/模板文件|   └── _posts # 默认文章Markdowm文件 └── themes  # 主题文件夹目录</code></pre><ul><li>打开hexo目录安装npm<pre><code class="Git">npm install</code></pre></li><li>启动hexo本地预览<pre><code class="Git">hexo s -g</code></pre></li></ul><p><strong>如果觉得npm安装慢的话(需要在合适的网络下才会很快)，可以换阿里巴巴源，为了不影响观看效果和操作流程具体操作步骤我放在结尾处，有需要观看点击目录 换阿里巴巴源</strong></p><p>上述操作进行完后打开浏览器，输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以预览你的博客了</p><h2 id="推送到Github仓库"><a href="#推送到Github仓库" class="headerlink" title="推送到Github仓库"></a>推送到Github仓库</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><ul><li>注册并登录Github账号</li><li>新建一个名为 username.github.io 的 Public 仓库，其中 username 是你的 Github 用户名，比如我的用户名是 koyang，那么我新建的仓库名称即为：koyang.github.io</li><li>点击仓库的 Settings 勾选 Github Pages<h3 id="链接-Git-到远程仓库"><a href="#链接-Git-到远程仓库" class="headerlink" title="链接 Git 到远程仓库"></a>链接 Git 到远程仓库</h3></li><li>打开Git Bash，分别输入以下命令：<pre><code>git config --global user.name &quot;username&quot; # username是你的Github用户名，注意大小写保持一致git config --global user.email &quot;your email address&quot; # your email address填写你的Github注册用的邮箱ssh-keygen -t rsa -C &quot;your email address&quot;  # 生成SSH公钥，your email address同上填</code></pre></li></ul><pre><code>- 在 C:\Users\用户名\.ssh\ 目录下，以文本编辑器打开 id_rsa.pub 文件，复制里面的所有内容![](http://p.ananas.chaoxing.com/star3/origin/7e84188a6182c6f4a0d6f24b84df15c1.png)- 添加到Github-在 Github 点开自己头像打开- Settings-选择 SSH and GPG Keys，点击 New SSH Key，添加刚才复制的id_rsa.pub![](http://p.ananas.chaoxing.com/star3/origin/4c9d338cb967ce54dd847c1edd8d7ed5.png)然后再在Git Bash输入</code></pre><p>ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a></p><pre><code>出现提示：(Hi 用户名！You’ve successfully authenticated，but……)就说明已经可以Git了- 打开 hexo 目录下的_config.yml 文件，修改最后一行的 deploy 配置信息：```Gitdeploy:  type: git  repo:    github: https://github.com/username/username.github.io.git # 将username修改成你的Github用户名  branch: master #表示部署到仓库的默认master(主)分支</code></pre><ul><li>安装Git插件<br>打开hexo目录Git Bash，输入<pre><code class="Git">npm install hexo-deployer-git --save</code></pre>附上hexo命令<pre><code class="Git">$ hexo clean # 清除生成的静态文件$ hexo g # 生成新的博客静态文件$ hexo s # 启动本地预览$ hexo d # 推送博客静态文件到远程仓库</code></pre>执行上面命令，你发现 hexo d 后本地预览的博客已经推送到你的远程仓库了，并且浏览器地址输入 username.github.io 可以访问你的博客了，代表关联 Hexo 到 Github 成功了！</li></ul><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>如果你觉得github.io域名不好看。可以选择自定义自己的域名</p><ul><li>进入自己的域名控制台，添加一条 CNAME 记录，记录值是你的博客的仓库名，比如我的：<br><img src="http://p.ananas.chaoxing.com/star3/origin/dc5891321b8237ccbebbbd8ad7a7475a.png"></li><li>打开你博客仓库的 Settings，找到 Github Pages 栏填入你自己的域名，比如我的是：koyang.shop<br><img src="http://p.ananas.chaoxing.com/star3/origin/972a0345cc0ee53d2b1021377514f6f6.png"></li><li>强制全局https,这样就可以使用Github<br><img src="http://p.ananas.chaoxing.com/star3/origin/58333bfab52e3d764ca350bd6d2a96ce.png"></li><li>这时候就可以输入自定义域名访问网站</li></ul><h2 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h2><p>这里推荐cards主题</p><ul><li>打开Git Bash输入<pre><code class="Git">cd hexogit clone https://github.com/ChrAlpha/hexo-theme-cards.git themes/cards</code></pre></li><li>修改_config.yml<pre><code>theme: cards</code></pre></li><li>重新生成<pre><code>hexo cleanhexo ghexo s/d</code></pre>各种主题的进阶配置以及详细说明请看主题作者写的文档</li></ul><h2 id="自定义网站信息"><a href="#自定义网站信息" class="headerlink" title="自定义网站信息"></a>自定义网站信息</h2><p>您可以在 hexo 的 _config.yml 中修改大部分的站点配置，Hexo 的配置文件使用 YAML 语法，请注意空格和字符缩进</p><table><thead><tr><th>参数</th><th>表头</th></tr></thead><tbody><tr><td>title</td><td>网站标题</td></tr><tr><td>subtitle</td><td>网站副标题</td></tr><tr><td>description</td><td>网站描述</td></tr><tr><td>keywords</td><td>网站的关键词，使用半角逗号 , 分隔多个关键词</td></tr><tr><td>author</td><td>网站作者名称</td></tr><tr><td>language</td><td>网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans 和 zh-CN。</td></tr><tr><td>timezone</td><td>网站时区，一般的，对于中国大陆地区可以使用 Asia/Shanghai</td></tr></tbody></table><h2 id="换阿里巴巴源"><a href="#换阿里巴巴源" class="headerlink" title="换阿里巴巴源"></a>换阿里巴巴源</h2><p>1.使用阿里定制的 cnpm 命令行工具代替默认的 npm，输入下面代码进行安装：</p><pre><code class="Git">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>以后安装插件只需要使用<code>cnpm intall</code>即可。</p><p>2.如果习惯了npm，又不想使用cnpm怎么办呢？也不是没有办法。</p><p>输入以下命令：</p><pre><code class="Git">npm config set registry https://registry.npm.taobao.org</code></pre><p>再输入：</p><pre><code class="Git">npm config list</code></pre><p>可以看到，已经换源了：</p><pre><code class="Git">$ npm config list; cli configsmetrics-registry = &quot;https://registry.npm.taobao.org/&quot;scope = &quot;&quot;user-agent = &quot;npm/6.4.1 node/v10.15.1 linux x64&quot;; userconfig /home/dounine/.npmrcregistry = &quot;https://registry.npm.taobao.org/&quot;; node bin location = /usr/app/node-v10.15.1/bin/node; cwd = /usr/app/node-v10.15.1/lib/node_modules; HOME = /home/dounine; &quot;npm config ls -l&quot; to show all defaults.</code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><ul><li>主题还是推荐看看作者的帮助文档，毕竟这个只有作者知道具体配置</li><li>绝大多数问题你都可以通过浏览器检索和阅读 <a href="https://hexo.io/zh-cn/docs/configuration">Hexo 文档</a>或者主题文档找到解决方法。如果你在使用中遇到一些无法理解、无法解决的问题也希望你在了解<a href="https://www.koyang.shop/2020/06/24/askquestions/">提问的智慧</a>后再进行提问，所有人的时间都很宝贵，熟读<a href="https://www.koyang.shop/2020/06/24/askquestions/">提问的智慧</a>可以一定程度上让你少走弯路</li><li>如果觉得加载的慢可以考虑使用CDN加速一下</li><li>也不是主题越花里胡哨越好，插件越多越好，合适的才是最好的</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈自己的建站经历</title>
      <link href="/archives/hexo.html"/>
      <url>/archives/hexo.html</url>
      
        <content type="html"><![CDATA[<p>  说起来也尝试过好几种个人博客，比如大众所熟悉的Wordpress、Typecho、Hexo都有尝试，最终还是落脚在Hexo上，接下来便是聊聊这几个个人博客的优劣所在：</p><a id="more"></a><h2 id="Wordpress："><a href="#Wordpress：" class="headerlink" title="Wordpress："></a>Wordpress：</h2><ol><li>为啥把Wordpress放在最前面，因为他是对新手最友好的一个博客框架，一个服务器+宝塔提供脚本可以让你在十分钟内搭建一个博客网站，外加十分庞大的内容管理系统也支持Markdown编辑体验十分爆表，外加提供很多主题和很多主题开发者让这个博客看起来十分美观内容十分丰富，更主要还支持很多插件，而且官网提供手机客户端，可以跨设备编辑。</li><li>体验感十足为啥最终被Pass，因为Wordpress主要还是需要服务器的支持（还得提供金钱和时间去维护），Wordpress功能丰富意味着占用资源更大，更臃肿，而且Wordpress服务器在国外（对那些服务器在国外的人比较友好）<h2 id="Typecho："><a href="#Typecho：" class="headerlink" title="Typecho："></a>Typecho：</h2></li><li>Typecho比较轻巧，占用内存比较小，而且是国人开发的，设计风格肯定对国人有好的，同样支持Markdown，搭建方法也是一台服务器+宝塔提供脚本可以在十分钟内搭建一个博客网站，官网提供一些主题但是很多开发者提供了不少好看的主题，相对于Wordpress启动速度更快，同意由很多插件</li><li>Typecho最终被Pass因为后台不提供上传主题和插件，得自己上传到服务器的根目录并在后台启用，最主要因素是因为服务器（同样需要金钱和时间的维护与投入）<h2 id="Hexo："><a href="#Hexo：" class="headerlink" title="Hexo："></a>Hexo：</h2></li><li>Hexo是一个静态网页，一个不需要服务器的（部署到Github Pages上，薅资本的羊毛），最快可以在五分钟内搭建一个博客网站，主要功能没有Wordpress和Typecho多，但是同样有不少主题和定制插件可以添加，最主要是摆脱了对服务器的维护，更不用为域名、备案、CDN等等头疼</li></ol><ul><li>免费 - Github</li><li>快速 - Node运行环境、前端个人站点的首选</li><li>简洁 - Markdown</li><li>轻量 - 全部静态文件</li></ul><ol start="2"><li>更换电脑不变 - 需重新安装环境，静态博客 - 后期不便于维护，多媒体管理较难</li></ol><h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><p>Hexo的服务器在Github，除了手动删库别的不用担心数据的丢失，以前用Wordpress和Typecho写的很多篇博文都丢失了，手动难受一会，最终向资本低头。放上一个谷歌测速网测试结果：</p><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p><img src="http://p.ananas.chaoxing.com/star3/origin/58ad4e21446b601d5266f1655b0c6065.png" alt="mobilephone"></p><h3 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h3><p><img src="http://p.ananas.chaoxing.com/star3/origin/d0aaa1993d63ad3248bfd0599150c5f9.png" alt="desktop"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 网站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
